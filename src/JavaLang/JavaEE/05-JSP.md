---
title: 05-Jsp
date: 2021-12-04 22:19:50
category: JavaWeb
tag:
 - Java
 - JavaWeb
 - Jsp
---

## 基本介绍

​  Jsp的全称是 Java Server Pages，Java的服务器页面

​  JSP的主要作用是替代Servlet程序回传HTML页面的数据

​  因为Servlet程序回传HTML页面数据是一件非常繁琐的事情，开发成本和维护成本都极高

​  (我上一个文章用的并非是完整的SSM思想，正确的SSM思想是在收到用户数据后回传HTML页面，并让用户跳转到指定页面)

​  **Jsp目前来说可以算是一个过时的东西，前后端分离才是主流**

​  或者说SSM也是一个过时的东西（耦合性太高了）  

​  但还是有必要学习下

比如说我们正常的通过流来传输一些HTML数据，是比较繁琐的

假设需要动态传递给客户端数据（不用ajax的前提下）

![image-20211206120843372](/images/Java/JavaEE/05-JSP/image-20211206120843372.png)

截下来使用JSP来简化这一步操作

在webapp目录下新建一个a.jsp

```html
<%--
  Created by IntelliJ IDEA.
  User: Amayakite
  Date: 2021/12/6
  Time: 12:09
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
这里可以写任意的HTML内容，相当于是一个增强版的HTML，具体后面说
</body>
</html>

```

### JSP的本质

本事是一个Servlet

我们现在创建一个`a.jsp`和`b.jsp`，在里面写入不同的内容，然后试图访问他们两

打包后的资源文件夹位置如下所示

![image-20211206123334428](/images/Java/JavaEE/05-JSP/image-20211206123334428.png)我们先进入这个文件夹，然后访问a.jsp，看看会发生什么：

![image-20211206123425700](/images/Java/JavaEE/05-JSP/image-20211206123425700.png)可以看到，未访问的时候，该文件夹下的`work\Catalina\localhost\jsp\org\apache\jsp`这个路境内首先只有一个index_jsp.class

访问后：

![image-20211206123540480](/images/Java/JavaEE/05-JSP/image-20211206123540480.png)

然后看看a.jsp的源码：

```java
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/10.0.13
 * Generated at: 2021-12-06 04:35:26 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import jakarta.servlet.*;
import jakarta.servlet.http.*;
import jakarta.servlet.jsp.*;

//HttpJspBase 这个类之前说过 相当于HttpServlet的子类  也就是说是一个Servlet程序
public final class a_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {
 //.... 这里省略一堆代码
  public void _jspService(final jakarta.servlet.http.HttpServletRequest request, final jakarta.servlet.http.HttpServletResponse response)
      throws java.io.IOException, jakarta.servlet.ServletException {

      //这里省略一堆判定内容


    try {
        //熟悉的流
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
         null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\r\n");
      out.write("\r\n");
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("    <title>Title</title>\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");
      out.write("<h1>这里是A.jsp</h1>\r\n");
      out.write("</body>\r\n");
      out.write("</html>\r\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof jakarta.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}

```

总结：经过查看`a.jsp`自动转换成的java程序，可以得到结果，jsp就是Servlet程序

### 头部的page指令和它的属性

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
```

可以看到，它的头部有这样一个玩意

他可以修改jsp页面中的一些重要的属性或者行为

page中可以写上去的属性

|    属性名    | 作用                                                                                                                                                               |                                       示例                                       |
| :----------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------: |
|   language   | 表示jsp翻译后是什么语言文件<br />暂时只支持Java                                                                                                                    |                                 language="java"                                  |
| contentType  | 表示jsp返回的数据类型<br />就相当于Servlet中的setContenType                                                                                                        |                             contentType="image/png"                              |
| pageEncoding | 表示当前jsp页面文件本身的字符集                                                                                                                                    |                               pageEncoding="utf-8"                               |
|    import    | 跟Java源代码中一样<br />用导包的方式倒类                                                                                                                           | <%@page import="java.util.ArrayList" %><br /> <%@page import="java.util.List" %> |
|  autoFlush   | 设置当out输出流缓冲区满了之后<br />是否自动刷新缓冲区<br />默认为true<br />一般不会用这玩意                                                                        |                                 autoFlush="true"                                 |
|    buffer    | 设置out输出流缓冲区的大小<br />默认是8kb<br />一般也是不动它                                                                                                       |                                   buffer="8kb"                                   |
|  errorPage   | 当JSP页面运行时出错<br />自动跳转去的错误页面路径<br />这个路径一般都是以斜杠大头<br />它表示请求地址为：<br /><http://ip:port/工程路径/><br />映射到代码的web目录 |                errorPage="/error"<br />errorPage="/error500.jsp"                 |
| isErrorPage  | 设置当前jsp页面是否是错误信息页面<br />默认是false<br />如果设置为true可以获取异常信息                                                                             |                                                                                  |
|   session    | 设置访问当前jsp页面，是否会创建<br />HttpSession对象，默认是true<br />也就是是否能创建Session对象<br />一般不动它                                                  |                                                                                  |
|   extends    | 设置jsp翻译出来的java类默认继承谁<br />一般不动它，让tomcat自动生成                                                                                                |                         extends="xxx.xx.xxx.xxx"\|<br />                         |

## Jsp中的常用脚本

### 声明脚本

格式`<%! 这里写java代码 %>`

作用：可以给jsp编译出来的Java类定义属性和方法，例如这样：

```html
<%!
    public static List<String> list = new ArrayList<String>();
    public static void add(String s){
        list.add(s);
    }
%>
```

- 声明类属性
- 声明static静态代码块
- 声明类方法
- 声明内部类

在ieda中，在这个声明脚本中使用的类会自动导入

```html
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>
<%!
//声明类属性
    private Integer id;
    private String name;
//静态属性
    private static Map<String,Object> map;
//声明static静态代码块
    static{
        map = new HashMap<String,Object>();
        map.put("id",1);
        map.put("name","张三");
        System.out.println("Hello Jsp!");
    }
//声明类方法
    public int abc(){
        return 1;
    }
//声明内部类
 public static class A{
        private Inetger id = 12;
        private String abc = "abc";
    }
%>
```

访问后，我们的控制台(不是浏览器的)成功输出了：Hello Jsp!

接下来看看源码他们都变成了啥：直接转换成了java代码...

![image-20211206141244413](/images/Java/JavaEE/05-JSP/image-20211206141244413.png)

### 使用声明脚本导入自己的类的时候注意事项

语法：`<%@ page import="包名" %>`

注意 这个包名不能是没有任何目录的，必须得com.xxx.xxx.xx

比如Person

```html
<%@ page import="Person" %>
你的包就在java的根目录下 然后这样导入了，但还是会出现异常
必须得将它放在一些其他的包中，例如com.test.Person
然后：
<%@ page import="com.test.Person" %>
```

并且，需要安装一个依赖，不然一定会在运行时出错

<https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-catalina>

根据你的tomcat版本安装，我这里是10.0.13

```xml
<!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-catalina -->
<dependency>
    <groupId>org.apache.tomcat</groupId>
    <artifactId>tomcat-catalina</artifactId>
    <version>10.0.13</version>
</dependency>

```

这个包

### 表达式脚本(目前来说较少使用)

格式：`<!= 这里写表达式 !>`

表达式脚本的作用是：在jsp页面上输出数据

可以输出的数据：

- 整数
- 浮点
- 字符串
- Object(自动调用Object的toString()方法，就像是字符输出流.write()那样)

在里面可以调用之前定义的方法

```html
<body>
<h1>这里是A.jsp</h1>
<%=12%><br>
<%=12.34%><br>
<%="Hello 表达式脚本"%><br>
<%=map%><br>
<%=abc()%><br>

</body>
```

![image-20211206140558244](/images/Java/JavaEE/05-JSP/image-20211206140558244.png)

看下编译后的源码：哦原来是自动帮我们转换成了`out.print()`

```java
out.print("Hello 表达式脚本");
out.write("<br>\r\n");
out.print(map);
out.write("<br>\r\n");
out.print(abc());
out.write("<br>\r\n");
out.write("\r\n");
out.write("</body>\r\n");
```

#### 表达式脚本的特点

1. 所有表达式都会被翻译到`_jspService(req,res)`方法中
2. 所有表达式都会被翻译成为`out.print()`输出到页面上
3. 由于表达式脚本翻译的内容都在`_jspService(req,res)`方法中，所以在所有在这个类中定义的对象都可以直接使用（比如说之前定义的声明脚本中的对象）
4. 脚本表达式中的表达式不能以`;`号结束（看源码就知道了，把我们写在里面的代码原原本本的放进`out.print()`里面了）

### 代码脚本

格式：`<% 这里写Java语句 %>`

作用：可以在Jsp页面中，编写我们自己需要的功能（得是Java语句）

注意：运行的时间根据我们拜访的位置决定

```html
<hr>
<%--if语句--%>
<%
    if (true) {
        System.out.println("if语句");
    }
%>
<%
    int i = 5;
    for (int i1 = 0; i1 < i; i1++) {
        System.out.println(i1);
    }
%>
<%--可以自由操作_jspService中的对象(req,res)或者这个类中的其他对象--%>
<%
    //注意 这个write是jspService方法中生成的流对象
    out.write("测试 脚本<br>");
    out.write((String) map.get("name")+"<br>");

%>

```

![image-20211206142755283](/images/Java/JavaEE/05-JSP/image-20211206142755283.png)

编译后的Java文件

![image-20211206142845918](/images/Java/JavaEE/05-JSP/image-20211206142845918.png)

#### 代码脚本的特点和注意事项

1. 代码脚本翻译之后都是在`_jspService`方法中

2. 代码脚本由于翻译到`_jspService`方法中，所以在`_jspService`方法中现有的对象都可以直接使用

3. 代码脚本还可以由多个代码脚本快组合完成一个完整的语句

   ```html
   <%
       if (true) {%>
   <%
           System.out.println("if语句");
       }
   %>
   这样不会出错，并且能正常运行...但是不推荐这样用
   ```

4. 也可以和表达式脚本一块使用：

   ```html
   <%
       int i = 5;
    for (int i1 = 0; i1 < i; i1++) {%>
   <%=i%>
   <%
       }
   %>
   这样可以在浏览器上看到0~5
   但是依旧不推荐使用
   ```

### JSP中的三种注释方式

1. HTML注释：`<!--这里是HTML注释-->`
   - 会编译到Java源代码中，会在HTML端显示
2. JSP注释：`<%--这里写JSP注释--%>`
   - 不会编译到任何文件中，只是给自个看的
3. Java注释：就正常的Java注释
   - 会编译到Java源代码中，能在Java源代码中看到
   - 不能在HTML中看到

## JSP的九大内置对象

​  Tomcat在编译jsp页面成为Servlet源码后，内部会提供九个对象

![image-20211206144442202](/images/Java/JavaEE/05-JSP/image-20211206144442202.png)

### 四大域对象

​  使用方法都跟`Context`全局上下文对象一样，可以自由增删改查数据（都很像是map）

分别是：

- pageContext ：JSP的上下文对象
  - 当前jsp页面范围内有效
- request：请求对象
  - 一次请求内有效
- session：会话对象
  - 一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器）
- application：ServletContext全局域对象(`getServletContext()`)
  - 整个Web范围都有效，只要web项目不关闭，就一直在

### jsp中的out输出和res.getWrite输出的区别

- out根据当前的位置来输出

- res.getWrite的输出位置在out之前

先看一个代码吧：

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<%
    out.write("这个是out输出的内容<br>");
    response.getWriter().write("这个是response输出的内容<br>");
%>

</body>
</html>
```

你在此时是不是觉得输出内容很正常，先是out，再是res，但结果是：

![image-20211206145400795](/images/Java/JavaEE/05-JSP/image-20211206145400795.png)

emm遇事不决先看源码：

![image-20211206145505903](/images/Java/JavaEE/05-JSP/image-20211206145505903.png)

源码似乎并没有什么问题，接下来分析下

![image-20211206150030961](/images/Java/JavaEE/05-JSP/image-20211206150030961.png) 说以说，我们可以通过提前调用out.flush的方式来让out中的内容比res中的内容先一步渲染出去

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<%
    out.write("这个是out输出的内容<br>");
    out.flush();
    response.getWriter().write("这个是response输出的内容<br>");
%>

</body>
</html>
```

结果：

![image-20211206150147744](/images/Java/JavaEE/05-JSP/image-20211206150147744.png)

### out.write和out.print的区别

如果你试图这样：`out.write(12)`，就能发现页面上啥都没显示

![image-20211206150649757](/images/Java/JavaEE/05-JSP/image-20211206150649757.png)

但是换成print却又可以

这里简单说下吧：

调用`out.print`的时候，会根据传入的值动态的转换为字符串类型，但是write不会

所以你明确的知道自己要输出的是字符串的话，就用write，如果不是的话就用print()

算了还是仔细分析下源码吧：

1. 首先out对象维护了一个数组（字符缓冲区）`char[] chars``
2. ``write`是直接将值转换成`char`并放入数组中`chars[index]=(char)1`
3. 1转换成char就是一个ascii码字符了(乱码的)
4. 如果是`char c = '1'` 那么转换为`(int)c`就是`49`
5. 所以说，如果要将1 放入到char数组中，则需要：`chars[index]=(char)49`

但是write没有这样做。。print做的方法是：无论传入的是任何类型，都会先转换成字符串类型（比如boolean就转换成“true”和"false"这两个字符串）并传递给write，这样write这样接收到的就始终是字符串中相应数据的编码，就不会出错的了

## JSP常用的标签

众所周知，大部分网站中的结构都是这样的：

![image-20211206151722723](/images/Java/JavaEE/05-JSP/image-20211206151722723.png)

​  假设你现在有一个网站，有10w个页面，如果每个页面都这样写重复的内容，那岂不是太难受了，并且修改的时候也要10w个页面的内容都一起改

​  所以就要用到JSP中的标签（这玩意用起来跟Vue之类的有点像，不过Vue之类的都是Diff渲染，这个是服务端渲染）

### 静态包含

就是这样：

![image-20211206152007851](/images/Java/JavaEE/05-JSP/image-20211206152007851.png)

语法：

`<%@ include file="文件名.jsp" %>`

file属性指定要包含的jsp页面的路径，地址中第一个斜杠表示`http://ip:port/工程路径/`，映射到代码的web目录

特点：

1. 静态包含不会编译被包含的jsp页面
2. 静态包含其实就是把被包含的jsp页面的代码拷贝到包含的位置进行输出

实例：`include/main.jsp`

```html

<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>头部信息</h1><br>
<h1>主要信息</h1><br>
<%@ include file="/include/footer.jsp" %>
</body>
</html>
```

`include/footer.jsp`

```html

<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
这里是独立的页脚信息
</body>
</html>

```

结果：

![image-20211206152620654](/images/Java/JavaEE/05-JSP/image-20211206152620654.png)

分析下源码：

![image-20211206152719104](/images/Java/JavaEE/05-JSP/image-20211206152719104.png)

草，直接把哪个页面的out中的所有内容搬到这里来了......

### JSP动态包含

先说下使用原则：简单的代码用静态包含，有逻辑的复杂一点的代码用动态包含

实际工作中，静态包含用的多一些，

语法：`<jsp:include page="资源路径和资源名"></jsp:include>`

也可以简写成：`<jsp:include page="资源路径和资源名"/>`

特点：

1. 动态包含会把包含的jsp页面也翻译成为Java代码

2. 动态包含底层使用如下代码去调用被包含的jsp页面执行输出

   ```java
   org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, "资源和路径名", out, false);
   ```

   ![image-20211206154103227](/images/Java/JavaEE/05-JSP/image-20211206154103227.png)

3. 动态包含还可以传递参数：

   ```html
   <jsp:include page="/include/footer.jsp">
       <jsp:param name="name" value="李四"/>
       <jsp:param name="password" value="王老五"/>
   </jsp:include>
   ```

实例：

```html

<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>头部信息</h1><br>
<h1>主要信息</h1><br>
<%--<%@ include file="/include/footer.jsp" %>--%>
<jsp:include page="/include/footer.jsp">
    <jsp:param name="name" value="李四"/>
    <jsp:param name="password" value="王老五"/>
</jsp:include>
</body>
</html>

```

footer:

```html
<%--
  Created by IntelliJ IDEA.
  User: Amayakite
  Date: 2021/12/6
  Time: 15:22
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
这里是独立的页脚信息
<%--获取参数--%>
<%=request.getParameter("name") %>>
<%=request.getParameter("password") %>>
</body>
</html>

```

效果：

![image-20211206154340122](/images/Java/JavaEE/05-JSP/image-20211206154340122.png)

和静态包含不同的是，他会生成被包含的文件的编译文件：

![image-20211206153413808](/images/Java/JavaEE/05-JSP/image-20211206153413808.png)

并且在源码中调用了这样一个方法：

```java
out.write("<h1>头部信息</h1><br>\r\n");
out.write("<h1>主要信息</h1><br>\r\n");
out.write('\r');
out.write('\n');
//
org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, "/include/footer.jsp", out, false);

out.write("\r\n");
out.write("</body>\r\n");
out.write("</html>\r\n");
```

### JSP请求转发标签

这个不是重定向不是重定向这个不是重定向不是重定向这个不是重定向不是重定向这个不是重定向不是重定向

非常简单：

```html

<%--你可以选择在Servlet中的转发方式--%>
<%
    request.getRequestDispatcher("/a.jsp").forward(request, response);
%>

<%--或者通过jsp的转发标签来实现--%>
<jsp:forward page="/a.jsp">
    <jsp:param name="root" value="123456"/>
</jsp:forward>
```

## Listener监听器

1. Listener监听器是JavaWeb的三大组件之一，JavaWeb的三大组件分别是：Servlet程序，Filter过滤器和Listener监听器
2. Listener和Servlet一样，是一个JavaEE定义的规范（接口）
3. 监听器的作用是：监听某种事物的变化，通过回调函数，反馈给程序（客户端）去做一些相对应的事情
   - 就有点像是emmmVue的Vuex和React的Redux
4. 监听器有八个，但是随着时代变化，到现在还有人用的就只剩下了:
   - `ServletContextListener`
   - `HttpSessionListener`
   - `ServletRequestListener`

关于他们的话这里有[一篇文章](https://blog.csdn.net/li_jia_wei/article/details/79658205)可以概况

### ServletContextListener监听器

​  其他的用法跟这个都差不多

​  ServletContextListener可以监听ServletContext对象的创建和销毁

​  ServletContext在Web工程启动的时候创建，全局唯一，在Web停止的时候销毁

​  ServletContextListener在监听到ServletContext监听和销毁后都会被调用

​  坚挺到创建和销毁之后都会分别调用`ServletContextListener`的方法反馈

两个方法分别是：

 ```java
 public interface ServletContextListener extends EventListener {
 
     /**
      * 在ServletContext对象创建之后马上调用，做初始化
      */
     public default void contextInitialized(ServletContextEvent sce) {
     }
 
     /**
   * 在ServletContext销毁的时候调用，做一些后续资源的关闭等
      */
     public default void contextDestroyed(ServletContextEvent sce) {
     }
 }
 ```

使用方法：

1. 编写类去实现ServletContextListener接口
2. 重写两个方法
3. 在WEB.xml中通过`<listener>`标签或者在那个类的顶部加个`@WebListener`来注册监听器

```java
@WebListener
public class MyListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println("程序启动辣");
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println("程序结束辣");
    }
}
```

如果要在xml中配置监听器的话：

```xml
<listener>
  <listener-class>xx.xx.xx.MyListener</listener-class>
</listener>
```

效果：

![image-20211206162047442](/images/Java/JavaEE/05-JSP/image-20211206162047442.png)

## EL表达式

全程：Expression Language 是表达式语言

作用：主要是替代JSP页面中表达式脚本在JSP页面中输出

格式：`${表达式}`，在输出null值的时候，会自动转换成空字符串`""`

EL表达式在输出数据的时候，要比JSP表达式更简洁

使用之前，需要在这个页面中设置下isELIgnored属性=false 否则表达式将不会生效

```html
<%@ page isELIgnored="false"
%>
```

并且提前安装好了这个包

```xml
<!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-jsp-api -->
<dependency>
    <groupId>org.apache.tomcat</groupId>
    <artifactId>tomcat-jsp-api</artifactId>
    <version>10.0.13</version>  这里根据你自己的tomcat版本来
</dependency>

```

使用：举个很简单的例子：

```html
<%
request.setAttribute("key","123");
%>
JS表达式：<%=request.getAttribute("key")%>
EL表达式：${key}
```

![image-20211206164556420](/images/Java/JavaEE/05-JSP/image-20211206164556420.png)

### El表达式搜索区域的顺序

按照就近原则：pageContext>request>session>application(Context)从小到大来搜索

```html
<%
    pageContext.setAttribute("key", "pageContext");
    request.setAttribute("key", "request");
    session.setAttribute("key", "session");
    application.setAttribute("key", "application");

%>
EL表达式：${key}
<%--输出结果应该是：pageContext--%>
```

![image-20211206165002714](/images/Java/JavaEE/05-JSP/image-20211206165002714.png)

### EL表达式输出Bean的普通属性、数组属性、List集合属性、Map集合属性

上代码：

```html
<%
    Person person = new Person("张三", 20);
    List<Person> list = new ArrayList<>();
    list.add(person);
    list.add(new Person("李四", 30));
    HashMap<String, Person> map = new HashMap<>();
    map.put("person", person);
    map.put("person2", new Person("王五", 40));
    pageContext.setAttribute("person", person);
    pageContext.setAttribute("list", list);
    pageContext.setAttribute("map", map);

%>
EL表达式读取Object：${person}
<br>
<%--读取属性实际上是通过反射机制来读取的，这样private的属性也能读取到--%>
EL表达式读取Person的属性:${person.name}
<br>
<%--这里读取数组同理--%>
EL表达式读取List的属性:${list[0].name}
<br>
<%--EL输出list--%>
EL表达式输出list:${list}
<br>
EL表达式读取Map的属性:${map.person.name}
<br>
<%--EL输出集合--%>
EL表达式输出map：${map}
```

结果：

![image-20211206171508674](/images/Java/JavaEE/05-JSP/image-20211206171508674.png)

### EL表达式-运算

#### 关系运算

![image-20211206171750922](/images/Java/JavaEE/05-JSP/image-20211206171750922.png)

关系运算是通过方法内的equals来决定的

#### 逻辑运算

![image-20211206171800762](/images/Java/JavaEE/05-JSP/image-20211206171800762.png)

还有

- 算数运算
- empty运算
  - 这玩意是判断一个数据是否为空，如果为空则输出true，否则false
  - 如果说字符串是空串的话也是会判定为空
  - Object数组长度为0时也是空
  - list集合、map集合元素个数为0时也是空
  - 语法：`${empty 想要运算的值}`：`${empty person}`
- `.`运算
- 中括号运算
- 三元运算
  - `${true?"hello":"no Hell"}`

### EL表达式中的11个内置对象

![image-20211206172946529](/images/Java/JavaEE/05-JSP/image-20211206172946529.png)

- `pageScope`：获取pageContext域属性，相当于pageContext.getAttribute("xxx")
- `requestScope`：获取request域属性，相当于request.getAttribute("xxx")
- `sessionScope`：获取session域属性，相当于session.getAttribute("xxx")
- `applicationScope`：获取application域属性，相当于application.getAttribute("xxx")
- `param`：对应参数，它是一个Map，其中key是参数，value是参数值，适用于单值的参数，相当于request.getParameter("xxx")
- `paramValues`：对应参数，她是一个Map，其中key是参数，value是多个参数值，适用于多值的参数，相当于request.getParameterValues("xxx")
- `header`：对应请求头，它是一个Map，其中key表示头名称，value是单个头值，适用于单值的请求头，相当于request.getHeader("xxx")
- `headerValues`：对应请求头，它是一个Map，其中key表示头名称，value是多个头值，适用于多值的请求头，相当于request.getHeaders("xxx")
- `initParam`：获取web.xml中`<context-param>`内的参数，${ initParam.xxx}，xxx就是`<param-name>`标签内的值，进而得到`<param-value>`中的值
- `cookie`：用于获取cookie，Map<String,Cookie>，其中key是cookie的name，value是cookie对象，例如${cookie.JSESSIONID.value }就是获取sessionId
- `pageContext`：可以获取JSP九大内置对象，相当于使用该对象调用getxxx()方法，例如pageContext.getRequest()可以写为${pageContext.request)

## JSTL标签库

​  全称：JSP Standard Tag Library JSP标准标签库。是一个不断完善的开源标签库

​  EL表达式主要是为了替换JSP中的表达式脚本，而标签库则是替换了代码脚本，这样使得整个JSP页面变得更加简洁

安装参考：[这篇博客](https://blog.csdn.net/amiao_2018/article/details/116357125)和[这篇博客](https://blog.csdn.net/RonaldMH/article/details/116675297)（Tomcat10+）

我按照教程来的，先在pom.xml中添加如下依赖 版本目前来说是固定的2.0.0 如果你到时使用的最新版本tomcat且发现这玩意有更新的版本，就用更新的吧

```xml
<dependency>
    <groupId>org.glassfish.web</groupId>
    <artifactId>jakarta.servlet.jsp.jstl</artifactId>
    <version>2.0.0</version>
</dependency>
<dependency>
    <groupId>jakarta.servlet.jsp.jstl</groupId>
    <artifactId>jakarta.servlet.jsp.jstl-api</artifactId>
    <version>2.0.0</version>
</dependency>
```

**然后在web.xml中webapp标签内的内容和tomcat自带的webapps内的web.xml内容一致**

然后再到你的xx.jsp的头部添加如下内容：

```html
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
```

就可以使用jstl了（整好后先重启下服务，不然一定会一直报错）

### 基本功能

#### 存放数据

语法：`<c:set  scope="存放区域 可选 默认是page" var="键" value="值"/>`

scope参数：

- page：表示pageContext
- request：表示requestContext
- session：SessionContext
- application：ServletContext

例子：

```html
<c:set  scope="page" var="foo" value="bar"/>
//读取数据
<c:out  value="${foo}"/>
```

#### 判断

语法：`<c:if test="{EL表达式}"> 表达式为true显示的内容  </c:if>`

```html
<c:if test="${12==12}">
    <h1>12=12</h1>
</c:if>
```

#### 多重分支判断

if语句并不能做多条件判断（没有elseif）

但是有替代的标签：choose when otherwise 就跟java中的switch case default那样使用即可

语法和使用：（注意，在choose标签内不能含有HTML的注释，只能含有jsp注释）

```html
<%
    request.setAttribute("height", 50);
%>
<c:choose>
<%--    这里相当于case--%>
    <c:when test="${height>100}">
        <h1>height>100</h1>
    </c:when>
    <c:when test="${height<10}">
        <h1>height<10</h1>
    </c:when>
<%--    这里相当于default--%>
    <c:otherwise>
        <h1>100>height>10</h1>
    </c:otherwise>
</c:choose>
```

#### 遍历 forEach

看代码吧：

语法：`<c:forEach 可选参数></c:forEach>`

- begin 设置开始的索引
- end 设置结束的索引
- var 设置循环变量
- items 设置一个要遍历的对象（数组、集合）
- setp 表示遍历的步长值
  - 就像是`for(int i;i<100;i++)`中的i++一样，可以设置setp的值来让i每次加多少
- varStatus
  - 表示当前遍历的对象的状态
  - 可以通过`varStatus="status"` 来讲statuc设置成为当前对象的状态
  - 这个状态可以在for循环中调用`statuc.方法名`
  - status是一个LoopTagStatus对象：
    ![image-20211206223248677](/images/Java/JavaEE/05-JSP/image-20211206223248677.png)

```html
<%--遍历1~10
    begin 设置开始的索引
    end   设置结束的索引
    var   设置循环变量(也是当前正在遍历到的数据)
--%>
<c:forEach begin="1" end="10" var="i">
    ${i}
</c:forEach>

<%--遍历数组--%>
<%
    request.setAttribute("arr", new String[]{"a", "b", "c"});
%>
<hr>
<c:forEach items="${arr}" var="item" varStatus="status">
    当前获取到的数据${item}<br>
<%--    获取是否是第一条--%>
    ${status.isFirst()}<br>
</c:forEach>
<%--遍历map集合

--%>
<%
    HashMap<String, String> map = new HashMap<>();
    map.put("a", "aa");
    map.put("b", "bb");
    map.put("c", "cc");
    request.setAttribute("map", map);
%>
<hr>
<c:forEach items="${map}" var="entry">
    <%--    这里获取到的是Map.Entry Entry中包含key和value属性--%>
    当前获取到的数据${entry.key}:${entry.value}<br>
</c:forEach>
<%--遍历List集合--%>

<%
    ArrayList<Person> list = new ArrayList<Person>();
    list.add(new Person("user1", 18));
    list.add(new Person("user2", 20));
    list.add(new Person("user3", 30));
    request.setAttribute("list", list);
%>
<hr>
<%--这里也可以用begin 和 end 来设置开始和结束位置--%>
<c:forEach begin="1" end="${list.size()}" items="${requestScope.list}" var="person">
    <%--    这里依然是用到了反射来读取数据--%>
    List数据${person.name}=${person.age}<br>
</c:forEach>
```

## 文件的上传和下载

### 文件的上传

1. 有一个form标签，method=post
2. from标签的encType属性必须为`multipart/form-data`
3. 在from标签中使用input，type=file 添加上传的文件
4. 编写服务器代码处理上传的请求

先说一个可能会遇到的小问题：如果你访问自己写的Servlet不到了的话：

在web.xml中

```xml
<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee
                      https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"
         version="5.0"
         metadata-complete="true"  <---这条删掉 然后重新部署
>
```

jsp：

```html
<p>${pageContext.request.contextPath}/upFileService</p>
<form method="post" enctype="multipart/form-data"
      action="${pageContext.request.contextPath}/upFileService">
    用户名：<input type="text" name="username"/><br/>
    选择文件：<input type="file" name="file"/><br/>
    <input type="submit" value="上传"/>
</form>
```

Java

```java
@WebServlet(name = "upFile", urlPatterns = {"/upFileService"})
public class upFile extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//        接收用户上传的文件
        System.out.println("文件上传成功");
    }

}
```

### 实现将用户上传的文件存储

在这之前，先了解下文件上传时浏览器发送了那些数据

![image-20211206230851372](/images/Java/JavaEE/05-JSP/image-20211206230851372.png)

我们先获取下用户发送的流，看下有哪些内容：

```java
//        获取流
ServletInputStream inputStream = req.getInputStream();
byte[] bytes = new byte[1024000];
int len = 0;
while ((len = inputStream.read(bytes)) != -1) {
    System.out.println(new String(bytes, 0, len));
}
```

![image-20211206231744235](/images/Java/JavaEE/05-JSP/image-20211206231744235.png)

看起来没错，那么该如何获取到这个文件呢？

我们就得用到第三方的包了（程序员准则：不要重复造轮子）

你这里可以考虑使用Apache的[commons-fileupload](https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload)，当然我还是选择[HuTool的文件上传](https://apidoc.gitee.com/dromara/hutool/cn/hutool/core/net/multipart/MultipartFormData.html) 不为别的 就因为中文文档

使用：这里省略了将文件信息存储进数据库

```java
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("text/html;charset=utf-8");
        PrintWriter writer = resp.getWriter();
//        判断用户是否是使用form-data(获取Content-Type)
        String contentType = req.getContentType();
        System.out.println(contentType + "********");
        if (contentType == null) {
            writer.write("数据异常");
            writer.close();
            return;
        } else if
//        正则匹配判断是否是form-data
        (!contentType.matches("^multipart/form-data.*")) {

            writer.write("数据异常");
            writer.close();
            return;
        }

        //        接收用户上传的文件
//        获取流
        MultipartFormData data = new MultipartFormData();
        data.parseRequestStream(req.getInputStream(), StandardCharsets.UTF_8);
        //        获取用户传入的存储文件名
        String username = data.getParam("username");
        if (username == null) {
            writer.write("数据不正确");
            writer.close();

            return;
        } else if 
            //这里是判断文件名是否为空
            ((username = username.trim()).equals("")) {
            writer.write("数据不正确");
            return;
        }

        //        获取文件
        Set<String> fileParamNames = data.getFileParamNames();
//        如果文件数量是否等于1（每次只能上传一个文件）
        if (fileParamNames.size() != 1) {
            System.out.println("文件数量大于1或者小于0");
            req.getInputStream().close();
            writer.write("文件数量不正确");
            writer.close();
            return;
        }

        //        获取上传的文件名
        Iterator<String> iterator = fileParamNames.iterator();
        // 只获取第一个文件 如果说要多文件上传的话 这一步可以改成while
        // 并且文件名才用uuid生成
        if (iterator.hasNext()) {
            Object next = iterator.next();
//            保存文件
            UploadFile file = data.getFile(next.toString());
//            获取文件后缀名
            String suffix = file.getFileName().substring(file.getFileName().lastIndexOf("."));
//            存储文件 这里如果是实际工作的话username要拿uuid加密过一遍
            file.write("D:\\" + username + suffix);
            req.getInputStream().close();

//            上传成功 这里省略将文件信息写入数据库
            writer.write("上传成功");
            writer.close();
            System.out.println("文件上传成功");
        }

    }
```

运行结果（若多个文件上传，只会上传第一个）：

![image-20211207121352017](/images/Java/JavaEE/05-JSP/image-20211207121352017.png)

### 文件下载（发送给客户端）

切记：如果是要给客户端的img的src用的话，最好是服务端先转个base64然后发送过去

或者是有一个public目录，该目录下存放相应的文件

大概流程：

![image-20211207121932296](/images/Java/JavaEE/05-JSP/image-20211207121932296.png)

### 发送其他文件并让客户端直接下载

jsp代码，这里也可以改成ajax请求

```html
<%--来个输入框让用户输入文件名 传递给服务器下载文件--%>
<form action="${pageContext.request.contextPath}/downloadFile" method="post">
    <input type="text" name="fileName" value="">
    <input type="submit" value="下载">
</form>
```

Java代码：

下面主要解决了： URL编码乱码 、动态文件等问题

```java
package com;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.tomcat.util.http.fileupload.IOUtils;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.URLEncoder;
import java.text.MessageFormat;

/**
 * @author Amayakite
 * @version 1.0.0
 * @BelongsProject 17-Servlet
 * @BelongsPackage com
 * @date 2021/12/7 12:20
 * @description 项目描述
 */
@WebServlet(name = "downloadFile", urlPatterns = {"/downloadFile"})
public class downloadFile extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//        设置头 防止乱码
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");

//        获取用户传入的文件名
        String fileName = req.getParameter("fileName");
//        设置下载的文件名
//        获取文件
        File file = new File("e:/高光时刻.jpg");
//        二选一即可 下面是动态获取文件发送给客户端 getRealPath 获取文件绝对路径 这里的aaa.txt可以通过filename动态绑定
//        file = new File(getServletContext().getRealPath("/public/aaa.txt"));
//        这里动态的获取文件类型 并设置
        String contentType = req.getServletContext().getMimeType(file.getName());
        resp.setContentType(contentType);
        System.out.println(contentType);
//        如果不是图片、视频类型的文件 则设置下载文件名 设置下载文件的大小 如果是图片、视频类型的文件，则直接返回给客户端的浏览器展示
        if (!contentType.matches("^(image|video).*")) {
            //        设置下载的文件名
//            先对文件名进行URL编码，防止乱码
            String encode = URLEncoder.encode(fileName + file.getName().substring(file.getName().lastIndexOf(".")), "utf-8");
            resp.setHeader("Content-Disposition", MessageFormat.format("attachment;filename={0}{1}", encode));
//        设置下载的文件大小
            resp.setHeader("Content-Length", String.valueOf(file.length()));
        }

//        获取文件的输入流
        BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(file));
        //        将文件写入到客户端 这里使用IOUTils简化自己的操作
        IOUtils.copy(inputStream, resp.getOutputStream());
        resp.getOutputStream().close();
        inputStream.close();
        System.out.println("文件发送完毕");
    }
}
```

## Cookie

### 基本介绍

1. 翻译过来就是饼干
2. COOKIE是服务器通知客户端保存键值对的一种技术 是一个规范（接口），由tomcat下的包实现了它
3. 客户端有了Cookie后，每次请求都发送给服务器
4. 每个Cookie的大小不能超过4kb

这玩意在学前端的时候应该有体系的说过了，我就不过多赘述

当我们想在jsp中获取cookie(AJAX同理)

COOKIE是一个接口，我们的Tomcat包完整了这个借口的封装

先发送一个请求给服务端，接下来服务端处理

```html
<a href="${pageContext.request.contextPath}/getCookie">获取cookie</a>
```

### 新增cookie

注意，一般cookie的value都会经过一系列的加密在给到客户端

Cookie 可以重名（前提是作用路径之类的不一样，否则新的会替换掉旧的）

```java

@WebServlet(name = "getCookie", urlPatterns = "/getCookie")
public class getCookie extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//        创建一个cookie
        Cookie cookie = new Cookie("name", "李四");
//        设置cookie的有效期 不设置的话默认是这次浏览器关闭就失效(默认是-1) 这里的Cookie的时间单位是秒
//        设置了一个有效期为7天的cookie
        cookie.setMaxAge(60 * 60 * 24 * 7);
        //可以通过如下方式设置一个永久有效的cookie
        // 永久有效的定义大概是：5~10年不失效（一般公司撑不了这么久）
        // 下面这样大概设置了80年
        cookie.setMaxAge(Integer.MAX_VALUE);

        
//        注释
        cookie.setComment("这是一个测试cookie");
//        设置cookie的路径
//        这个默认是当前网址的当前项目的路径（这个/getCookie所在的路径下生效） 可以改写为/ ：当前网站下的所有路径均生效
        cookie.setPath("/");
//        设置cookie的域名 这玩意儿是可以设置多个域名的 但是不能设置ip:port的形式
//        cookie.setDomain("www.baidu.com");
//        设置cookie的安全性 设置了这玩意之后，这个cookie只能在https协议下访问 或者localhost（本地）访问
        cookie.setSecure(true);
//        设置cookie是否为HttpOnly(只能用于http请求，JavaScript代码无法读取)
        cookie.setHttpOnly(true);
//        设置cookie的版本
        cookie.setVersion(1);
//        将cookie添加到响应头中
        resp.addCookie(cookie);
        
//        可以添加多个cookie
        Cookie cookie1 = new Cookie("age", "18");
        resp.addCookie(cookie1);
        System.out.println(cookie); 
        System.out.println("---");
        System.out.println(cookie1); 

    }
}

```

### 接收cookie

浏览器发送请求给服务器时，默认会携带在自身`path`下所拥有的所有cookie

jsp:

```html
<%--发送cookie--%>
<a href="${pageContext.request.contextPath}/setCookie">发送cookie</a>
```

接收

```java
@WebServlet(name = "setCookie", urlPatterns = "/setCookie")
public class setCookie extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//       获取客户端发送过来的cookie
        Cookie[] cookies = req.getCookies();
//        这个cookie有非常多的get方法（就是上面那里设置的这里都能get） 一般就在下面开始验证
        for (Cookie cookie : cookies) {
            System.out.println(cookie.getName() + "=" + cookie.getValue());
        }
    }
}

```

### 删除、修改cookie

Cookie没有直接的删除方式，如果需要删除的话，设置`setMaxAge(1)`即可 表示立即失效（1秒后失效）

如果`setMaxAge(0)`表示马上失效，两者都可以使用 看个人习惯 ，如果说测试的话一般设置个1（这样还能在浏览器的控制台瞄上一眼）

比如客户端原先有一个`name`=`张三`的cookie

我们只需要

```java
//先获取到原先用户的COOKIE
@WebServlet(name = "setCookie", urlPatterns = "/deleteCookie")
public class setCookie extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//       获取客户端发送过来的cookie
        Cookie[] cookies = req.getCookies();
        for (Cookie cookie : cookies) {
           if(cookie.getName().equals("name")){
               //设置时长为0表示删除Cookie 在这里还可以判定下cookie的作用路径等再进行删除
               cookie.setMaxAge(1);
               resp.addCookie(cookie);
           }
        }
    }
}

```

如果说要删除一个不在当前项目路径下，比如说Cookie：`token`，当前用户在`/test`发出请求，而Cookie存储的位置在`/`

那么就需要通过新建一个同名COOKIE的方式来覆盖

```java
Cookie cookie = new Cookie("token", "");
cookie.setPath("/");
cookie.setMaxAge(1);
resp.addCookie(cookie);
```

同理，也可以通过这种方式来修改cookie

不设置path的话，默认针对的是当前项目路径下的cookie

注意：修改一个cookie的话，如果cookie没创建，就会创建 如果被创建了 就会被修改

```java
//设置值为自己定的
Cookie cookie = new Cookie("token", "132123123132123");
cookie.setPath("/");
//设置有效期为一天
cookie.setMaxAge(60*60*24);
resp.addCookie(cookie);
```

### 关于Cookie的Path

![image-20211207153825970](/images/Java/JavaEE/05-JSP/image-20211207153825970.png)

## Session

### 基本介绍

1. 也是一个接口（HttpSession）
2. session就是会话，它是用来维护一个客户端和服务器之间关联的一种技术
3. 每个客户端都有自己的一个Session会话
4. Session会话中，我们经常用来保存用户登陆之后的信息

### 创建和获取Session

方法：`reques.getSession()` 返回一个Session对象

- 第一次调用 是创建一个session会话
- 之后每次调用都是 获取前面创建好的session

`session.isNew()`：判断是不是一个刚创建出来的session

每个会话都有一个身份证号，也就是ID值，而且这个ID是唯一的

当然还有些其他的信息：

```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    //        创建一个session对象
    HttpSession session = req.getSession();
    //        判断这个session是否是刚创建出来的
    boolean aNew = session.isNew();
    //        获取这个会话的id
    String id = session.getId();
    //        获取这个会话的创建时间
    long creationTime = session.getCreationTime();
    //        获取这个会话的最后访问时间
    long lastAccessedTime = session.getLastAccessedTime();
    //        获取这个会话的最大生命周期
    int maxInactiveInterval = session.getMaxInactiveInterval();
    //        将如上内容都发送给客户端
    resp.setContentType("text/html;charset=utf-8");
    PrintWriter writer = resp.getWriter();
    writer.write("是否是刚创建的Session：" + aNew + "<br>");
    writer.write("Session的id：" + id + "<br>");
    writer.write("Session的创建时间：" + creationTime + "<br>");
    writer.write("Session的最后访问时间：" + lastAccessedTime + "<br>");
    writer.write("Session的最大生命周期：" + maxInactiveInterval + "<br>");
    writer.close();
}
```

访问结果：

> 是否是刚创建的Session：true
> Session的id：E219AD1DD1276E79ED6EEC440A065BD4
> Session的创建时间：1638863911293
> Session的最后访问时间：1638863911293
> Session的最大生命周期：1800

### 读取和写入session

写入：

```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    //        创建一个session对象
    HttpSession session = req.getSession();
    session.setAttribute("name", "李四");
    session.setAttribute("age", "18");

}
```

读取就是`session.getAttribute("name")`即可，会话有效期内都可以读取到相应的值

### 关于session的时长（超时）控制

如果说设置为负数的话，表示用不超时，全局和局部都是如此

![image-20211207161617663](/images/Java/JavaEE/05-JSP/image-20211207161617663.png)

上面那个是全局的，如果想要设置单个会话的话：

![image-20211207161818205](/images/Java/JavaEE/05-JSP/image-20211207161818205.png)

### 让session立刻超时（销毁）

语法：`session.invalidata()`

也就是让当前这个Session会话马上超时（无效）

### Session的细节说明（重要）

一张图概括，相当于浏览器和服务端之间的Session是通过COOKIE联系的

![image-20211207163532641](/images/Java/JavaEE/05-JSP/image-20211207163532641.png)

### Session的实例-验证码

​  可以将我在上个章节的验证码的密文/明文存储（存储在Header中的）替换为使用Session来保存，这样用户就始终不知道密文，也无法暴力破解了

​  验证码可以通过Google的Kaptcha来生成，或者使用huTool

​  当让这样的话得严格限制下Session的超时时间，例如一分钟，否则抗不太住高频请求

## Filter过滤器

​  JavaWeb的三大组件之一：Servlet程序、Listener监听器、Filter监听器

​  Filter是JavaEE的规范，也就是接口

​  Filter过滤器的作用是：**拦截请求**、过滤响应

常见的应用场景：

1. 权限检查
2. 日记操作
3. 事务管理

就有点像Vue的前后置路由守卫那样

### Filter的初体验

要求：web工程下，有一个admin目录，这个admin目录下的所有资源（HTMl页面。jpg图片。JSp文件等）都必须是用户登录之后才允许访问

![image-20211207180618388](/images/Java/JavaEE/05-JSP/image-20211207180618388.png)

根据我们之前学习的东西来说，用户登陆之后，相关信息都在COOKIE中有，或者在Session域中存在

所以我们可以根据以上两点来判断是否有

所以说可以在admin/index.jsp中加入如下内容

```html
<%
    Object user = session.getAttribute("user");
    if (user == null) {
//        重定向到登录页面
        response.sendRedirect(request.getContextPath() + "/login.jsp");
    }
%>
```

试了下，问题倒是没问题，但是在html或者资源图片中又该怎么实现..这些玩意并不能使用Java代码

所以我们就得用到Filter

### 创建一个简单的filter

前面说过，Filter是一个接口，所以我们要使用它最直接的方式是实现接口

```java
public class MyFilter implements Filter {
    /**
     * 初始化的方法 这玩意我们应该用不着
     * @param filterConfig
     * @throws ServletException
     */
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    /**
     * doFilter方法 专门用于拦截请求，过滤响应 可以做权限检查
     * @param request
     * @param response
     * @param chain
     * @throws IOException
     * @throws ServletException
     */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {

    }

    /**
     * 销毁的方法 这个应该也用不着
     */
    @Override
    public void destroy() {
    }
}
```

可以看到这玩意有三个方法要我们去实现，但是我们只需要实现中间那个就行

### 实现doFilter方法

```java
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpSession session = null;
//        获取session
        session = ((HttpServletRequest) request).getSession();
        Object user = session.getAttribute("user");
//        如果user为null 表示还没有登陆
        if (user == null) {
//           重定向到登陆页面
            ((HttpServletResponse) response).sendRedirect(((HttpServletRequest) request).getContextPath() + "/login.jsp");
            //下面是那啥来着到用户页面 对 转发
//            request.getRequestDispatcher("/login.jsp").forward(request, response);
            return;
        } else {
//            如果user不为null 表示已经登陆了
//            让程序继续往下访问用户的目标资源
            chain.doFilter(request, response);
        }

    }
```

### 配置过滤器

有两种配置方式

#### 通过web.xml配置

```xml
<!--filter标签用于配置一个Filter过滤器-->
<filter>
<!--配置FIlter的别名-->
 <filter-name>AdminFilter</filter-name>
<!--配置Filter的全类名-->
    <filter-class>com.Filter.MyFilter</filter-class>
</filter>

<!--配置Filter过滤器的拦截路径-->
<filter-mapping>
<!--filter-name表示当前的拦截路径给哪个filter使用-->
    <filter-name>AdminFilter</filter-name>
<!--filter-pattren配置拦截路径
		/ 表示请求地址为 http://ip:port/工程路径/ 映射到IEDA的WEB目录
  		/admin/* 表示:http://ip:port/工程路径/admin/* 该目录下的所有路径
-->
    <filter-pattren>/admin/*</filter-pattren>
</filter-mapping>

```

#### 通过注解来配置

一句话搞定：

```java
@WebFilter( filterName = "AdminFilter", urlPatterns = "/admin/*")
//   名称       拦截的路径
```

### Filter的生命周期

Filter的生命周期包含如下方法：

1. 构造器方法
2. init初始化方法
   - 第一个和第二个都会在WEB工程启动的时候运行（Filter已经创建）
   - 执行顺序：构造器-->init
3. doFilter过滤方法
   - doFilter：每次拦截到请求，就会执行
   - 没有拦截到请求，则不会执行
4. destory 销毁方法
   - 停止web工程的时候，会执行destory中的方法
   - 也就是说，停止web工程的时候，也会销毁filter过滤器

### FilterConfig类

​  见名知意，它是Filter过滤器的配置文件类

​  Tomcat每次创建Filter的时候，也会同时创建一个FilterConfig类，这里包含了Filter配置文件的配置信息

FilterConfig类的作用是获取FIlter过滤器配置的内容

1. 获取Filter名称：FIlter-name标签中的内容
2. 获取在filter中配置的init-param标签中的初始化参数
3. 获取ServletContext对象

这里我们通过注解生成哦氯气：

```java
@WebFilter(
        filterName = "AdminFilter",
        urlPatterns = "/admin/*",
        initParams = {
                @WebInitParam(name = "adminName", value = "admin"),
                @WebInitParam(name = "password", value = "123456")
        }
)
```

然后在init中写入如下内容：

```java
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("------------------------------");
        Enumeration<String> initParameterNames = filterConfig.getInitParameterNames();
//        获取在filter中配置的init-param标签中的初始化参数
        while (initParameterNames.hasMoreElements()) {
            String name = initParameterNames.nextElement();
            System.out.println(name + ":" + filterConfig.getInitParameter(name));
        }
//        获取过滤器名称
        System.out.println("过滤器名称:" + filterConfig.getFilterName());
//        获取ServletContext对象
        System.out.println("ServletContext对象:" + filterConfig.getServletContext());
    }
```

最终结果：

```md
------------------------------
adminName:admin
password:123456
过滤器名称:AdminFilter
ServletContext对象:org.apache.catalina.core.ApplicationContextFacade@79f987f6

```

### FilterChain过滤器链

​  我们可以看到doFilter方法内有个`FilterChain chain`参数，并且我们在调用过滤器的时候最后调用了`chain.doFilter(request, response);`方法

​  这玩意目前我看来就跟其他语言中的上下文传递对象挺像的，接下来详细的说明下它

​  Filter 过滤

​  Chain 链条

​  FilterChain 就是过滤器链（多个过滤器如何一起工作）

 比如说我们现在有两个Filter：Filter1 和Filter2

PS：可以用HttpFilter来操作，只需要重写下doFilter方法即可，自带转型

```java
@WebFilter(filterName = "filter1", urlPatterns = "/*")
public class Filter1 extends HttpFilter {
    @Override
    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println("filter1 成功拦截了");
        chain.doFilter(request, response);
        System.out.println("filter1 后置代码");
    }
}

```

FIlter2的：

```java
@Override
protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
    super.doFilter(request, response, chain);
    System.out.println("Filter2 成功拦截了");
    chain.doFilter(request, response);
    System.out.println("Filter2 的后置代码执行了");
}
```

FIlter1的路径是`/*`，Filter2的路径是`/admin/*`

接下来访问下`/admin/index.jsp`

结果：

```md
filter1 成功拦截了
Filter2 成功拦截了
Filter2 的后置代码执行了
filter1 后置代码
```

![image-20211207214110480](/images/Java/JavaEE/05-JSP/image-20211207214110480.png)

使用Thread.currentThread.getName()查看线程

![image-20211207214130720](/images/Java/JavaEE/05-JSP/image-20211207214130720.png)

### Filter的三种拦截匹配模式

- 精确匹配
  - 例如：`/target.jsp`
  - 以上配置的路径表示请求地址必须为：`http://ip:port/工程路径/target.jsp`
- 目录匹配
  - 例如：`/public/*`
  - 以上配置的路径表示请求地址必须为：`http://ip:port/工程路径/public/任意文件`
- 后缀名匹配
  - 例如`*.html`
  - 表示请求地址必须以`.html`结尾
  - 例如：`/target.html`或者`/public/aaa.html`

**FIlter过滤器只关心请求的地址是否匹配，不关心请求的资源是否存在**

## 配置自定义的错误页面

在我们 学习过程中 可能会有大量的错误页面出现在网页上，但是那些目前来说都不重要

但在工作中，往往都得自己配一个错误页面

配置的方式很简单，在web.xml中添加如下标签即可

```xml
<!--error-page标签配置-服务器出错后，自动跳转的页面-->
<error-page>
    <!--error-code是错误类型-->
 <error-code>500</error-code>
    <!--localtion标签标识，要跳转去的页面路径（可以是文件 也可以是一个Servlet）-->
    <localtion>/404.html</localtion> 
    <!--上面这样配置的是项目根目录下的404.html为发生code 500 错误时自动跳转的页面-->
</error-page>
```

例如我现在设置一个ErrorPage页面，内容就一个h1标签里面写着Errorpage

![image-20211207215653754](/images/Java/JavaEE/05-JSP/image-20211207215653754.png)

然后设置下web.xml

```xml
<error-page>
    <error-code>500</error-code>
    <location>/ErrorPage.jsp</location>
</error-page>
```

然后在login.jsp中加入一个错误的代码：

```html
<%
    System.out.println(12 % 0);
%>
```

试图进入login.jsp：发现是转发了内容，而不是重定向，说明我们可以直接编写一个Error的Servlet，然后获取错误内容并存储到数据库之类的

![image-20211207215731561](/images/Java/JavaEE/05-JSP/image-20211207215731561.png)

## I18N国际化

​  这里只是做个引子，实际上在通常情况下，国际化的任务是交给前端来完成的（ReactI18N、VueI18N）

​  国际化指的是同一个网站可以支持多种不同的语言，以便不同的国家、地点、用户访问

​  关于国际化我们相当的最简单的方案是为不同的国家创建不同的网站

​  例如苹果，在美国是：<https://www.apple.com，而中国是https://www.apple.com/cn>

​  但是这种方案并不适合全部公司---造价较高

​  我们通常希望一个相同的网站，在相同的人访问的时候，可以展现出不同的语言，实际上这种需求并不强烈，一般真的有国际化需求的公司，主流用的依然是苹果公司的那种方案，为不同国家的人创建不同的页面，所以国际化的内容并不是终点

​  国际化的全称是：internationalization 由于字母过长，老外就想了个简单的叫法：I18N，这个单词总共有20个字母，掐头去尾18个，头是I，尾是N

​  以后有人跟你说I18N那就是在跟你说国际化

### 国际化的相关要素

![image-20211207221430453](/images/Java/JavaEE/05-JSP/image-20211207221430453.png)

示例：

我们最简单的获取当前时区名的方式是使用`java.util.Locale`

```java
@Test
public void testLocale(){
    //获取系统默认语言的国家信息
    Locale locale = Locale.getDefault();
    System.out.println(locale);//zh_CN
    System.out.println("=============================");

    //       获取所有的locale
    for (Locale locale : Locale.getAvailableLocales()) {
        System.out.println(locale);
    }
    System.out.println("=============================");
    // 下面是常见的Locale 最常见的是最上面的三个
    System.out.println(Locale.CHINA);
    System.out.println(Locale.US);
    System.out.println(Locale.JAPAN);
    System.out.println(Locale.FRANCE);
    System.out.println(Locale.GERMANY);
    System.out.println(Locale.ITALY);
    System.out.println(Locale.KOREA);
}
```

好了，基本的了解完了，接下来实现国际化

我们先新建两个properties，分别为i18n_zh_CN.properties和老美的，内容分别如下

```properties
//中国的
username=用户名
password=密码
login=登录
logout=退出

//美国的
username=UserName
password=Password
login=Login
logout=Logout
```

一定要放在res文件夹中，对应打包后的classes根目录，否则是无法读取到的：当你的文件名和路径都准确无误时，IEDA会给你自动加上一个资源包的tag（实际上就是在res的根目录）

![image-20211207223958124](/images/Java/JavaEE/05-JSP/image-20211207223958124.png)

然后编写一个测试类测试：

```java
@Test
public void test2(){
    Locale locale = Locale.US;
    ResourceBundle i18n = ResourceBundle.getBundle("i18n", locale);
    System.out.println(i18n.getString("username"));
}
```

当你测试美国的时候，发现没有问题，但是测试中国的时候，出了问题：文字乱码了

解决方案：[这篇文章](https://www.cnblogs.com/feshfans/p/9885985.html)来不动IEDA设置的更该

或者像我一样，设置下properties的文件编码，然后删除原先创建的文件，再新建一个相同的文件，就是UTF-8编码了

![image-20211207224718369](/images/Java/JavaEE/05-JSP/image-20211207224718369.png)

### 在网页中使用I18N

这里用JSP代码为例：

```html
<%@ page import="java.util.Locale" %>
<%@ page import="java.util.ResourceBundle" %>
<html>
<body>
</body>
<%
    //从请求头中获取locale信息
    Locale locale = request.getLocale();
    System.out.println(locale);
    //获取国际化资源文件
    ResourceBundle i18n =  ResourceBundle.getBundle("i18n", locale);

%>
<h1><%=i18n.getString("username")%></h1>
<h1><%=i18n.getString("password")%></h1>
<h1><%=i18n.getString("login")%></h1>
<h1><%=i18n.getString("logout")%></h1>
</html>

```

最终结果

![image-20211207225744152](/images/Java/JavaEE/05-JSP/image-20211207225744152.png)

### 如何让用户自己选择语言

其实非常简单，直接上代码：

```java
<%@ page import="java.util.Locale" %>
<%@ page import="java.util.ResourceBundle" %>
<%@page contentType="text/html" pageEncoding="UTF-8" isELIgnored="false" %>
<html>
<body>
</body>
<%
    //从请求头中获取locale信息
    Locale locale = request.getLocale();
    System.out.println(locale);
//    获取用户传入的language参数
    String language = request.getParameter("language");
    if (language != null && language.length() > 0) {
        switch (language) {
            case "zh":
                locale = Locale.CHINA;
                break;
            case "us":
                locale = Locale.US;
                break;
            default: //默认中文 识别不了的都转成中文
                locale = Locale.CHINA;
                break;
        }
    }
    //获取国际化资源文件
    ResourceBundle i18n = ResourceBundle.getBundle("i18n", locale);

%>
<%--两个A标签分别切换中英文--%>
<a href="${pageContext.request.contextPath}/index.jsp?language=zh">点我切换成中文</a> |
<a href="${pageContext.request.contextPath}/index.jsp?language=us">English</a>
<h1><%=i18n.getString("username")%>
</h1>
<h1><%=i18n.getString("password")%>
</h1>
<h1><%=i18n.getString("login")%>
</h1>
<h1><%=i18n.getString("logout")%>
</h1>
</html>

```

打开网页，可以自由切换了

![image-20211207231512239](/images/Java/JavaEE/05-JSP/image-20211207231512239.png)

### 使用JSTL标签实现国际化

只能说，我这一步没成功，懒得折腾了，反正以后用不着Tomcat的这玩意

Tomcat10 太阴间 找不到问题 要看就去看这个系列的最后1P吧，安装教程也没有 （MD 找不到那个包 气死我了）

<iframe src="//player.bilibili.com/player.html?aid=91909529&bvid=BV1Y7411K7zz&cid=157064727&page=325" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

JavaWEB就先学到这，如果你有兴趣的话就跟着尚硅谷敲一遍前端代码。接下来我的学习路线是先学习JUC（JavaSE中的），然后继续学习SPring全家桶
