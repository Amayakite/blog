---
title: 12-常用类
date: 2021-11-03 20:43:44
category: JavaSE
tag:
 - Java
 - JavaSE
 - Object
---

## 包装类

包装类(Wrapper)可以理解为，给八种基本的数据类型定义相应的引用类型

**让基本的数据类型有了类的特点，就可以调用类中的方法**

| 基本数据类型 |   包装类    |
| :----------: | :---------: |
|   boolean    |   Boolean   |
|     char     |  Character  |
|     byte     |  **Byte**   |
|    short     |  **Short**  |
|     int      | **Integer** |
|     long     |  **Long**   |
|    float     |  **Float**  |
|    double    | **Double**  |

上方，粗体写的类的父类是**Number**

### 包装类关系图

![image-20211103210315078](/images/Java/JavaSE/12-常用类/image-20211103210315078.png)

上方类中**Boolean和Character直接继承于Comparable，实现了Serializable，Comparable**

**Long、Double、Short、Byte、Integer、Float继承于Number(Number实现了Serializable)，并实现了Comparable**

> Q：看起来这些类很麻烦的样子，为啥要用类来包装这些玩意，普普通通的不好吗？
>
> A：因为这些类封装的方法实在是太多了，比直接用起来舒服一大截，为啥不用...

### 包装类和基本数据类型的转换

使用特点：

1. 在Jdk5以前，是需要手动装箱和手动拆箱，**装箱**：基本类型-->包装类型，反之，**拆箱**
2. 在Jdk5以后（含Jdk5）是附带了自动装箱和自动拆箱
3. 自动装箱底层调用的是ValueOf方法，比如Integer.ValueOf()
4. 所有包装类的装箱和拆箱方法都一样，看下面演示

> 演示Integer的装箱和拆箱，其他的几个包装类装箱拆箱方法跟这个一模一样，不一一举例了

```java
package com.wrapper;

public class Integer01 {
    public static void main(String[] args) {
//        演示int<--->Integer的装箱和拆箱
//        Jdk5以前是手动装箱和拆箱:
        int n1 =100;
//        如果想把这个普通的数据类型转换成包装类，就需要进行装箱:
//        JDK5以前的手动装箱： int-->Integer
        Integer integer = new Integer(n1);
        Integer integer1 = Integer.valueOf(n1);
//        上面这样就是手动装箱..

//        JDK5以前的手动拆箱 Integer-->int
        int in2 = integer.intValue();
//        上面这个就是手动拆箱

//        在JDK5后，就可以自动装箱和拆箱了
        int n2 =200;
//         自动装箱 int-->Integer2
        Integer integer2 =n2;
//        按照正常的道理来说，这样写是不对的，把一个基本数据类型直接赋予给一个类，这放在其他类里是会报错的。。。。
//        这里的底层实际上还是Integer.valueOf(2),Debug一下看看：
        /*
        可以看到，在Debug时，运行到这一行，系统自动跳转到Integer的valueOf了
            public static Integer valueOf(int i) {
                if (i >= IntegerCache.low && i <= IntegerCache.high)
                    return IntegerCache.cache[i + (-IntegerCache.low)];
                return new Integer(i);
            }
        * */

//        自动拆箱 Integer ==>int
        int n3 =integer2;
//        这里按理说也讲不过去，直接将一个包装类赋给基本数据类型...看看源码吧
        /*
        可以看到，Debug后，依旧是调的intValue()..
        public int intValue() {
            return value;
        }
        也就是说，自动拆箱和装箱，在JDK5以后，java开发者整了一套底层原理，自动调用拆箱和装箱
        所以就可以这样自用的赋值。。
        */
    }
}

```

#### 扩展-经典的面试题

```java
Object obj1 =true?new Integer(1):new Double(2.0);
System.out.println(obj1);//会输出什么？
```

可能会下意识的就觉得是1，但并非如此，它实际输出的是1.0

为啥呢？因为`true?new Integer(1):new Double(2.0)`这个地方是一个整体，他这之中精度最高的是double，所以结果会提升优先级，最终结果就是1

> 再来看另外一道题

```java
Object obj2;
if(true){
    obj2=new Integer(1);
}else{
    obj2=new Double(2.0);
}
System.out.println(obj2);// 这里应该输出什么？
```

这里就很一目了然了，结果是1，因为他们根本不是同一个整体`obj2=new Integer(1);`跟`obj2=new Double(2.0);`完全是两码事

### 包装类型和String类型的互相装换

> 在实际工作中，包装类型往往跟String之间相互转换的工作比较多，所以来看看他们是怎么相互转换的
>
> 这里演示Integer和String的相互转换，其他包装类同理

```java
package com.wrapper;

public class WrapperVString {
    public static void main(String[] args) {
//        包装类(Integer)-->String
        Integer i =100;//自动装箱
//        方式1
        String str1 =i+""; //精度原理，懂得都懂
//        方式2
        String str2 =i.toString(); //用包装类自带的ToString方法
//        方式3
        String str3 = String.valueOf(i);

//        String-->Integer
        String str4="123456";
//        方式1 Integer.parseInt
        Integer i1 = Integer.parseInt(str4); //这里返回的是int类型，然后再用自动装箱
//        方式2 new Integer(String str)
        Integer i2 = new Integer(str4); //Integer这类的包装类中构造方法比较多，其中就可以直接接收字符串
//        要注意的是，无论是通过哪种方式将字符串转换成integer，若字符串不是合发数字的话，会抛出NumberFormatException的异常
//        其他包装类也同理

    }
}
```

### Integer和Character类的常用方法

这些包装类的方法，构造函数，属性之类的可以直接在IEDA的树状图中查看

![image-20211103221003388](/images/Java/JavaSE/12-常用类/image-20211103221003388.png)

可以看到，光拿Integer就有一大堆方法和属性及常量，接下来了解下Integer和Character中那些常用的方法，当然实际开发过程中要用到哪个方法就去JDK手册中查哪个方法即可

```java
package com.wrapper;

public class WrapperMethods {
    public static void main(String[] args) {
        System.out.println(Integer.MAX_VALUE); //返回最大值
        System.out.println(Integer.MIN_VALUE);//返回最小值

        System.out.println(Character.isDigit('a'));//判断是不是数字
        System.out.println(Character.isLetter('a'));//判断是不是字母
        System.out.println(Character.isUpperCase('a'));//判断是不是大写
        System.out.println(Character.isLowerCase('a'));//判断是不是小写

        System.out.println(Character.isWhitespace('a'));//判断是不是空格
        System.out.println(Character.toUpperCase('a'));//转换成大写
        System.out.println(Character.toLowerCase('A'));//转换成小写
    }
}

```

#### 扩展-Integer面试题

> 看看下面代码，输出的结果是啥，为什么？

```java
public void method1(){
    Integer i = new Integer(1);
    Integer j = new Integer(1);
    System.out.println(i==j);
    
    Integer m =1;
    Integer n =1;
    System.out.println(m==n);
    
    Integer x =128;
    Integer y =128;
    System.out.println(x == y);
    
}
```

1. 首先要确定的一点是，无论是什么情况下，对象和对象的比较始终都是比较地址。

2. 两个对象判定是否相等（都是new出来的），所以判断的是他们两是不是同一个对象，即地址是否相等，所以为false

3. 这两个不是new出来的，底层用的是`Integer.valueOf()`，先看看底层源码：

   - ```java
     public static Integer valueOf(int i) {
         if (i >= IntegerCache.low && i <= IntegerCache.high)
             return IntegerCache.cache[i + (-IntegerCache.low)];
         return new Integer(i);
     }
     ```

   - 可以看到，这个源码里有个判断，大意是判断i是否大于等于某个值，小于等于某个值，如果是的话就是直接返回一个现有的Integer，否则的话就是New一个出来，那接下来看一看这两个值分别是什么

   - ```java
     static final int low = -128;
     ```

   - ```java
     static final int high;  
     //可以看到这里并没有赋值，根据常识可以得知
     //final定义的属性是必须要赋值的，既然没有直接high=xxx;
     //那就一定就要在静态代码块中进行赋值
     ```

   - 那么接下来看看他的静态代码块中是否有相应的定义

   - ```java
     static {
         // high value may be configured by property
         int h = 127;
         String integerCacheHighPropValue =
             sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
         if (integerCacheHighPropValue != null) {
             try {
                 int i = parseInt(integerCacheHighPropValue);
                 i = Math.max(i, 127);
                 // Maximum array size is Integer.MAX_VALUE
                 h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
             } catch( NumberFormatException nfe) {
                 // If the property cannot be parsed into an int, ignore it.
             }
         }
         high = h; //可以看到，这里将high的值设定为了h，h的值为127，所以high=127
     
         cache = new Integer[(high - low) + 1];
         int j = low;
         for(int k = 0; k < cache.length; k++)
             cache[k] = new Integer(j++);
     
         // range [-128, 127] must be interned (JLS7 5.1.7)
         assert IntegerCache.high >= 127;
     }
     ```

   - 由上得出，当i的值为：-128<=i<=127时，返回的是一个现有的对象(在cache数组中的对象，看这个静态代码块可以知道，类加载的时候这个数组就已经创建好了)，并没有真的new了一个对象，所以他们两个的比较结果为true

4. 可以看出，这里底层用的依旧是`Integer.valueOf()`，根据上一点得出的结论进行分析：

   - ```
     public static Integer valueOf(int i) {
         if (i >= IntegerCache.low && i <= IntegerCache.high)
             return IntegerCache.cache[i + (-IntegerCache.low)];
         return new Integer(i);
     }
     ```

   - 当i的值为：-128<=i<=127时，返回的是一个现有的对象，否则new一个新的对象出来，这里的两个值都是>128

   - 所以这两个都是new出来的对象，比较地址返回false

运行结果：

```shell
false
true
false
```

## String(重要)

> 截止至这里，我么貌似都用习惯了String，设置可能开始的时候，也将他认为是一个基本数据类型，但实际上他不是...

### String的基本介绍

1. String对象用于保存字符串，也就是一组字符(char)序列

   String的关系图：![image-20211103230909848](/images/Java/JavaSE/12-常用类/image-20211103230909848.png)

2. **字符串常量**对象是用双引号括起来的字符序列，如：`"Hello world","你好","How are you" "15.236"`等

   - ```java
     main(){
         String name ="Hello"; //创建字符串常量
         name="Tom"; //修改字符串常量
     }
     ```

   -

3. 字符串的字符使用`Unicode`字符编码，一个字符（不区分字母还是汉字）占两个字节

4. String类常用的构造器(它有相当多的构造器，实现了构造器的多重重载):

   - ```java
     String s1 =new String(); //创建一个空的String
     String s2 =new String(String original);//带上一些字符串常量
     String ss =new String(byte[] byte);// 接收一个byte数组
     String s3 =new String(char[] char);//通过char数组
     String s4 =new String(char[] char,int startindex,int count);
     //指定一个char数组的从哪里开始的多少个字符来创建一个String
     //记住这最后一个，IO之类的时长用到它
     ```

   - ![image](/images/Java/JavaSE/12-常用类/image-20211103231305877.png)

5. String类是一个`final`类，他不能被继承

6. String中属性`private final char value[]`，用于存放字符串内容

   - ![image-20211103232113634](/images/Java/JavaSE/12-常用类/image-20211103232113634.png)
   - 这个value的说明是：用于存储字符串，并且他的类型是char[]数组
   - 说明**字符串在底层本质上还是char[]数组**

7. 一定要注意，这个**value是一个final类型**，不可修改：即**地址不可修改**

   - 比如：原先的value指向了一块数据-->"TOM"

   - **在指向完"TOM"之后，value就不能指向另外的空间了比如我想把Value的指向改成"Jack"，这是不被允许的**

   - 但是，我把value值中的"TOM"换成“TOH”或者"TAK"是被允许的

   - **也就是说，value的不可修改指的是它里面的单个字符依然可以正常修改(单个字符的内容是可以变化的)，但是Value不能指向一个新的对象(新的地址)**

   - 举个例子：

     - ```java
       package com.String_;
       
       public class String01 {
           public static void main(String[] args) {
               final char[] value ={'H','e','l','l','o'};
               value[0]='f';
               System.out.println(value);
       
           }
       }
       //结果：fello 没报错，能正常修改，就跟Javascript中定义的const list有点类似，本身的指向不能被重定向，但是里面的内容可以自由修改
       ```

     - ```java
       package com.String_;
       
       public class String01 {
           public static void main(String[] args) {
               final char[] value ={'H','e','l','l','o'};
               value[0]='f';
               char[] value2 ={'v','o','t'};
               //value=value2; 不可以修改value的地址
               System.out.println(value);
       
           }
       }
       //如果是这样的话，编译器就直接报错了，final约束是让其地址无法指向一个新的数据空间，但是单独的内容的改变它是允许的
       ```

### 创建String对象的两种方式

- 方式1：直接赋值`String str ="How are YOU"`
- 方式2：调用构造器`String str = new String("I'm fina thank you,and you?")`

> 这两种方式创建String对象它是不一样的(机制)...接下来说说它的区别

1. 方式1：先从常量池查看是否有`How are YOU`数据空间，如果有，直接指向；如果没有则重新创建，然后指向，str最终指向的是常量池的空间地址
2. 方式2：现在堆中创建空间，里面维护了value属性，指向了常量池的`I'm fina thank you,and you?`空间。如果常量池没有`I'm fina thank you,and you?`,重新创建，如果有，直接value指向，最终指向的是堆中的空间地址
3. 内存布局图：
   ![image-20211103235127338](/images/Java/JavaSE/12-常用类/image-20211103235127338.png)

> 卧槽瞬间就明朗了，原来是这么一回事...接下来做一道简单的题目:

```java
String a ="abc";
String b ="abc";
System.out.println(a.equals(b));// true
System.out.prinln(a == b);//true
```

1. 字符串重写了equals，所以这里的比较实际上是比较两个String对象的value值的所有内容是否相等，如果相等就返回true，否则就返回false
2. 这里根据上面的内存布局图可以得出，a是直接创建的，b是直接创建的，所以他们连是直接指向同一个常量池中的地址，所以结果为true
3. String a 和b的创建流程：
   1. String A 创建时，程序在常量池里面看有没有"abc"。发现没有，于是就创建一个，然后让A的地址指向它
   2. String B 创建时，程序在常量池里面看有没有"abc"，发现有，于是直接让B指向它
   3. 加入常量池中的"abc"地址是0x6151564;那么A和B指向的地址都是0x6151564，即：他们完全相同

> 再来做一道题目

```java
String a = "hsp";
String b = new String("hsp");
System.out.println(a.equals(b));
System.out.println(a == b);
System.out.println(a == b.intern());
System.out.println(b == b.intern());
```

1. true
2. false
3. 这里分别看下JavaDoc的文档和源码
   1. 查看源码，发现：
      ![image-20211104000459973](/images/Java/JavaSE/12-常用类/image-20211104000459973.png)
   2. 这玩意没有代码，说明是系统底层（JVM）提供的。。然后看看文档，大意是，返回String的常量池中的地址（假设是0x111）
   3. 完整文档：当调用intern方法时：如果池(常量池)已经包含一个等于此String对象的字符串(用equals(Object))来匹配，则返回池中的字符串(地址)，否则，将这个String添加到常量池中，并返回这个String对象的引用
   4. 解读：intern()方法最终返回的是常量池的地址
   5. 然后a的地址也是指向常量池中的(0x111)
   6. 所以可以得出，结果为true
4. 根据3的结果，可以得知，这里比较的是b在堆中的地址和b的value的常量池地址
   1. 所以可以得出，他们两一定是不相等的，所以返回false

![image-20211104001912357](/images/Java/JavaSE/12-常用类/image-20211104001912357.png)

### 字符串的特性

1. String是一个final类，代表不可变的字符序列
2. 字符串是不可变的，一个字符串一旦被匹配，其内容是不可变的

> 小练 以下语句创建了几个对象？画出内存布局图

```java
String s1 ="hello";
s1 ="haha";
```

两个对象，在s1创建时，往常量池里面添加了hello，在s1重定向时，又往常量池添加了haha

![image-20211104002637352](/images/Java/JavaSE/12-常用类/image-20211104002637352.png)

#### 扩展-面试题

```java
String a ="hello"+"abc";
//创建了几个对象？
```

一个，底层会自动优化，这里的"hello"+"abc"等价于"helloabc"，底层在运行到这里的时候会自动得到"helloabc"，并将其传入常量池生成(编译器不是傻子)

![image-20211104002924021](/images/Java/JavaSE/12-常用类/image-20211104002924021.png)

```java
String a ="hello";
String b="abc";
String c =a+b; //创建了几个对象？
```

1. 创建了a对象

2. 创建了b对象

3. 这个时候就要用到强大的断点工具了：

   1. ```
      package com.String_;
      
      public class String01 {
          public static void main(String[] args) {
              String a ="hello";
              String b="abc";
      //        1 先创建一个StringBuild sb = new StringBuild();
      //        2 执行 sb.append("hello");
      //        3 sb.append("abc");
      //        4 String c = sb.toString();// tpString:new String("xxx");
      //        最后其实是c指向堆中的对象(String)value[]-->池中"Helloabc"
              String c =a+b; //在这里DEBUG
      
          }
      }
      
      ```

   2. 可以在Debug中看到，执行到这一步的时候，是先创建了一个StringBuild，然后再将常量池中的hello 和 abc添加到StringBuild的末尾

   3. 然后再调用String Build的Tostring方法，new了一个String()，并返回给C

   4. 同时，根据对new String()的理解，可以得出，newString()时，是在堆中创建一个对象，然后查看池中是否有value值对应的东西，这里发现没有，于是在池中创建"helloabc",并赋值给value

   5. 所以说，这一步中创建了两个对象

   6. 加上new StringBuild 总共创建了三个对象

4. 因此，总共创建了5个对象，当然，实际上最终的结果是：

   1. A指向了常量
   2. B指向了常量
   3. C指向了堆
   4. 因此，也可以理解为创建了三个对象，但是得了解到这一步到底做了哪些事情

5. 如果说这个时候在判断c=="helloabc"

   1. 因为c指向的堆中的对象
   2. 而"helloabc"在常量池
   3. 所以false

![image-20211104004803611](/images/Java/JavaSE/12-常用类/image-20211104004803611.png)

总结：**两个常量相加，结果在池，两个变量相加，结果在堆**

常量相加，直接看池的地址，变量相加，就需要看堆，再通过value映射的地址到池

所以说，学这玩意，一定要尽量看着源码学（再提一嘴，韩顺平老师真的厉害）

> 下一题

请根据代码说出打印的结果：

```java
public class String01 {
    String str = new String("hsp");
    final char[] ch = {'j', 'a', 'v', 'a'};

    public void change(String str, char[] ch) {
        str = new String("HSP");
        ch[0] = 'h';
    }

    public static void main(String[] args) {
        String01 ex = new String01();
        ex.change(ex.str,ex.ch);
        System.out.println(ex.str);
        System.out.println(ex.ch);
    }
}

```

可能看到这道题下意识的就认为结果是：java + hava

接下来逐步分析下这个代码

1. new了一个String01对象 创建了一个新的栈，指向了堆中的String实例对象
   1. 这个对象里面有个str，str是String类型的，他会指向堆中的一个String空间
      1. 这个String空间中有一个非常重要的属性value，value指向常量池中的"hsp"
   2. 还有个char[]数组，数组指向堆中的 [**j|a|v|a**]大概是这样一个数组，并且这个char是final的，不能修改其指向
2. 调用了ex.change方法， 这个方法调用的时候，创建了一个新的栈（Change栈）
   1. 传入了两个值，str和ch，
   2. 所以相当于是new了两个值，new String ,new char[] ，并把它们指向传进来的两个值
   3. 到这一步就很明确的，给str修改内容就相当于让其指向一个新的常量地址，这样做并不会影响到其他东西，只会将自己的（这个方法中的）string指向的地址更该
   4. 然后是char，char和String一样，指向的都是开始new String01()中的地址，但是这里并没有更该他的指向，而是更该其指定的一个值，这样做并不会更该ch所指向的地址
3. 所以结果就很显而易见了，结果是hsp hava

> 个人解读change

0. 这里调用的change(string,ch)实际上：str为new了一个String，地址指向了ex.str的地址，然后ch是new了一个char[] 地址指向了ex.ch

1. 为了方便区分，这里把change的两个参数分别命名为c1和c2

2. 然后程序更该了c1的指向：c1="java"，实际上是更改了c1指向的地址(在池中开辟了新的常量"java",并把c1的地址指向"java")

3. 所以到一这一步的时候，c1实际上指向的就不是ex.str的地址了，而是一个新的地址

4. 接着，程序更该了c2数组的内容,将原本的['j', 'a', 'v', 'a']，替换成了['h', 'a', 'v', 'a']

5. 根据前面的知识，可以知道，数组在更该其内容时，并不会更该他本身的地址，所以这里的c2实际上还是指向了ex.ch

6. 综上所述，得出结论：输出的语句为:hsp and hava

![image-20211104144229377](/images/Java/JavaSE/12-常用类/image-20211104144229377.png)

### String类常用方法

String类是保存字符串常量的，每次更新都需要重新开辟空间，效率低，因此Java设计者还提供了`StringBuffer`和`StringBuilder`来增强String的功能并提高效率，在此之前，先来看看下面的的代码

```java
String s =new String("");
for(int i=0;i<80000;i++){
    s+="hello"
}
```

可以看到，这里循环了80000次，每次都是在创建新的“常量”空间，第一次hello,第二次hellhello....以此类推，总共创建了80001个常量空间(包括创建s的时候)，但是我们只需要用到最后一个空间，所以前80000的就相当于白费了，且创建空间是需要时间的，效率相当的低，这个的解决方法到后面`StringBuffer`和`StringBuilder`就知道了，在此之前，必须得知道的是，虽然String在类似于这种场合效率低下，但是他本身也附带了很多很有用的方法，接下来来了解下

- `equals(String str)` 比较两个String是否相等，比较的是value数组的值(区分大小写的判断)

- `equalsIgnoreCase(String str)`比较两个String是否相等(不区分大小写进行判断)

- `length()`获取字符的个数，字符串的长度

- `indexOf(String str)` 获取**字符(char)或字符串**在字符串中第一次出现的索引，索引从0开始，如果找不到就返回-1

  ```java
  String s1 ="amayakite@qq.com";
  System.out.println(s1.indexOf('a'));//0
  System.out.println(s1.indexOf('b'));//-1
  //也可以放字符串
  System.out.prinln(s1.indexOf("kite"))//5
  ```

- `lastIndexOf(参数同上)`获取**字符(char)或字符串**在字符串最后一次出现的索引，索引从0开始，如果找不到就返回-1

  ```java
  String s1 ="amayakite@qq.com";
  System.out.println(s1.indexOf('a'));//2
  ```

- `substring()`截取指定范围的字符串

  ```java
  String name ="Hello,张三";
  System.out.println(name.substring(6));//从索引6开始(索引从0开始计算)截取后面所有的内容：张三
  System.out.println(name.substring(0,5))//从索引0到索引(5-1=4)中的所有内容:Hello
  ```

- `trim()`去掉前后空格

- `charAt()`获取某索引处的字符，注意，String不能通过str[index]的方式获取指定索引处的字符

- `toUpperCase(String str)`将字符串转换为全**大**写

- `toLowerCase(String str)`将字符串转换为全**小**写

- `concat()`拼接字符串

  ```java
  String s1 ="林黛玉";
  s1 = s1.concat("宝玉").concat("fahter").concat("skr~~~");
  //s1=林黛玉宝玉fahterskr~~~
  ```

- `replace()`替换字符串中的字符

  ```java
  s1="Hello 世界你好 你好 你好";
  s2 = s1.replace("你好","你不好");//replace执行后返回的结果才是替换过的，对原对象(s1)没有影响
  //s2=Hello 世界你不好 你不好 你不好
  ```

- `split()`分割字符串

  ```java
  s1 ="锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦";
  String[] strArray = s1.split(",");//将字符串根据指定的字符进行分割，指定的字符将不会被保留，返回一个数组。split可以传入正则表达式
  //strArray:["锄禾日当午","汗滴禾下土","谁知盘中餐","粒粒皆辛苦"]
  s1="E:\\aaa\bbb\\ccc.txt";
  strArray=s1.split("\\\\");//如果要对这种本身含有转义符的东西，如：\\分割就要用到\\\\(转义再转义)
  ```

- `toCharArray()`将字符串转换成char数组

- `compareTo()`比较两个字符串的大小

  - 如果两个字符串的长度相同，且每个字符也相同，返回0

  - 如果长度相同或者不相同，但是在比较时，可以区分大小写，就返回

    ```java
    if(c1 !=c2){
        return c1-c2;
    }
    ```

  - 如果前面的部分都相同，就返回str1.len-str2.len

- `format()`格式化字符串

  ```java
  String name = "John";
  int age =10;
  double score = 98.3/3;
  char gender = '男';
  s1 =String.format("我的姓名是%s，年龄是%d,成绩是%.2f性别是%c,希望大家喜欢我",name,age,score,gender);
  //s1:我的姓名是John,年龄是10,成绩是32.77，性别是男，希望大家喜欢我
  ```

### String Format(模板字符串)补充

format方法使用占位符进行格式化

常规类型、字符类型和数值类型的占位符格式：

`%[index$][标识][最小宽度][.精度]转换符`

日期和时间类型的占位符格式：

`%[index$][标识][最小宽度]转换符`

与参数不对应的占位符格式：

`%[标识][最小宽度]转换符`

其中index表示参数列表中的位置上的值

| 转 换 符    | 说  明                                      | 示  例       |
| ----------- | ------------------------------------------- | ------------ |
| %s          | 字符串类型                                  | "mingrisoft" |
| %c          | 字符类型                                    | 'm'          |
| %b          | 布尔类型                                    | true         |
| %d          | 整数类型（十进制）                          | 99           |
| %x          | 整数类型（十六进制）                        | FF           |
| %o          | 整数类型（八进制）                          | 77           |
| %f          | 浮点类型                                    | 99.99        |
| %.[number]f | 显示小数点后number位，会自动四舍五入        | 100.00       |
| %a          | 十六进制浮点类型                            | FF.35AE      |
| %e          | 指数类型                                    | 9.38e+5      |
| %g          | 通用浮点类型（f和e类型中较短的）            |              |
| %h          | 散列码                                      |              |
| %%          | 百分比类型（自己给自己转义）                | ％           |
| %n          | 换行符                                      |              |
| %tx         | 日期与时间类型（x代表不同的日期与时间转换符 |              |

```java
public static void main(String[] args) { 
  String str=null; 
  str=Stringformat("Hi,%s", "王力"); 
  Systemoutprintln(str); 
  str=Stringformat("Hi,%s:%s%s", "王南","王力","王张");      
  Systemoutprintln(str);              
  Systemoutprintf("字母a的大写是：%c %n", 'A'); 
  Systemoutprintf("3>7的结果是：%b %n", 3>7); 
  Systemoutprintf("100的一半是：%d %n", 100/2); 
  Systemoutprintf("100的16进制数是：%x %n", 100); 
  Systemoutprintf("100的8进制数是：%o %n", 100); 
  Systemoutprintf("50元的书打5折扣是：%f 元%n", 50*85); 
  Systemoutprintf("上面价格的16进制数是：%a %n", 50*85); 
  Systemoutprintf("上面价格的指数表示：%e %n", 50*85); 
  Systemoutprintf("上面价格的指数和浮点数结果的长度较短的是：%g %n", 50*85); 
  Systemoutprintf("上面的折扣是%d%% %n", 85); 
  Systemoutprintf("字母A的散列码是：%h %n", 'A'); 
} 
```

输出结果：

```
Hi,王力 
Hi,王南:王力王张 
字母a的大写是：A  
3>7的结果是：false  
100的一半是：50  
100的16进制数是：64  
100的8进制数是：144  
50元的书打5折扣是：500000 元 
上面价格的16进制数是：0x54p5  
上面价格的指数表示：250000e+01  
上面价格的指数和浮点数结果的长度较短的是：5000  
上面的折扣是85%  
字母A的散列码是：41 
```

也可以搭配转换符的标志

| 标  志 | 说  明                                                   | 示例                    | 结果             |
| ------ | -------------------------------------------------------- | ----------------------- | ---------------- |
| +      | 为正数或者负数添加符号                                   | ("%+d",15)              | +15              |
| -      | 左对齐                                                   | ("%-5d",15)             | \|15 \|          |
| 0      | 数字前面补0                                              | ("%04d", 99)            | 0099             |
| 空格   | 在整数之前添加指定数量的空格                             | ("% 4d", 99)            | \| 99\|          |
| ,      | 以“,”对数字分组                                          | ("%,f", 9999.99)        | 9,999.990000     |
| (      | 使用括号包含负数                                         | ("%(f", -99.99)         | (99.990000)      |
| #      | 如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0 | ("%#x", 99)             | ("%#o", 99)      |
| <      | 格式化前一个转换符所描述的参数                           | ("%f和%<3.2f", 99.45)   | 99.450000和99.45 |
| $      | 被格式化的参数索引                                       | ("%1$d,%2$s", 99,"abc") | 99,abc           |

```java
public static void main(String[] args) { 
  String str=null; 
  //$使用 
  str=Stringformat("格式参数$的使用：%1$d,%2$s", 99,"abc");       
  Systemoutprintln(str);            
  //+使用 
  Systemoutprintf("显示正负数的符号：%+d与%d%n", 99,-99); 
  //补O使用 
  Systemoutprintf("最牛的编号是：%03d%n", 7); 
  //空格使用 
  Systemoutprintf("Tab键的效果是：% 8d%n", 7); 
  //使用 
  Systemoutprintf("整数分组的效果是：%,d%n", 9989997); 
  //空格和小数点后面个数 
  Systemoutprintf("一本书的价格是：% 5f元%n", 8); 
} 
```

输出结果：

```
格式参数$的使用：99,abc 
显示正负数的符号：+99与-99 
最牛的编号是：007 
Tab键的效果是：    7 
整数分组的效果是：9,989,997 
一本书的价格是：80000元 
```

## StringBuffer(重要)

> **StringBuffer是对String类的增强**

### 基本介绍

- java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删
- 很多方法都是和String相同的，**但StringBuffer是可变长度的**
- StringBuffer是一个容器
- StringBuffer的直接父类是`AbstractStringBuilder`
- StringBuffer实现了Serializable，即StringBuffer的对象可以串行化
- 在StringBuffer的父类`AbstractStringBuilder`中，**有属性char[] value，且这个属性不带有任何修饰符(不是final类型)**
  - **该value数组存放字符串内容**
  - 因此，**数据存放在堆中**，而不是常量池
- StringBuffer是一个final类，不可以被继承

#### String Vs StringBuffer

1. **`String`**，<u>里面的值不能更改</u>，**每次String类的更新实际上就是在更改地址，效率较低**
   `private final char value[]` 这个放在常量池
2. **`StringBuffer`**保存的是字符串变量，<u>里面的值可以更该</u>，**每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高**
   `char[] value`这个存放在堆中
3. String每次更新-->在常量池更改地址（创建新的对象），无论更新的内容是1个字符还是10个字符
4. StringBuffer更新--> 不用每次都更换地址
   1. 比方说，StringBuffer原先有16个空间，第一次用了五个空间，没有用完，那么往后添加数据，只是在他的空间中追加了一个字段，直到这16个空间被填充满了，才会创建新的对象（并添加地址）
   2. 所以他的效率高于String

![image-20211104171931252](/images/Java/JavaSE/12-常用类/image-20211104171931252.png)

可以看到它的构造方法中默认容量为16个字符

```java
package com.StringBuffer_;

public class StringBuffer01 {
    public static void main(String[] args) {
//        构造器的解析
//        1 默认无参构造器 创建一个大小为16的char[]数组，用于存放字符内容
        StringBuffer stringBuffer = new StringBuffer();
//        2 通过构造器指定char[]数组的大小 这里制定了100
        StringBuffer stringBuffer1 = new StringBuffer(100);
//        3 通过给一个String创建一个StringBuffer
//        这里char[]数组的长度为:str.len + 16=21
        StringBuffer stringBuffer2 = new StringBuffer("Hello");
    }
}

```

### String和StringBuffer的相互转换

 ```java
 package com.StringBuffer_;
 
 public class StringAndStringBuffer {
     public static void main(String[] args) {
 //        String-->StringBuffer
         String str ="hello tom";
 //        方式1  使用构造器
         StringBuffer stringBuffer = new StringBuffer(str);
 //        方式2 使用append方法
         StringBuffer stringBuffer1 = new StringBuffer();
         stringBuffer1.append(str);
 
 //        StringBuffer-->String
         StringBuffer stringBuffer2 = new StringBuffer("世界你好");
 //        方式1：StringBuffer提供的toString
         String str1 = stringBuffer2.toString();
 //        方式2 使用构造器来搞定 String构造器可以接受StringBuffer
         String s = new String(stringBuffer2);
 
     }
 }
 ```

### StringBuffer类常见方法

在开始前，我定义了一个StringBuffer:`StringBuffer hello = new StringBuffer("hello");`

- 增 append

  ```java
  // hello="hello"
  hello.append(',');
  hello.append("张三");
  hello.append(3 + 5 + 10)
      .append(true)
      .append(1.35);
  /*
           ToString方法：
           @Override
          public synchronized String toString() {
              if (toStringCache == null) {
                  toStringCache = Arrays.copyOfRange(value, 0, count);
              }
              return new String(toStringCache, true);
  }*/
  System.out.println(hello); //hello,张三18true1.35
  ```

- 删除 delete
  删除索引为>=start&&<end的字符
  下面是删除第5~8位的字符（不包含第八位）

  ```java
  // hello="hello,张三18true1.35"
  hello.delete(5,8);
  System.out.println(hello); //把",张三" 这三个字符给删除掉了: hello18true1.35
  ```

- 替换replace
  使用World替换索引从5~7的字符（不包含7）

  ```java
  // hello="hello18true1.35"
  hello.replace(5,7,"World");
  System.out.println(hello);//把18替换成了HelloWorld：helloWorldtrue1.35
  ```

- 查找 indexOf
  查找某个字符串在StringBuffer中第一次出现的字符的位置
  这里World是从第五位开始的，所以是5
  如果找不到则返回-1

  ```java
  // hello="helloWorldtrue1.35"
  int indexOf = hello.indexOf("World");
  System.out.println(indexOf);//5
  ```

- 插入 insert
  在索引为 5 的位置之前插入（4和5的中间）指定的字符串
  从索引为5开始的内容自动后移要插入的内容的长度

  ```java
  //  hello="helloWorldtrue1.35"
  hello.insert(5,"空格");
  System.out.println(hello); //hello空格Worldtrue1.35
  ```

- 获取长度 length

  ```java
  // hello="hello空格Worldtrue1.35"
  System.out.println(hello.length());//20
  ```

- 开发中还有可能用带其他的，用到了再去查

### 扩展-动态的给double数值添加_

```java
package com.StringBuffer_;

import java.util.Scanner;

/**
 * 需求，根据用户输入的double，自动每隔三位数加个_(整数位，小数位不管)
 */
public class StringBufferExecise01 {
    public static void main(String[] args) {
//        获取用户输入的数值
        Scanner scanner = new Scanner(System.in);
        init(scanner);

    }

    public static void init(Scanner scanner) {
        //        创建字符串缓存流
        StringBuffer stringBuffer = new StringBuffer();
        while (true) {
//            删除历史遗留记录
            if (stringBuffer.length() > 0) {
                stringBuffer.delete(0, stringBuffer.length() - 1);
            }
            System.out.print("请输入一段数值：");
//            先获取到用户的输入
            String userInput = scanner.nextLine();
            try {
                double number = Double.parseDouble(userInput);
//                将number传入到流之中
                stringBuffer.append(number);
//                解决用户输入的数值太大太长导致出现E的问题
                if (stringBuffer.indexOf("E") != -1) throw new NumberFormatException("数值太长");
//                解决用户输入了多个小数点的问题
                if (stringBuffer.indexOf(".") != stringBuffer.lastIndexOf("."))
                    throw new NumberFormatException("小数点过多");
//                获取小数点的indexOf，如果
                for (int i = stringBuffer.indexOf(".") - 3; i > 0; i -= 3) {
                    stringBuffer.insert(i, "_");
                }
                System.out.println("String:" + stringBuffer);
            } catch (NumberFormatException e) {
                System.out.println(e.getMessage());
            }
        }
    }

}
```

## StringBuilder(重要)

### 基本介绍

1. 一个可变的字符序列，此类提供一个与StringBuffer兼容的API，但不保证同步，该类的涉及用作StringBuffer的一个简易替换，**在字符串缓冲区被单个线程使用的时候，如果可能，建议优先使用`StringBuilder`，因为在大多数实现中，它都比StringBuffer更快**

2. 在StringBuilder上主要是操作append和insert方法，可以重载这些方法，以接受任意类型的数据

3. StringBuilder和StringBuffer的区别：StringBuilder用在单线程，StringBuffer用在多线程

4. 它有的方法和StringBuffer一样

5. StringBuilder的直接父类是`AbstractStringBuilder`

6. StringBuilder实现了Serializable，即StringBuilder的对象可以串行化（对象可以传输到网络，也可以保存到文件）

7. 是一个final类，不能被继承

8. 数据也是存放在欺负类AbstractStringBuilder的char value[]，因此字符序列是存放在堆中

   ```java
   @Override
   synchronized StringBuffer append(AbstractStringBuilder asb) {
       toStringCache = null;
       super.append(asb);
       return this;
   } 
   //绝大部分方法中都用了synchronized
   ```

9. **StringBuilder的方法没有做任何互斥的处理，即没有`synchronized`关键字的包裹，所以是不安全的线程**因此，只推荐在单线程的情况下使用StringBuilder

   ```java
   public StringBuilder append(StringBuffer sb) {
       super.append(sb);
       return this;
   }
   //所有方法中都没有synchronized
   ```

### String、StringBuilder、StringBuffer的比较

1. StringBuffer和StringBuilder非常类似，军代表可变的字符序列，且方法也一样
2. String：不可变字符序列，效率低，但是复用性高
3. StringBuffer：可变字符序列，效率较高（增删），线程安全(带有synchronized关键字，每次运行前都会进行线程判断)
4. StringBuilder：可变字符序列，效率最高，线程不安全(没有synchronized关键字)

可以尝试一下比较他们：

```java
package com.StringBuffer_;

public class StringBuilder01 {
    public static void main(String[] args) {
        long startTime = 0L;
        long endTime = 0L;
        String text = "";
        StringBuffer stringBuffer = new StringBuffer("");
        StringBuilder stringBuilder = new StringBuilder("");
        startTime = System.currentTimeMillis();

        for (int i = 0; i < 200000; i++) {
            stringBuffer.append(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("stringBuffer的所用时间是：" + (endTime - startTime)+"ms");
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 200000; i++) {
            stringBuilder.append(i);
        }
        endTime = System.currentTimeMillis();

        System.out.println("stringBuilder的所用时间是：" + (endTime - startTime)+"ms");
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 200000; i++) {
            text+=i;
        }
        endTime = System.currentTimeMillis();

        System.out.println("String的所用时间是：" + (endTime - startTime)+"ms");


    }
}

```

只能说，运行的时候一看卧槽不得了..

```java
stringBuffer的所用时间是：28ms
stringBuilder的所用时间是：10ms
String的所用时间是：30573ms
```

当然我也尝试了一下拼接两千万次

![image-20211105005251767](/images/Java/JavaSE/12-常用类/image-20211105005251767.png)

这里不敢尝试String，感觉没个半个小时它跑不完

## String的总结

使用的原则：结论：

1. 如果字符串存在大量的修高操作，一般使用StringBuffer或者StringBuilder
2. 如果字符串存在大量的修改操作，并在**单线程**的情况，使用**StringBuilder**
3. 如果字符串存在大量的修改操作，并在**多线程**的情况，使用**StringBuffer**
4. 如果字符串**很少修改**，被**多个对象引用**，使用**String**，比如配置信息等

## Math

> Math类包含用于执行基本数学运算的各种方法，比如初等指数，对数，平方根和三角函数等

![image-20211105010014540](/images/Java/JavaSE/12-常用类/image-20211105010014540.png)

可以通过它的类图发现没有继承除了Object以外的任何父类，方法有一大堆，变量有一大堆..

**它的方法均为静态方法**

常用的如下：

```java
package com.math_;

public class MathMethods {
    public static void main(String[] args) {

//        Math的具体用法

//        1 求绝对值 abs
        int abs = Math.abs(9);
        System.out.println(abs);

//        2 求幂 pow
        double pow = Math.pow(-3.5, 4);//-3.5的四次方
        System.out.println(pow);

//        3 ceil 向上取整，返回>=该参数的最小整数
        double ceil = Math.ceil(-3.9);
        System.out.println(ceil); //-3.0

//        4 floor 向下取整，返回<=该参数的最大整数(double)
        double floor = Math.floor(4.0001);
        System.out.println(floor);//4.0

//        5 round 四舍五入
        long round = Math.round(-5.565645);
        System.out.println(round); //6

//        6 开方
        double sqrt = Math.sqrt(9.0); //负数的话会返回NaN
        System.out.println(sqrt); //3.0

//        7  random 返回0~1之间的随机小数
//        0<=x<1
        System.out.println("----Random");
        for (int i = 0; i < 10; i++) {
            System.out.println(Math.random());

        }
//        思考：获取a~b之间的一个随机整数，a，b均为整数：2~7
//         a<=number<(a+b-a)
        System.out.println("获取到的值为：");
//        使用递归方法
//        System.out.println(ranInt(2,7));
//        使用直接获取的方法
//        1. (int)a <=number<=(int)(a+Math.random()*(b-a)+1)
//        Math.random()*(b-a):0<=number<b-a
//        a=2 b=7
//        System.out.println("获取到的值为：");
        System.out.println((int)(2+Math.random()*(7-2)+1));

//        max min 返回最大最小值
        int min =Math.min(5,111);
        System.out.println(min);//5
        int max = Math.max(5,111);
        System.out.println(max);//111

    }

    public static int ranInt(int firstNumber, int lastNumber) {
        int num = (int) (Math.random() * 10);
        if (num >= lastNumber || num <= firstNumber) {
            return ranInt(firstNumber, lastNumber);
        }
        return num;
    }


}
```

## Arrays

Arrays里面包含了一系列静态方法，用于管理或者操作数组（比如排序和搜索）

### Arrays的常用方法

```java
package com.arrays_;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class ArraysMethods {
    public static void main(String[] args) {
//        演示Arrays的常用方法

        Integer[] integers = {1, 20, 30};
//        以前遍历数组
        for (Integer integer : integers) {
            System.out.println(integer);
        }
        System.out.println("使用Arrays");
//        1. Arrays.toString() 格式化数组并打印
        System.out.println(Arrays.toString(integers));//[1, 20, 30]

//        2.1. sort排序
        Integer[] arr = {1, -1, 7, 0, 89, 666, 53, 48, 15};
//        进行排序
//        虽然可以直接使用冒泡排序，但是sort是真滴方便
        System.out.println("排序前：" + Arrays.toString(arr));
        Arrays.sort(arr); //数组是引用类型，所以这里是直接更该其值，而不是指向新的地址
        System.out.println("默认排序后：" + Arrays.toString(arr)); //[-1, 0, 1, 7, 15, 48, 53, 89, 666]
//        2.2 sort方法是重载的，可以通过传入一个接口Comparator实现定制排序
        System.out.println("定制排序方法");
        arr = new Integer[]{1, -1, 7, 60, 10, 0, 89, 666, 53, 48, 15};
//        使用匿名内部类
//        2.3 调用定制排序时，传入了两个参数
//        (1)要排序的数组
//        (2)实现了Comparator接口的匿名内部类，要求实现compare方法
//        2.4 这里实现了接口编程的一种方式，先下个Debug看看
//        源码分析：
//        (1)  Arrays.sort(arr, new Comparator(){}
//        (2)  这一步最终走到了一个方法binarySort(二叉树排序),所在类:TimSort
//        (3)  执行到binarySort中的方法,
//        到c.compare会根据动态绑定机制去执行我们传入的匿名内部类的compare方法
//        (4)  public int compare(Integer o1, Integer o2)返回的值是>0还是<0
//        会影响到整个排序结果
//        这就充分体现了 接口编程+匿名内部类+动态绑定的综合使用
//        将来的底层框架和源码的使用方法，类似于这样的会非常多
        /*
         * while(left<right){
         *   int mid=(left+right)>>>1;
         *   if(c.compare(pivot,a[mid)<0){
         *       rigth=mid;
         *   }else{
         *       left=mid+1;
         *   }
         * }
         * */

        Arrays.sort(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
//                这里实现了从大到小的排序
                return o2 - o1;
            }
        });
        System.out.println(Arrays.toString(arr));

//        3. binarySearch通过二分搜索法进行查找某个值的在数组中的位置，要求必须先排好序(正序排序)，
//        找不到则返回：return -(low)+1; 可以就是说，这下面的663本来是在666之前，即：数组的第10位
//        但是二叉查找并没有在对应的位置上找到他， 所以返回它的位置+1并取反-也就是说，他如果存在的话，应该在第11位上面
        System.out.println("二分搜索排序：");
        Arrays.sort(arr);
        System.out.println(Arrays.binarySearch(arr, 663));

//        4. copyOf 数组的元素复制 见名知意，讲一个数组的所有元素复制到一个新的数组上，省去了自己fori
//        这里相当于是：从arr数组中，拷贝从第0到第(arr.length-1)个元素，到arr2数组中
//        如果下面的的第二个参数变为length +1 新数组则最后一个位置的参数为空(null)
//        如果第二个参数为len-n，则新的数组的长度将会比旧数组少n位
//        如果拷贝的长度小于0，则会抛出异常：负数异常
//        该方法的底层使用的是System.arraycopy()
        Integer[] arr2 = Arrays.copyOf(arr, arr.length+1);
        System.out.println("拷贝后的数组："+Arrays.toString(arr2));

//        5. fill 数组填充
        Integer[] num = new Integer[]{9,3,2};
//        用指定的数值替换数组中的所有元素，
        Arrays.fill(num,99);
        System.out.println("数组的填充：");
        System.out.println(Arrays.toString(num)); //[99, 99, 99]

//        6. equals 比较两个数组的内容是否完全一致 一致指的是长度，元素值，元素位置都完全一致
        Integer[] arr3 = new Integer[]{9,3,2};
        Integer[] arr4  = Arrays.copyOf(arr, arr3.length);
        Arrays.sort(arr4);
        System.out.println("判断两个数组是否完全一致");
        System.out.println(Arrays.equals(arr3, arr4)); //false

//        7.  arList 将一组值，转换成list
//        会将(2, 3, 4, 5, 6, 7, 8, 9)转换成一个list的集合，并返回
//        集合在后面会降到
//        返回的变异类型就是左边的List<Integer>
        List<Integer> list = Arrays.asList(2, 3, 4, 5, 6, 7, 8, 9);
        System.out.println("Arrays.asLis:"+list);
        System.out.println("list的运行类型:"+list.getClass());
        //class java.util.Arrays$ArrayList  Arrays的内部类ArrayList
    }
}
```

### 扩展-定制排序

```java
package com.arrays_;

import java.util.Arrays;
import java.util.Comparator;

public class ArraySortCustom {
    public static void main(String[] args) {
        int[] arr = {1, -1, 50, 30, 650, 504, 3};
        System.out.println("冒泡排序后的情况：" + Arrays.toString(bubbleSort(arr)));
//        使用自定义冒泡排序
        int[] arrays_ = bubbleSort02(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        });
        System.out.println("使用定制排序后的情况：");
        System.out.println(Arrays.toString(arrays_));
    }

    //    使用冒泡 进行排序
    public static int[] bubbleSort(int[] arr) {
        int temp = 0;
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
//                从小到大排序
                if (arr[j] > arr[j + 1]) {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        return arr;
    }

    //    需求：结合冒泡+定制
    public static int[] bubbleSort02(int[] arr, Comparator<Integer> c) {
        int temp = 0;
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
//
                if (c.compare(arr[j], arr[j + 1]) > 0) {
//                    大于0则表示是从小到大，第一个数大于第二个数，交换两个数的位置
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }

            }
        }
        return arr;
    }

}
```

#### 扩展-小练

> 现在有一个类Book，属性有name和price，请使用Comparator来完成正序，倒序，和根据书本名字长短来排序

```java
package com.arrays_;

import java.util.Arrays;
import java.util.Comparator;

public class ArrayExercise {
    public static void main(String[] args) {
        Book[] books = new Book[6];
        books[0] = new Book("如何高效的吃宴席", 22.33);
        books[1] = new Book("理论的下葬", 453.13);
        books[2] = new Book("Java从入门到入土", 99.99);
        books[3] = new Book("JavaScript从入门到学Java", 11.11);
        books[4] = new Book("一生", 1.5);
        books[5] = new Book("迷", 9999.6);


//        排序方式1：使用Arrays自带的sort+Comparator 实现正序排序
        Arrays.sort(books, new Comparator<Book>() {
            @Override
            public int compare(Book b1, Book b2) {
                return (int) (b1.getPrice() - b2.getPrice());
            }
        });
        System.out.println("使用Arrays.Sort进行的正序排序");
        System.out.println(getJsonString(books));

//        方法2 使用自己写的冒泡排序来完成倒序排序：
        mysort(books, new Comparator<Book>() {
            @Override
            public int compare(Book o1, Book o2) {
                return (int) (o2.getPrice() - o1.getPrice());

            }
        });
        System.out.println("使用MySort进行的倒序排序：");
        System.out.println(getJsonString(books));

//        方法3 根据自己的方法，根据名字来完成从短到多的排序
        mysort(books, new Comparator<Book>() {
            @Override
            public int compare(Book o1, Book o2) {

                return o1.getName().length() - o2.getName().length();
            }
        });

        System.out.println("使用MySort进行的按照名字顺序从短到长进行排序：");
        System.out.println(getJsonString(books));

    }

    /**
     * 传入一个Book的正序，使用冒泡排序法进行排序
     *
     * @param books      BOOK的数组
     * @param isSequence 排序的规则，一个Comparator实例对象
     */
    public static void mysort(Book[] books, Comparator<Book> isSequence) {
        Book book;

        for (int i = 0; i < books.length - 1; i++) {
            for (int j = 0; j < books.length - i - 1; j++) {
                if (isSequence.compare(books[j], books[j + 1]) > 0) {
                    book = books[j];
                    books[j] = books[j + 1];
                    books[j + 1] = book;
                }
            }
        }
    }

    /**
     * 重写的列表展现方式，让其看起来更Json一点，直观易懂
     *
     * @param objs OBj数组
     * @return 一个String，长得很像Json
     */
    public static String getJsonString(Object[] objs) {
        StringBuilder stringBuilder = new StringBuilder("[\n");
        for (int i = 0; i < objs.length; i++) {
            if (i != objs.length - 1) {
                stringBuilder.append("\t").append(objs[i].toString()).append(",\n");
                continue;
            }
//            最后一个对象不在末尾添加逗号
            stringBuilder.append("\t").append(objs[i].toString()).append("\n");
        }
        stringBuilder.append("]");
        return stringBuilder.toString();
    }

}

class Book {
    private String name;
    private double price;

    @Override
    public String toString() {

        return String.format("{name:\"%s\",price:\"%.2f\"}", name, price);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public Book(String name, double price) {
        this.name = name;
        this.price = price;
    }
}
```

## System

### System的常用方法

- `exit` 退出当前程序

  ```java
  System.exit(0);
  //0 表示一个状态，正常的状态，一般让程序退出都是这样写
  ```

- `arraycopy` 复制数组元素，比较适合底层调用，一般都是使用Arrays.copyOf来完成复制数组

  ```java
  int[] src={1,2,3};
  int dest =new int[3];
  System.arraycopy(src,0,dest,0,3);
  五个参数：
      01 src 源数组;
   02 srcPos 从源数值的哪个索引位置开始拷贝;
   03 dest 目标数组;
   0 destPos 把源数值的数据拷贝到目标数组的哪个索引(位置);
   05 length 要从源数组拷贝多少个数据到目标数组;
  ```

- `cuurentTimeMillens`：返回当前时间距离1970年1月1日00:00的**毫秒数**

- ~~`gc`运行垃圾回收机制System.gc()~~ 这个平常建议不用

## BigInteger BigDecimal

这两个类能解决浮点数因为精度问题导致的(0.9999998)以及数值太大(99999999999999999)这类的问题

- `BigInteger`适合**保存比较大的整数**
- `BigDecimal`适合**保存精度更高的浮点类型(小数)**

### BigInteger的使用

```java
package com.bignumber_;

import java.math.BigInteger;

public class BigintegerMethod {
    public static void main(String[] args) {
//        当编程中需要处理很大的数的时，long不够用，就可以使用BigInteger这个类来解决问题
//        999999999999156456431213246545645645646546
//        创建 BigInteger 将数值用字符串包裹表示
        BigInteger bigInteger = new BigInteger("999999999999999999999999999999999999999999999999");
        System.out.println(bigInteger); //输出

//        对齐进行加减乘除，需要使用方法来加减乘除，不能直接+-*/ 返回值是bigInteger
//        传入的值只能是BigTeger类型的，非该类型需要用valueOf装箱
//        即：不能穿入小数
//        并且返回的值，例如除法中若有小数会被自动四舍五入划掉

//        加法
        BigInteger bigInteger1 = bigInteger.add(BigInteger.valueOf(10));
        BigInteger bigInteger2 = bigInteger.add(new BigInteger("54564565165456465456"));
        System.out.println(bigInteger1);
        System.out.println(bigInteger2);

//        减法 subtract
        BigInteger bigInteger3 = bigInteger.subtract(BigInteger.valueOf(12312345645656L));
        System.out.println(bigInteger3);

//        乘法 multiply
        BigInteger bigInteger4 = bigInteger.multiply(BigInteger.valueOf(5));
        System.out.println(bigInteger4);

//        除法 divide
        BigInteger bigInteger5 = bigInteger.divide(BigInteger.valueOf(2));
        System.out.println(bigInteger5);

    }
}
```

#### BigDecimal的使用

```java
package com.bignumber_;

import java.math.BigDecimal;

public class BigDecimalMethod {
    public static void main(String[] args) {
//        比如说有一个数：1.1354564561565646548977897654456;
//        来看看普通double输出的值：
        System.out.println("double:"+(double) 1.1354564561565646548977897654456);
//        结果：1.1354564561565648 可以看到精度被缩减了
//        截下来使用BigDecimal:
        BigDecimal bigDecimal = new BigDecimal("1.1354564561565646548977897654456");
        System.out.println("BigDecimal:"+bigDecimal); //1.1354564561565646548977897654456 进度没有任何缩减

//        进行加减乘除和BigInteger差不多一样，不过要传入的值限定为BigDecimal，可以穿入小数进行减加乘除

//        加 add
        System.out.println("add:" + bigDecimal.add(BigDecimal.valueOf(1111.564687)));

//        减 subtract
        System.out.println("subtract:" + bigDecimal.subtract(new BigDecimal("165156166666.16534156564")));

//        乘法 multiply
        System.out.println("multiply:" + bigDecimal.multiply(BigDecimal.valueOf(5.5655)));

//        除法 divide 可能会抛出异常：在除出的数是无线循环小数时
//        System.out.println("divide:"+bigDecimal.divide(BigDecimal.valueOf(2.1)));
// Exception in thread "main" java.lang.ArithmeticException:
// Non-terminating decimal expansion; no exact representable decimal result.
//        解决方法：在调用divide方法时，指定精度即可
//        这里BigDecimal.ROUND_DOWN 相当于是定义值的精度：即bigDecimal的精度 1.1354564561565646548977897654456
//
        System.out.println("divide:" + bigDecimal.divide(BigDecimal.valueOf(2.1),BigDecimal.ROUND_DOWN));
    }
}
```

## Date、Calendar、LocalDate

这个。。。时间类要用到了再去查即可，一般都是format now Date 或者format后的值转成Date
