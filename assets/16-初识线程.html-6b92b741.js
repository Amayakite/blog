const n=JSON.parse('{"key":"v-47e4b932","path":"/JavaLang/JavaSE/16-%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B.html","title":"16-初识线程","lang":"zh-CN","frontmatter":{"title":"16-初识线程","date":"2021-11-10T22:31:30.000Z","category":"JavaSE","tag":["Java","JavaSE","Thread"],"description":"线程介绍 线程这玩意应该是整个Java中最重要的部分了，能掌握多线程高并发者得天下也不是白说的... md终于学到这里了 在正式开始前，先回顾下几个点 程序(Program) 是为我们完成特定任务，用某种语言编写的一直输指令的集合 简单来说 就是我们写的代码 public class HelloWorld{ public static void main(String[] args){ System.out.println(\\"Hello World!\\"); } } 进程 进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间，当我们使用迅雷，又启动了一个进程，操作系统将会为迅雷分配新的内存空间，再或者说，我们使用Java运行了了一个java HelloWorld，又启动了一个进程，操作系统也将会为他分配新的内存空间 进程是程序的一次执行过程，或是正在运行的一个程序，是动态过程:有它自身的产生，存在和消亡的过程 也就是说，正在运行的程序叫做进程，一个进程是一定会占用内存空间的，只是占用的多与少的问题，进程结束后，系统会自动释放其资源，打个比方：人生存一定要占用地球的空间，只是小孩占用的空间小一点，大人占用的空间多一点，安息后就火化尘归尘土归土，本身就不占用空间了，它住的房子就可以挪出来给别人用 再比如说，我现在打开了原神，一个进程就被创建了，当我关闭原神时，一个线程就销毁了，这就是线程 当然如果感觉抽象的话，可以打开任务管理器看看 我还没开原神时，我电脑上有这些线程 当我打开原神时 可以看到任务管理器中多出了一个线程，名为launcher 当我关闭原神时 这个线程就没了 它占用的空间也可以在上图中看到，70.6MB(当然这是我还没有启动游戏本体的情况下)，也会吃掉我们的Cpu，也就是说，只要启动了一个进程，就一定会吃掉CPU和内存的空间 线程 什么是线程？ 线程是由进程创建的，是进程的一个实体 一个进程可以拥有多个线程，比如：迅雷/百度云/阿里云/OneDrive/GoogleDrive...等，这些进程在同时下载/上传多个文件时，会开启多条线程，比如：当我使用阿里云同时上传多个文件：这其实就是创建了多个线程来同时进行，以让我的上传效率最大化 线程可以套娃创建：一个线程中再创建一个线程--之后会了解到 其他相关概念 单线程：同一个时刻，只允许执行一个线程 多线程：同一个时刻，可以执行多个线程：比如，一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件 并发 同一时刻，多个任务交替执行，造成一种貌似同时的错觉，简单的说，单核CPU 实现的多任务就是并发 比方说：有个人再开车时打电话，你可能会认为它正在边开车边打电话，实际上它的大脑再某个瞬间只再做一件事情-要么正在操控方向盘开车，要么正在跟电话另一头的人说话(所以说我国法律规定开车的时候不能打电话，因为它在跟人交流的时候，就有可能忽略了踩刹车) 并行 同一时刻，多个任务同时执行，多核CPU可以实现并行 比方说：一个人开车，一个人接电话，互不干扰，都在专心干自己的事情 当然程序的世界不可能这么简单，程序有可能正在并行+并发，他们两是可以同时存在的，比如说电脑上开了500个QQ和500个原神，但是CPU只有8个，电脑就会让CPU一会儿执行CPU，一会儿执行原神，这种情况下，对于单个CPU的视角来看，他正在并发，对于多个CPU的视角来看，他们正在并行 那么，提出一个简单的问题，如何通过Java来知道我们的电脑中有多少个可用的CPU(多少核)呢，只需要编写以下代码即可： package com; public class CpuNumber { public static void main(String[] args) { Runtime runtime = Runtime.getRuntime(); // available 获取 Processors 处理器 available Processors 可用处理器 int cpuNumber = runtime.availableProcessors(); System.out.println(cpuNumber); } } 通过这两句话就可以轻松的获取电脑上可用的CPU的个数，当然原理先不谈","head":[["meta",{"property":"og:url","content":"http://www.amayakite.github.io/JavaLang/JavaSE/16-%E5%88%9D%E8%AF%86%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"Amayakite Blogs"}],["meta",{"property":"og:title","content":"16-初识线程"}],["meta",{"property":"og:description","content":"线程介绍 线程这玩意应该是整个Java中最重要的部分了，能掌握多线程高并发者得天下也不是白说的... md终于学到这里了 在正式开始前，先回顾下几个点 程序(Program) 是为我们完成特定任务，用某种语言编写的一直输指令的集合 简单来说 就是我们写的代码 public class HelloWorld{ public static void main(String[] args){ System.out.println(\\"Hello World!\\"); } } 进程 进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间，当我们使用迅雷，又启动了一个进程，操作系统将会为迅雷分配新的内存空间，再或者说，我们使用Java运行了了一个java HelloWorld，又启动了一个进程，操作系统也将会为他分配新的内存空间 进程是程序的一次执行过程，或是正在运行的一个程序，是动态过程:有它自身的产生，存在和消亡的过程 也就是说，正在运行的程序叫做进程，一个进程是一定会占用内存空间的，只是占用的多与少的问题，进程结束后，系统会自动释放其资源，打个比方：人生存一定要占用地球的空间，只是小孩占用的空间小一点，大人占用的空间多一点，安息后就火化尘归尘土归土，本身就不占用空间了，它住的房子就可以挪出来给别人用 再比如说，我现在打开了原神，一个进程就被创建了，当我关闭原神时，一个线程就销毁了，这就是线程 当然如果感觉抽象的话，可以打开任务管理器看看 我还没开原神时，我电脑上有这些线程 当我打开原神时 可以看到任务管理器中多出了一个线程，名为launcher 当我关闭原神时 这个线程就没了 它占用的空间也可以在上图中看到，70.6MB(当然这是我还没有启动游戏本体的情况下)，也会吃掉我们的Cpu，也就是说，只要启动了一个进程，就一定会吃掉CPU和内存的空间 线程 什么是线程？ 线程是由进程创建的，是进程的一个实体 一个进程可以拥有多个线程，比如：迅雷/百度云/阿里云/OneDrive/GoogleDrive...等，这些进程在同时下载/上传多个文件时，会开启多条线程，比如：当我使用阿里云同时上传多个文件：这其实就是创建了多个线程来同时进行，以让我的上传效率最大化 线程可以套娃创建：一个线程中再创建一个线程--之后会了解到 其他相关概念 单线程：同一个时刻，只允许执行一个线程 多线程：同一个时刻，可以执行多个线程：比如，一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件 并发 同一时刻，多个任务交替执行，造成一种貌似同时的错觉，简单的说，单核CPU 实现的多任务就是并发 比方说：有个人再开车时打电话，你可能会认为它正在边开车边打电话，实际上它的大脑再某个瞬间只再做一件事情-要么正在操控方向盘开车，要么正在跟电话另一头的人说话(所以说我国法律规定开车的时候不能打电话，因为它在跟人交流的时候，就有可能忽略了踩刹车) 并行 同一时刻，多个任务同时执行，多核CPU可以实现并行 比方说：一个人开车，一个人接电话，互不干扰，都在专心干自己的事情 当然程序的世界不可能这么简单，程序有可能正在并行+并发，他们两是可以同时存在的，比如说电脑上开了500个QQ和500个原神，但是CPU只有8个，电脑就会让CPU一会儿执行CPU，一会儿执行原神，这种情况下，对于单个CPU的视角来看，他正在并发，对于多个CPU的视角来看，他们正在并行 那么，提出一个简单的问题，如何通过Java来知道我们的电脑中有多少个可用的CPU(多少核)呢，只需要编写以下代码即可： package com; public class CpuNumber { public static void main(String[] args) { Runtime runtime = Runtime.getRuntime(); // available 获取 Processors 处理器 available Processors 可用处理器 int cpuNumber = runtime.availableProcessors(); System.out.println(cpuNumber); } } 通过这两句话就可以轻松的获取电脑上可用的CPU的个数，当然原理先不谈"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-17T15:14:40.000Z"}],["meta",{"property":"article:author","content":"Amayakite"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaSE"}],["meta",{"property":"article:tag","content":"Thread"}],["meta",{"property":"article:published_time","content":"2021-11-10T22:31:30.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-17T15:14:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"16-初识线程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-11-10T22:31:30.000Z\\",\\"dateModified\\":\\"2023-06-17T15:14:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Amayakite\\",\\"url\\":\\"https://github.com/Amayakite\\"}]}"]]},"headers":[{"level":2,"title":"线程介绍","slug":"线程介绍","link":"#线程介绍","children":[{"level":3,"title":"进程的详解","slug":"进程的详解","link":"#进程的详解","children":[]}]},{"level":2,"title":"线程的概念(Thread)","slug":"线程的概念-thread","link":"#线程的概念-thread","children":[]},{"level":2,"title":"线程基本使用","slug":"线程基本使用","link":"#线程基本使用","children":[]},{"level":2,"title":"Thread","slug":"thread","link":"#thread","children":[{"level":3,"title":"jconsole的使用","slug":"jconsole的使用","link":"#jconsole的使用","children":[]}]},{"level":2,"title":"start()的深入了解","slug":"start-的深入了解","link":"#start-的深入了解","children":[{"level":3,"title":"分析Start的源码","slug":"分析start的源码","link":"#分析start的源码","children":[]}]},{"level":2,"title":"实现Runnable接口","slug":"实现runnable接口","link":"#实现runnable接口","children":[{"level":3,"title":"线程的应用案例-多线程执行","slug":"线程的应用案例-多线程执行","link":"#线程的应用案例-多线程执行","children":[]},{"level":3,"title":"一个经典的问题-多个线程同时操控一个变量","slug":"一个经典的问题-多个线程同时操控一个变量","link":"#一个经典的问题-多个线程同时操控一个变量","children":[]}]},{"level":2,"title":"线程常用的方法","slug":"线程常用的方法","link":"#线程常用的方法","children":[{"level":3,"title":"基本方法","slug":"基本方法","link":"#基本方法","children":[]},{"level":3,"title":"礼让和插队","slug":"礼让和插队","link":"#礼让和插队","children":[]},{"level":3,"title":"用户线程和守护线程","slug":"用户线程和守护线程","link":"#用户线程和守护线程","children":[]}]},{"level":2,"title":"线程的生命周期","slug":"线程的生命周期","link":"#线程的生命周期","children":[]},{"level":2,"title":"线程的同步","slug":"线程的同步","link":"#线程的同步","children":[{"level":3,"title":"线程的同步机制","slug":"线程的同步机制","link":"#线程的同步机制","children":[]}]},{"level":2,"title":"同步具体方法-Synchronized(互斥锁)","slug":"同步具体方法-synchronized-互斥锁","link":"#同步具体方法-synchronized-互斥锁","children":[{"level":3,"title":"synchronize锁-同步方法的实现","slug":"synchronize锁-同步方法的实现","link":"#synchronize锁-同步方法的实现","children":[]},{"level":3,"title":"synchronize锁-代码块的实现","slug":"synchronize锁-代码块的实现","link":"#synchronize锁-代码块的实现","children":[]},{"level":3,"title":"互斥锁的原理","slug":"互斥锁的原理","link":"#互斥锁的原理","children":[]},{"level":3,"title":"互斥锁的注意事项和细节","slug":"互斥锁的注意事项和细节","link":"#互斥锁的注意事项和细节","children":[]},{"level":3,"title":"线程的死锁","slug":"线程的死锁","link":"#线程的死锁","children":[]},{"level":3,"title":"如何避免死锁","slug":"如何避免死锁","link":"#如何避免死锁","children":[]}]},{"level":2,"title":"Lock锁","slug":"lock锁","link":"#lock锁","children":[]},{"level":2,"title":"Synchronized和Lock的对比","slug":"synchronized和lock的对比","link":"#synchronized和lock的对比","children":[]},{"level":2,"title":"如何释放锁","slug":"如何释放锁","link":"#如何释放锁","children":[{"level":3,"title":"扩展-小练","slug":"扩展-小练","link":"#扩展-小练","children":[]}]},{"level":2,"title":"线程协作-生产者消费者模式","slug":"线程协作-生产者消费者模式","link":"#线程协作-生产者消费者模式","children":[{"level":3,"title":"Wait、Notify--让线程可以通信（Object类中的方法）","slug":"wait、notify-让线程可以通信-object类中的方法","link":"#wait、notify-让线程可以通信-object类中的方法","children":[]},{"level":3,"title":"生产消费者解决方式1-管程法","slug":"生产消费者解决方式1-管程法","link":"#生产消费者解决方式1-管程法","children":[]},{"level":3,"title":"生产消费者解决方式2-信号灯法","slug":"生产消费者解决方式2-信号灯法","link":"#生产消费者解决方式2-信号灯法","children":[]}]},{"level":2,"title":"Wait Notify使用细节","slug":"wait-notify使用细节","link":"#wait-notify使用细节","children":[]},{"level":2,"title":"线程的第三种创建方式-Callable接口","slug":"线程的第三种创建方式-callable接口","link":"#线程的第三种创建方式-callable接口","children":[]},{"level":2,"title":"线程池的基本介绍","slug":"线程池的基本介绍","link":"#线程池的基本介绍","children":[{"level":3,"title":"使用线程池","slug":"使用线程池","link":"#使用线程池","children":[]}]}],"git":{"createdTime":1687006308000,"updatedTime":1687014880000,"contributors":[{"name":"Amayakite","email":"amayakite@qq.com","commits":2}]},"readingTime":{"minutes":54.56,"words":16368},"filePathRelative":"JavaLang/JavaSE/16-初识线程.md","localizedDate":"2021年11月10日","excerpt":"<h2> 线程介绍</h2>\\n<p>线程这玩意应该是整个Java中最重要的部分了，能掌握多线程高并发者得天下也不是白说的...</p>\\n<p>md终于学到这里了</p>\\n<p>在正式开始前，先回顾下几个点</p>\\n<ul>\\n<li>\\n<p>程序(Program)</p>\\n<ul>\\n<li>\\n<p>是为我们完成特定任务，用某种语言编写的一直输指令的集合</p>\\n</li>\\n<li>\\n<p>简单来说 <em>就是我们写的代码</em></p>\\n</li>\\n<li>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">HelloWorld</span><span class=\\"token punctuation\\">{</span>\\n <span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">static</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">String</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> args<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token class-name\\">System</span><span class=\\"token punctuation\\">.</span>out<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">println</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"Hello World!\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>\\n</li>\\n<li>\\n<p>进程</p>\\n<ol>\\n<li>进程是指运行中的程序，比如我们使用<strong>QQ</strong>，就启动了一个进程，<strong>操作系统就会为该进程分配内存空间</strong>，当我们使用<strong>迅雷</strong>，又启动了一个进程，<strong>操作系统将会为迅雷分配新的内存空间</strong>，再或者说，我们使用Java运行了了一个<code>java HelloWorld</code>，又启动了一个进程，操作系统也将会为他分配新的内存空间</li>\\n<li><strong>进程是程序的一次执行过程，或是正在运行的一个程序，是动态过程:有它自身的产生，存在和消亡的过程</strong></li>\\n<li>也就是说，<strong>正在运行的程序叫做进程</strong>，一个进程是一定会占用内存空间的，只是占用的多与少的问题，进程结束后，系统会自动释放其资源，打个比方：人生存一定要占用地球的空间，只是小孩占用的空间小一点，大人占用的空间多一点，安息后就火化尘归尘土归土，本身就不占用空间了，它住的房子就可以挪出来给别人用</li>\\n<li>再比如说，<strong>我现在打开了原神，一个进程就被创建了，当我关闭原神时，一个线程就销毁了，这就是线程</strong><br>\\n<img src=\\"/images/Java/JavaSE/16-初识线程/7a3dbc9d553886bf00a889a303fa8d857ee3659e.gif\\" alt=\\"img\\" loading=\\"lazy\\">\\n<ul>\\n<li>当然如果感觉抽象的话，可以打开任务管理器看看</li>\\n<li>我还没开原神时，我电脑上有这些线程<br>\\n<img src=\\"/images/Java/JavaSE/16-初识线程/image-20211110225711675.png\\" alt=\\"image-20211110225711675\\" loading=\\"lazy\\"></li>\\n<li>当我打开原神时 可以看到任务管理器中多出了一个线程，名为launcher<br>\\n<img src=\\"/images/Java/JavaSE/16-初识线程/image-20211110225747173.png\\" alt=\\"image-20211110225747173\\" loading=\\"lazy\\"></li>\\n<li>当我关闭原神时 这个线程就没了<br>\\n<img src=\\"/images/Java/JavaSE/16-初识线程/image-20211110225829854.png\\" alt=\\"image-20211110225829854\\" loading=\\"lazy\\"></li>\\n<li>它占用的空间也可以在上图中看到，70.6MB(当然这是我还没有启动游戏本体的情况下)，也会吃掉我们的Cpu，也就是说，只要启动了一个进程，就一定会吃掉CPU和内存的空间</li>\\n</ul>\\n</li>\\n</ol>\\n</li>\\n<li>\\n<p>线程</p>\\n<ul>\\n<li>\\n<p>什么是线程？</p>\\n<ol>\\n<li>线程是由进程创建的，是进程的一个实体</li>\\n<li><strong>一个进程可以拥有多个线程</strong>，比如：迅雷/百度云/阿里云/OneDrive/GoogleDrive...等，这些进程在同时下载/上传多个文件时，会开启多条线程，比如：当我使用阿里云同时上传多个文件：这其实就是创建了多个线程来同时进行，以让我的上传效率最大化<br>\\n<img src=\\"/images/Java/JavaSE/16-初识线程/image-20211110231058750.png\\" alt=\\"image-20211110231058750\\" loading=\\"lazy\\"></li>\\n<li>线程可以套娃创建：一个线程中再创建一个线程--之后会了解到</li>\\n</ol>\\n</li>\\n<li>\\n<p>其他相关概念</p>\\n<ol>\\n<li>单线程：同一个时刻，只允许执行一个线程</li>\\n<li>多线程：同一个时刻，可以执行多个线程：比如，一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件</li>\\n</ol>\\n</li>\\n<li>\\n<p>并发</p>\\n<ul>\\n<li>同一时刻，<strong>多个任务交替执行</strong>，造成一种<code>貌似同时</code>的错觉，简单的说，单核CPU                                      实现的多任务就是并发  比方说：有个人再开车时打电话，你可能会认为它正在边开车边打电话，实际上它的大脑再某个瞬间只再做一件事情-要么正在操控方向盘开车，要么正在跟电话另一头的人说话(所以说我国法律规定开车的时候不能打电话，因为它在跟人交流的时候，就有可能忽略了踩刹车)<br>\\n<img src=\\"/images/Java/JavaSE/16-初识线程/image-20211110231923321.png\\" alt=\\"image-20211110231923321\\" loading=\\"lazy\\"></li>\\n</ul>\\n</li>\\n<li>\\n<p>并行</p>\\n<ul>\\n<li>同一时刻，多个任务同时执行，多核CPU可以实现并行 比方说：一个人开车，一个人接电话，互不干扰，都在专心干自己的事情<br>\\n<img src=\\"/images/Java/JavaSE/16-初识线程/image-20211110231939340.png\\" alt=\\"image-20211110231939340\\" loading=\\"lazy\\"></li>\\n</ul>\\n</li>\\n<li>\\n<p>当然程序的世界不可能这么简单，<strong>程序有可能正在并行+并发</strong>，他们两是可以同时存在的，比如说电脑上开了500个QQ和500个原神，但是CPU只有8个，电脑就会让CPU一会儿执行CPU，一会儿执行原神，这种情况下，对于单个CPU的视角来看，他正在并发，对于多个CPU的视角来看，他们正在并行</p>\\n</li>\\n</ul>\\n<p>那么，提出一个简单的问题，如何通过Java来知道我们的电脑中有多少个<strong>可用的</strong>CPU(多少核)呢，只需要编写以下代码即可：</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">package</span> <span class=\\"token namespace\\">com</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">CpuNumber</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">static</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">String</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> args<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token class-name\\">Runtime</span> runtime <span class=\\"token operator\\">=</span> <span class=\\"token class-name\\">Runtime</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getRuntime</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token comment\\">// available 获取 Processors 处理器  available Processors 可用处理器</span>\\n        <span class=\\"token keyword\\">int</span> cpuNumber <span class=\\"token operator\\">=</span> runtime<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">availableProcessors</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token class-name\\">System</span><span class=\\"token punctuation\\">.</span>out<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">println</span><span class=\\"token punctuation\\">(</span>cpuNumber<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>通过这两句话就可以轻松的获取电脑上可用的CPU的个数，当然原理先不谈</p>\\n</li>\\n</ul>","autoDesc":true}');export{n as data};
