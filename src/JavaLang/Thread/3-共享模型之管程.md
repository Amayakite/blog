---
title: 3-共享模型之管程
date: 2022-1-15 20:32:30
category: Thread
tag:
- Java
- JavaSE
- Thread
---

## 共享带来的问题

老王（操作系统）有一个强大的算盘（CPU），现在它想把它租出去，赚一点外快

![老王](/images/JavaThread/3-共享模型之管程/1642250739946.png)

- a，b要使用这个算盘来做一些计算，并按时间给老王支付费用
- 但是a不能一天24h使用算盘，它有时候需要休息一会儿(sleep),又或者要去上厕所(阻塞io操作)，有时候需要点一根烟，没有烟的时候思路全无(wait)，这些情况统称为**阻塞**

![a](/images/JavaThread/3-共享模型之管程/1642250763555.png)

- 在这些时候，算盘没有利用起来（不能收钱了），老王觉得有点不划算
- 另外，b也想用算盘，如果总是让a占着便宜，让b觉得不公平
- 于是，老王灵机一动，想到了一个办法:**让他们每个人用一会儿，轮流使用算盘**
- 这样，当a阻塞的时候，算盘可以分给b使用，不会浪费，反之亦然
- 最近指定的计算比较复杂，需要存储一些中间结果，但是a和b的脑容量（工作内存）不够，所以老王申请了一本笔记本（主存），把一些中间结果存在笔记本里，这样就可以让a和b各自使用一会儿，让算盘利用起来
- 计算流程是这样的
- ![算盘](/images/JavaThread/3-共享模型之管程/1642250996132.png)
- 但是由于分时系统，有一天还是发生了事故
- a钢都区了初始值0做了个+1运算，还没来得及会写结果
- 老王说[a，你的时间到了，该换别人了，记住结果走吧]，于是a念叨着[是1,1,1]然后走了(上下文切换)
- 老王说[b,轮到你了]，b看到笔记本上还写着0，于是做了个-1，写入笔记本
- 这个时候b的时间也用完了，老王又叫来a说[a，你接着把上次的题目写完吧]，a将它脑海中的结果写入了笔记本
- ![共享问题](/images/JavaThread/3-共享模型之管程/1642251215715.png)
- a和b都觉得自己没做错，但是笔记本里的结果是1，而不是0

### Java的体现

两个线程对初始值0的静态变量做一个自增，一个做自减，各做5k次，结果会是0吗？

```java

@Slf4j(topic = "c.MyThread")
public class MyThread {

    static int count = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                count++;
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                count--;
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.info("当前count的值是{}", count);
    }
}
```

上面的最终运行结果是(我这里是这样，根据电脑情况不同应该都不一样)

> 21:01:08.334 [main] INFO c.MyThread - 当前count的值是1371

### 问题分析

以上的结果可能是正数、负数，零,为什么呢？

因为Java中的对变量的自增、自减并不是原子性的操作（之前在学习Redis的时候有提到过），要彻底理解，必须要从字节码来进行分析

例如对于i++而言(i作为静态变量)，会产生如下的jvm字节码指令

```text
get-static   i 获取静态变量i的值
i_const_1   准备常量1
i_add       自增
put_static  i  将修改后的值存入静态变量i
```

对应的i--同理

而Java的内存模型如下，完成静态变量的自增，自减需要在工作内存中进行数据转换

![自增的底层](/images/JavaThread/3-共享模型之管程/1642252280493.png)

如果是单线程以上8行代码是顺序执行（不会交错）没有问题

![i++和i--单线程](/images/JavaThread/3-共享模型之管程/1642252341176.png)

但多线程下这8行代码可能交错运行：

> 出现负数的情况

![多线程-负数](/images/JavaThread/3-共享模型之管程/1642252434725.png)

> 出现正数的情况

![多线程-正数](/images/JavaThread/3-共享模型之管程/1642252496435.png)

### 临界区(Critical Section)

- 一个程序运行多个线程本身是没有任何问题的
- 问题出在多个线程访问**共享资源**
    - 多个线程读共享资源没有问题
    - 多个线程对共享资源的读写操作时发生指令交错，就会出现问题
- 一段代码块内如果存在对**共享资源**的多线程读写操作，这块代码被称为*临界区*

例如，下面的代码中的临界区

```java
class Test {
    static int counter = 0;

    /**
     * 临界区方法
     */
    static void increment() {
        counter++;
    }

    /**
     * 临界区方法
     */
    static void decrement() {
        counter--;
    }
}
```

方法体内的`{...}`这些内容就是临界区

多个线程在临界区内执行，由于代码的**执行序列不同**而导致结果无法预测，称之为发生了**竞选条件**

### 解决方案

在Java内，对于这种事情，有非常多种解决方案，主要分为两类

- 阻塞式的解决方案：`synchronized`、`lock`
- 非阻塞式的解决方案：原子变量

## synchronized

### 基本使用

对象锁，这个我们已经不陌生了，在Java的基础部分用的明明白白，这是一种互斥锁，可以有效的阻塞其他的线程

语法：

```java
class A {
    int count = 0;

    //    语法1：用在方法上 这个方法同时将只有一个人能用
    public synchronized void add() {
        count++;
    }

    //    语法2，用在方法内 用在方法内的话需要传入一个对象，任意的对象都行
    public void sub() {
        synchronized (this) {
            count--;
        }
    }

}
```

我们如果需要使用它来解决我们之前的问题的话只需要

```java

@Slf4j(topic = "c.MyThread")
public class MyThread {

    static int count = 0;
    final static Object obj = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            synchronized (obj) {
                for (int i = 0; i < 5000; i++) {
                    count++;
                }
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            synchronized (obj) {
                for (int i = 0; i < 5000; i++) {
                    count--;
                }
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.info("当前count的值是{}", count);
    }
}
```

执行结果： 21:34:36.219 [main] INFO c.MyThread - 当前count的值是0

当然，也可以选择使用synchronized方法来完成

```java

@Slf4j(topic = "c.MyThread")
public class MyThread {

    static int count = 0;
    static Object obj = new Object();

    public synchronized static void countFunction(boolean isAdd) {
        if (isAdd) {
            count++;
        } else {
            count--;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                countFunction(true);
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                countFunction(false);
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.info("当前count的值是{}", count);
    }
}
```

最终的效果都是一样的

### synchronized的理解

![synchronized](/images/JavaThread/3-共享模型之管程/1642254005598.png)

### synchronized用在代码块内和方法上的区别

谨记两点：

- 用在代码块内，需要自己标注锁哪个对象，一般这种情况下锁的对象都是全局唯一的`static final xxx=xxx`
- 用在方法体上，这种情况下锁住的对象是这个类本身，例如类`Person`内的用`synchronizd`标注的方法，锁的是Person这个类在**实例化**后的对象
    - 例如`Person p1 = new Person`，则锁的是`p1`这个对象

## 变量的安全分析

### 成员变量和静态变量是否线程安全

- 如果他们没有共享，则线程安全
- 如果他们被共享了，则根据他们的状态能否改变，又被分为两种情况
    - 如果只有读操作，则线程安全
    - 如果有读写操作，则这段代码是临界区，需要考虑线程安全

### 局部变量是否线程安全

- 局部对象是线程安全的
- 但是局部的**引用对象**未必
    - 如果该对象没有逃离方法的作用范围，它是线程安全的
    - 如果该对象逃离出方法的作用范围，需要考虑线程安全

也就是说

```java
public class Person {
    public void test1() {
        int i = 10;
        //这样始终是线程安全的，因为i在外部无法访问
        System.out.println(++i);
    }
}
```

### 常见的线程安全类

- String
- Integer
- StringBuffer
- Random
- Vector
- Hashtable
- `java.util.concurrent`包下的类(记住这个包,简写JUC)

这里说他们的线程安全是指：多个线程调用他们同一个实例的某个方法时，是线程安全的，也可以理解为

- 他们的每个方法都具有原子性
- 但要注意：他们**多个方法**的组合不是原子性的

例如下面这些代码

```java
import java.util.Hashtable;

class A {
    static <String, String>hashtable =new Hashtable<>();

    public static void main(String[] args) {
        if (hashtable.get("key") == null) {
            hashtable.put("key", value)
        }
    }
}
```

上面这里实际上是不安全的，因为实际上他们是有两步：

1. 判断一个值是否存在
2. 存入值

这个时候如果说有多个线程同时对一个值进行操作的话

![线程安全](/images/JavaThread/3-共享模型之管程/1642256672659.png)

依旧会造成数据错乱，引发临界区，解决方法很简单，**在这一段操作之前上个锁，让get和put一块变成原子性的**

### 不可变类的线程安全性

String/Integer等都是不可变类，因为其内部状态不可以被改变，因此他们的方法都是线程安全的

可能你会问，string的subString、replace之类的方法不是改变了内容吗...

还记得之前在学习常用类的时候吗，String内部是维护了一个char数组，如果有变动，char数组是不会变的，例如replace，它会将这个数组复制一份，然后进行对应的修改，然后包装成一个新的String对象返回给你，所以说它的变动占用的开销挺大的

## Monitor

### Java对象头

这里涉及到JVM的知识，以后在了解，先看看即可，以32位JVM虚拟机为例

我们在Java中写的对象通常有两部分组成

1. 它的对象头
    1. 下方例子图片中，一个基本的普通对象的对象头是64bit，也就是8个字节
    2. 其中四个字节叫做MarkWorld 另外四个字节叫做Klass Word
    3. Klass Word指向了这个对象的指针，从而让JVM知道当前对象是属于哪个ClassLoader，简单来说就是通过这个找到它的类对象
2. 对象中的成员变量
3. 如果说是数组对象，还有4个字节来表示它的长度

![a](/images/JavaThread/3-共享模型之管程/1642258641096.png)

Mark Word包含了如下内容

- 其中25位是一个hashcode，然后还有一个age是4位，表示垃圾回收时它的分类年龄（这个age超过一定值的时候就会从新生区进入到老年代）
- biased_lock表示它是不是一个偏量锁，然后最后`|`后面的1和0表示它的加锁状态，01表示没有锁
- 剩下的都是其他状态下的信息（State是状态，默认是normal状态）
- 如果说我们之后加了偏向锁之类的，它的状态和值也将会随之改变

![b](/images/JavaThread/3-共享模型之管程/1642258658516.png)

总所周知，一个int对象占了4个字节，但是一个Integer却用了8+4=12个字节，所以某些最求极致性能的情况下，往往不用包装类比较好

### Monitor的概念

这玩意被翻译成监视器，或者你可以称它为管程，或者说，他就是锁

每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针

Monitor结构如下

![monitor](/images/JavaThread/3-共享模型之管程/1642262589004.png)

Monitor是操作系统中的对象，我们在Java中是看不到它的展示的

当我们给一个对象上锁了之后，是这样一个流程

![monitor](/images/JavaThread/3-共享模型之管程/1642262929300.png)

这个obj中的mark word将会指向操作Monitor中的一个对象，并且如果准确无误的话，这个线程将会成为这把锁的主人，同时它的mark word将会变成如下图所示 前30位变成一个指针，指向Monitor的地址

![最终指向](/images/JavaThread/3-共享模型之管程/1642262846464.png)

如果说此时又有线程来调用了这个锁，那么他将会先看看，这个obj的mark word是否是指向一个Monitor

如果是的话，就去检查这个Monitor对象有没有主人，如果此时有的话，则加入到Monitor的Entry Set(等待队列)中，进入阻塞(Blocked)状态中

![new synchronized](/images/JavaThread/3-共享模型之管程/1642263103183.png)

这个时候如果还有别的线程加入，也是同上一样，进入到Entry Set阻塞队列内进行排队等待

![其他的线程](/images/JavaThread/3-共享模型之管程/1642263251348.png)

那什么时候其他线程能够获取这个锁呢？

答案就是当我们的Thread-2执行完synchronized这个方法内的内容的时候，他将会自动解除自己和Monitor对象的Owner(主人)的依赖关系

这个时候Monitor的这个对象内的主人位置就空出来了，它将会通知等待队列的线程，将他们唤醒，然后让他们抢夺锁，竞争是非公平的，假设Thread-1最终胜出

这个时候，Thread-1就会成为这个Monitor对象的新一任主人

![当一个线程结束了](/images/JavaThread/3-共享模型之管程/1642263486600.png)

到这里，也就能非常明了的知道，Monitor就是充当锁一样的角色，他就是一把锁

![流程](/images/JavaThread/3-共享模型之管程/1642263613695.png)

注意：

- synchronized必须是进入同一个对象的monitor才有上述效果
- 不加synchronized的对象不会关联监视器，不遵循以上规则

### 原理之synchronized

我们先来准备一点代码

```java
public class MyThread {
    static final Object lock = new Object();
    static int count = 0;

    public static void main(String[] args) {
        synchronized (lock) {
            count++;
        }
    }
}
```

对应的字节码为：

![synchronized](/images/JavaThread/3-共享模型之管程/1642264418106.png)

## Synchronized优化

### 由一个小故事引出

- 老王：操作系统
- 小南-线程
- 小女-线程
- 房间-对象
- 房门上-防盗锁-Monitor
- 房门上-小南书包-轻量级锁
- 房门上-刻上小南大名-偏向锁
- 批量重刻名：一个类的偏向锁撤销到达20阀值
- 不能刻名字：批量撤销对该类对象的偏向锁，设置该类不可偏向

![故事](/images/JavaThread/3-共享模型之管程/1642264742659.png)

### 轻量级锁

轻量级锁的使用场景：如果一个对象虽然有多个线程来访问，但是多个现成来访问的时间是错开的（也就是没有竞争），那么可以用轻量级锁来优化

轻量级锁对使用者来说是透明的，也就是说语法没有任何变化，依旧是synchronized

假设有两个方法同步块，利用同一个对象加锁

```java
public class A {
    static final Object obj = new Object();

    public static void method1() {
        synchronized (obj) {
//            同步块A
            System.out.println("做了相关的事情，接下来调用方法B");
            method2();
        }
    }

    public static void method2() {
        synchronized (obj) {
            System.out.println("方法2开始执行");
        }
    }
}
```

- 上述代码在执行的过程中，首先是method1会创建锁记录(Lock Record)对象，每个线程的栈帧都会包含一个索记录的结构，内部可以存储锁定对象的Mark Word
    - 注意 这个锁我们在Java层面是见不到的，它属于系统级别

![锁](/images/JavaThread/3-共享模型之管程/1642265576228.png)

- 接着，让锁记录中的Object reference指向锁对象，并尝试用cas替换Object的Mark Word 将Mark Word的值存入锁记录

![锁2](/images/JavaThread/3-共享模型之管程/1642265715684.png)

- 如果Cas替换成功，对象头中存储了锁记录和状态 00 ，表示由该线程给对象加锁，此时图示如下

![加锁成功](/images/JavaThread/3-共享模型之管程/1642265829363.png)

![轻量锁](/images/JavaThread/3-共享模型之管程/1642265814970.png)

那刚刚这个时候会成功，什么时候会失败呢？当然是有其他线程把最后两位替换成00了，锁地址已经指向了其他的线程，这个操作自然就失败了

![er](/images/JavaThread/3-共享模型之管程/1642266050032.png)

当退出synchronized代码块(解锁时)，如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数-1

![-1](/images/JavaThread/3-共享模型之管程/1642266136449.png)

- 当退出synchronized代码块(解锁时)锁的记录如果不为null，这时使用cas将Mark Word的值恢复给对象头
    - 成功：则解锁成功
    - 失败：说明轻量级锁进行了锁膨胀已经升级为重量级锁(门上刻字)，此时进入重量级锁的解锁流程

### 锁膨胀

如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他的线程为此对象加上了轻量级锁（有竞争），此时需要锁膨胀，将轻量级锁变为重量级锁

```java
public class A {
    final static Object obj = new Object();

    public static void method1() {
        synchronized (obj) {
            System.out.println("线程1获取到了锁");
        }
    }
}
```

- 当Thread-1进行轻量级加锁的时候，Thread-0已经对该对象加了轻量级锁

![两个轻量级锁](/images/JavaThread/3-共享模型之管程/1642266554767.png)

- 此时Thread-1加轻量级锁失败，进入膨胀锁流程
    - 即为Object对象申请Monitor锁，让Object指向重量级锁地址
    - 然后自己进入Monitor的Entry List，进入阻塞状态

![重量级锁](/images/JavaThread/3-共享模型之管程/1642266735253.png)

![重量级锁地址参考](/images/JavaThread/3-共享模型之管程/1642266722639.png)

此时，当Thread-0退出同步块解锁的时候，使用cas将Mark Word的值恢复给对象头，失败，这时进入重量级解锁流程，即：按照Monitor地址找到Monitor对象
，设置Owner为null，唤醒EntryList中的Blocked线程，也就是Thread-1

### 自旋优化

重量级锁竞争的时候，还可以使用自旋(自循环)来进行优化，如果当前线程自旋成功(即这时候持锁线程已经退出了同步块，释放了锁)，这时当前线程就可以避免阻塞
(上下文切换的发生)

自旋成功的情况：也就是当一个线程想要进入Monitor锁内的时候，并不会立刻进入阻塞状态，而是先自旋几次看看能不能拿到锁，拿到了就是直接用锁

![自旋](/images/JavaThread/3-共享模型之管程/1642267118338.png)

> 如果上一步中的线程最终并没有获取到锁，那么就会自旋失败，接着就是按照正常的Monitor流程进入到EntryList等待队列中阻塞

![自旋失败-阻塞](/images/JavaThread/3-共享模型之管程/1642267235033.png)

- 在Java6之后，自旋锁是自适应的，比如对象刚刚的一次自旋成功操作过后，那么(JVM)认为这次自旋成功的可能性会高，就多自旋几次，反之亦然，总之比较智能
- 自旋会占用CPU时间，单核CPU自旋就是浪费性能，多核CPU自旋才能发挥优势
- Java7之后不能控制是否开启自旋功能，也就是说这个功能目前是完全自动的

### 偏向锁

轻量级锁在没有竞争时(就自己这个线程)，每次重入仍需要执行CAS操作

Java6中就引入了偏向锁来做进一步的优化，只有在第一次使用CAS将线程ID设置到对象的Mark Word头， 之后发现这个线程ID是自己的就表示没有竞争，不用从新CAS，以后只要不发生竞争，这个对象就归该对象所有

例如：

```java
public class A {
    static final Object obj = new Object();

    public static void m1() {
        synchronized (obj) {
//            同步块m1
            m2();
        }
    }

    public static void m2() {
        synchronized (obj) {
//            同步块m2
            m3();
        }
    }

    public static void m3() {
        synchronized (obj) {
//            同步块m3
            System.out.println("这里是同步块m3的内容");
        }
    }

}
```

上方执行后，是这样一个流程

![轻量级锁](/images/JavaThread/3-共享模型之管程/1642308139626.png)

![偏向锁](/images/JavaThread/3-共享模型之管程/1642308154612.png)

总结就是，如果说是同一个线程之内，调用锁的话，会检查锁是不是自己的，如果是，那就直接用，偏向锁就是只有第一次加锁的时候， 会使用Thread-ID替换Mark Word

### 偏向状态

先来看看对象头格式

![对象头的几种状态](/images/JavaThread/3-共享模型之管程/1642308454825.png)

一个对象创建的时候

- 如果开启了偏向锁(默认是开启状态)，那么对象创建后，mark word值为0x05，即最后三位是101，这时它的Thread、Epoch、Age都为0
- 偏向锁是默认延迟的，不会在程序启动时立刻生效，如果想避免延迟，可以加JVM参数：`-XX:BiasedLockingStartupDelay=0`来禁用延迟
- 如果没有开启偏向锁，那么对象创建后，mark word值为0x01，也就是最后三位是101，这时它的hashcode，age都为0，第一次用到hashcode时才会赋值

我们想查看偏向锁的状态得借助第三方的Jar包

```xml

<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.16</version>
</dependency>
```

这玩意的原理不是重点，只要知道咋用即可，我们使用非常简单

```java

@Slf4j(topic = "c.MyThread")
public class MyThread {

    public static void main(String[] args) {
        Dog dog = new Dog();
        String s = ClassLayout.parseInstance(dog).toPrintable();
        log.info("{}", s);
    }
}

class Dog {

}
```

运行结果：

```text
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000001 (non-bias-able; age: 0)
  8   4        (object header: class)    0xf800ef95
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

可以看到，mark word最后是`0x0000000000000001`,也就是没有开启偏向锁的，但是按道理来讲，它的最后三位应该是101,而不是001

这是因为偏向锁的延迟特点，所以我们在启动的时候额外加下jvm的参数吧

所以只需要

```java

@Slf4j(topic = "c.MyThread")
public class MyThread {

    public static void main(String[] args) {
        Dog dog = new Dog();
        String s = ClassLayout.parseInstance(dog).toPrintable();
        log.info("{}", s);
        // 延迟创建
        TimeUnit.SECONDS.sleep(10);
        String s1 = ClassLayout.parseInstance(new Dog()).toPrintable();
        log.info("{}", s1);
    }
}

class Dog {

}
```

结果：

```text

13:03:12.169 [main] INFO c.MyThread - com.Project.thread.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000001 (non-bias-able; age: 0)

13:03:22.180 [main] INFO c.MyThread - com.Project.thread.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000005 (bias-able; age: 0)
```

可以看到，延迟后就变了，最后的结果是5，根据进制转换，5转换成二进制就是101

![进制](/images/JavaThread/3-共享模型之管程/1642309551672.png)

当然 你坑定会想问了，这时候我不想要它延迟，想要直接测试该怎么办

非常简单，添加个JVM参数即可

![JVM参数](/images/JavaThread/3-共享模型之管程/1642309820122.png)

最终启动的时候，可以看到，第一个和第二个都是101

![后续测试](/images/JavaThread/3-共享模型之管程/1642309856953.png)

> 当然，如果存在程序内的线程竞争关系非常激烈，那么用偏向锁就不太合适了，这个时候可以选择禁用偏向锁
>
> 只需要加一个JVM参数即可`-XX:-UseBiasedLocking` 这样即可禁用偏向锁
>
> 这个UseBiasedLocking前面如果是减号`-`表示禁用偏向锁
>
> 如果是`+`号，则表示开启偏向锁（默认就是开启的）

加锁顺序：`偏向锁-->轻量级锁-->重量级锁`

但是，当一个可偏向的对象，调用了其hashcode方法之后，它将会禁用掉偏向锁

![偏向锁](/images/JavaThread/3-共享模型之管程/1642311050077.png)

原因非常简单

![偏向锁2](/images/JavaThread/3-共享模型之管程/1642311070843.png)

在偏向锁内，并没有字段可以存储hashcode，而hashcode，只有我们在调用这个方法的时候才会生成

### 撤销-调用对象的HashCode

调用了对象的HashCode，但偏向锁的对象MarkWord中存储的是线程ID，如果调用hashCode会导致偏向锁被撤销

- 轻量锁会在锁记录中记录Hashcode，所以将不会被撤销
- 重量锁会在Monitor中记录Hashcode，所以不会被撤销

在调用Hashcode后使用偏向锁，记得去掉jvm参数`-XX:-UseBiasedLocking`

![调用hashcode](/images/JavaThread/3-共享模型之管程/1642311402111.png)

### 撤销-其他线程使用对象

当有其他线程使用锁对象的时候，会将偏向锁升级为轻量级锁

### 调用wait-notify

调用这个的时候，也会取消偏向锁，同时将会升级到重量级锁，因为这玩意只有重量级锁才有

### 批量重偏向

如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象中任然有机会重偏向于T2，重偏向会重置对象的ThreadID

当撤销偏向锁阀值达到20次了之后，JVM会这样觉得：_我是不是偏向错了呢？于是会给这些对象加锁时重新偏向至加锁线程_

```java

@Slf4j(topic = "c.MyThread")
public class MyThread {

    public static void main(String[] args) {
        Vector<Dog> list = new Vector<>();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 20; i++) {
                Dog o = new Dog();
                list.add(o);
                synchronized (o) {
                    log.debug(i + "\t" + ClassLayout.parseInstance(o).toPrintable());
                }
            }
            synchronized (list) {
                list.notify();
            }
        }, "t1");
        t1.start();
        Thread t2 = new Thread(() -> {
            synchronized (list) {
                try {
                    list.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            for (int i = 0; i < 20; i++) {
                Dog o = new Dog();
                list.add(o);
                synchronized (o) {
                    log.debug(i + "\t" + ClassLayout.parseInstance(o).toPrintable());
                }
            }

        }, "t2");
        t2.start();
    }
}

class Dog {

}

```

### 批量撤销

当撤销偏量阀值超过40之后，JVM会认为，自己却是弄错方向了，根本就不应该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的

## Wait和Notify

### 为什么需要wait

- 由于条件不满足，小男就不能继续进行计算
- 但如果小南一直占用这锁，其他人就得阻塞，效率太低
- ![小南](/images/JavaThread/3-共享模型之管程/1642314764712.png)
- 于是老王单开了一个休息室(调用wait方法)，让小南到休息室(WaitSet)等着去了，这时锁释放开，其他人可以由老王随机安排进屋
- 直到小M将烟送来了，大叫一声：【你的烟到了】(调用notify方法)
- ![烟](/images/JavaThread/3-共享模型之管程/1642314863682.png)
- 小南此时可以离开休息室，重新进入竞争锁队列
- ![小南2](/images/JavaThread/3-共享模型之管程/1642314931554.png)

### 原理之wait和notify

![wait和notify](/images/JavaThread/3-共享模型之管程/1642315003952.png)

- Owner线程发现条件不满足，于是进入wait方法，即可进入`WaitSet`变为`WATTING`状态
- BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU的时间片
- BOCKED线程会在Owner线程释放锁时唤醒
- WAITING线程会在Owner线程调用`notify`或者`notifyAll`时唤醒，但唤醒之后并不意味着立刻获取到锁，仍需进入`EntryList`重新竞争
- WaitSet也是一个集合，和EntrySet功能基本一致

### API介绍

- `obj.wait()`让进入object监视器的线程到`waitSet`等待
- `obj.notify()`让object上正在`waitSet`等待中的线程随机挑选**一个**唤醒
- `obj.notifyAll()`让object上正在`waitSet`的线程全部唤醒

他们都是线程进行协作的手段，都属于Object对象的方法，**必须得获取这个对象的锁(成为这把锁的主人)**，才能获取这几个方法

也就是说，必须得先通过`synchroized`获取到对象的锁之后，才可以进行wait/notify操作

使用起来非常简单，只需要

```java

@Slf4j(topic = "c.WaitAndNotify")
public class WaitAndNotify {
    final static Object obj = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行");
                try {
//                让线程在obj上一直等待下去
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其他代码");
            }
        }, "t1").start();
        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行");
                try {
//                让线程在obj上一直等待下去
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其他代码");
            }
        }, "t2").start();

        TimeUnit.SECONDS.sleep(3);
        log.debug("唤醒obj上的其他线程");
//        主线程获取obj的锁对象
        synchronized (obj) {
//            唤醒obj上的一个随机一个线程
//            obj.notify();
//            唤醒obj上的所有线程
            obj.notifyAll();
        }
    }
}
```

运行结果：

```text

14:55:00.952 [t1] DEBUG c.WaitAndNotify - 执行
14:55:00.955 [t2] DEBUG c.WaitAndNotify - 执行
14:55:03.952 [main] DEBUG c.WaitAndNotify - 唤醒obj上的其他线程
14:55:03.952 [t2] DEBUG c.WaitAndNotify - 其他代码
14:55:03.953 [t1] DEBUG c.WaitAndNotify - 其他代码
```

### wait指定时间

也就是让自己等待多长时间，我们平常调用`wait()`相当于是调用了`wait(0)`

- 0表示只要没有人唤醒(notify)，这个线程就一直WAITING下去
- 我们也可以指定毫秒数，例如`wait(1000)`来表示这个线程最多能等待多少毫秒

例如：

```java

@Slf4j(topic = "c.WaitAndNotify")
public class WaitAndNotify {
    final static Object obj = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行");
                try {
//                让线程在obj上等待1秒
                    obj.wait(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其他代码");
            }
        }, "t1").start();
        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行");
                try {
//                让线程在obj上一直等待下去
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其他代码");
            }
        }, "t2").start();

        TimeUnit.SECONDS.sleep(3);
        log.debug("唤醒obj上的其他线程");
//        主线程获取obj的锁对象
        synchronized (obj) {
//            唤醒obj上的一个随机一个线程
//            obj.notify();
//            唤醒obj上的所有线程
            obj.notifyAll();
        }
    }
}
```

结果：

```text
14:59:57.965 [t1] DEBUG c.WaitAndNotify - 执行
14:59:57.967 [t2] DEBUG c.WaitAndNotify - 执行
14:59:58.971 [t1] DEBUG c.WaitAndNotify - 其他代码
15:00:00.966 [main] DEBUG c.WaitAndNotify - 唤醒obj上的其他线程
15:00:00.966 [t2] DEBUG c.WaitAndNotify - 其他代码
```

## Wait Notify的正确使用姿势

### sleep(long n)和wait(long n)的区别

- Sleep是Thread的方法，而wait是Object的方法
- sleep不需要强制和synchronized配合使用，但是wait一定要配合`synchronized`一起用
- sleep在睡眠的同时，**不会释放锁对象**，但是wait在等待的时候，**会释放对象锁**
- 他们都是进入了`TIMED_WAITING`(系统层面上)这个状态

### 如何正确的使用wait

谨记一点：**使用wait的时候，如果遇上了变量之类的判断，需要给对应的变量判断加个while**

```java {26-29,39-42}
package com.Project.thread;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;

@Slf4j(topic = "c.WaitAndNotify")
public class WaitAndNotify {
    final static Object obj = new Object();

    /**
     * 烟是否送到了
     */
    static boolean isSomeOne = false;


    /**
     * 外卖是否送到了
     */
    static boolean isWaiMai = false;

    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            synchronized (obj) {
                try {
                    while (!isSomeOne) {
                        log.info("烟没送到，等待中");
                        obj.wait();
                    }
                    log.info("烟已送到，烟台准备开始烟");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        Thread thread2 = new Thread(() -> {
            synchronized (obj) {
                try {
                    while (!isWaiMai) {
                        log.info("外卖没送到，等待中");
                        obj.wait();
                    }
                    log.info("外卖已送到，外卖准备开始外卖");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        thread1.start();
        thread2.start();
        TimeUnit.SECONDS.sleep(1);
        synchronized (obj) {
            isSomeOne = true;
            obj.notifyAll();
        }
        TimeUnit.SECONDS.sleep(2);
        synchronized (obj) {
            isWaiMai = true;
            obj.notifyAll();
        }
    }

}
```

运行结果：

```text
15:29:58.732 [Thread-0] INFO c.WaitAndNotify - 烟没送到，等待中
15:29:58.734 [Thread-1] INFO c.WaitAndNotify - 外卖没送到，等待中
15:29:59.739 [Thread-1] INFO c.WaitAndNotify - 外卖没送到，等待中
15:29:59.739 [Thread-0] INFO c.WaitAndNotify - 烟已送到，烟台准备开始烟
15:30:01.754 [Thread-1] INFO c.WaitAndNotify - 外卖已送到，外卖准备开始外卖
```

### 设计模式之保护性暂停

英文名Guarded Suspension，**在用一个线程等待另一个线程的执行结果**

要点：

1. 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个GuardedObject
2. 如果有结果不断从一个线程到另一个线程，那么可以使用消息队列(生产消费者-RabbitMQ之类的)
3. JDK中，Join的实现，Future的实现，才用的就是此模式
4. 因为需要等待另一方的结果，因此归类到同步模式

![guarded](/images/JavaThread/3-共享模型之管程/1642318697632.png)

实现非常简单，有固定的套路

> GuardedObject

```java
class GuardedObject {

    /**
     * 结果
     */
    private Object response;

    /**
     * 获取结果
     *
     * @return Object
     */
    public Object get() {
        synchronized (this) {
            while (response == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }

    /**
     * 产生结果
     */
    public void complete(Object obj) {
        synchronized (this) {
//          给结果成员变量赋值
            this.response = obj;
            this.notifyAll();
        }
    }


}
```

使用非常简单，例如我们现在有两个线程，线程1要等待线程2的下载结果，这里用请求百度来简单模拟下

```java

@Slf4j(topic = "c.TestGuarded")
public class TestGuarded {

    public static void main(String[] args) {

        GuardedObject guardedObject = new GuardedObject();
//        等待结果
        new Thread(() -> {
            log.debug("线程{}正在等待结果", Thread.currentThread().getName());
            Object o = guardedObject.get();
            log.info("线程{}获取到结果{}", Thread.currentThread().getName(), o);
        }, "t1").start();

        new Thread(() -> {
            try {
                ArrayList<String> strings = downloadBaidu();
                log.info("线程{}获取到结果了，正在准备传递给另外的线程", Thread.currentThread().getName());
                guardedObject.complete(strings);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }, "t2").start();

    }

    public static ArrayList<String> downloadBaidu() throws IOException {
        HttpURLConnection urlConnection = (HttpURLConnection) new URL("https://www.baidu.com").openConnection();
        ArrayList<String> strings = new ArrayList<>();
        BufferedReader bufferedInputStream = new BufferedReader(new InputStreamReader(urlConnection.getInputStream(), StandardCharsets.UTF_8));
        String line;
        while ((line = bufferedInputStream.readLine()) != null) {
            strings.add(line);
        }
        return strings;
    }

}
```

运行结果：

![结果](/images/JavaThread/3-共享模型之管程/1642319757511.png)

当然，你也可以自己加一个超时参数来决定等待时间,下面的逻辑还是比较复杂的 可以自行看看

```java
class GuardedObject {

    /**
     * 结果
     */
    private Object response;

    /**
     * 获取结果
     *
     * @return Object
     */
    public Object get() {
        synchronized (this) {
            while (response == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }

    public Object get(long time) {
        synchronized (this) {
//            记录开始时间
            long start = System.currentTimeMillis();
//            经历的时间
            long passedTime = 0;
            while (response == null) {
//                经历的时间超过了time，就退出
                if (passedTime >= time) {
                    System.out.println("不等了");
                    break;
                }
                try {
//                    防止虚假唤醒后又要继续等待time秒，
                    wait(time - passedTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
//                求得经历时间
                passedTime = System.currentTimeMillis() - start;


            }
            return response;
        }
    }


    /**
     * 产生结果
     */
    public void complete(Object obj) {
        synchronized (this) {
//          给结果成员变量赋值
            this.response = obj;
            this.notifyAll();
        }
    }


}
```

## Park和Un park

### 基本使用

和我们之前的wait和notify非常相似，是由java.util.concurrent.locks.Lock提供的,作用是阻塞当前线程或者恢复当前线程

- `LockSupport.park()` 将当前线程阻塞，直到被唤醒
- `LockSupoort.unpark(被阻塞的线程对象)`恢复某个被阻塞的线程

使用比较简单

```java

@Slf4j
public class ParkAndUnPark {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            log.debug("start...");
            try {
                sleep(1000);
                log.debug("park...");
                LockSupport.park();
                log.debug("resume...");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1");
        t1.start();

        sleep(2000);
        log.debug("unpark...");
        LockSupport.unpark(t1);
    }
}
```

结果：

```text
17:57:05.482 [t1] DEBUG com.Project.thread.ParkAndUnPark - start...
17:57:06.495 [t1] DEBUG com.Project.thread.ParkAndUnPark - park...
17:57:07.482 [main] DEBUG com.Project.thread.ParkAndUnPark - unpark...
17:57:07.482 [t1] DEBUG com.Project.thread.ParkAndUnPark - resume...
```

看起来是不是和wait notify差不多，但是实际上如果我们把两个时间变一下，在延迟结束之前，就使用`unpark`解锁试试

![unpark](/images/JavaThread/3-共享模型之管程/1642327251726.png)

结果是：成功解锁，接下来的代码畅通无阻

![over](/images/JavaThread/3-共享模型之管程/1642327276001.png)

结论：**park的解锁，可以在它之前调用，也可以在它之后调用，效果都是一样的，都会造成解除等待**

### Park的特点

和Object的wait和notify相比

- wait，notify和notifyAll必须配合Object Monitor一起使用，但是park不需要
- park和unpark是以线程为单位来进行阻塞和唤醒线程，而notify只能随机唤醒一个等待线程，notifyAll可以换新所有等待的线程，结果就不那么精确
- park和unpark使用的时候，可以先unpark，而wait和notify使用的时候，不能先notify

### park和unpark的原理

每个线程都有自己的一个Parker对象，由三部分组成：_counter、_cond、和_mutest，打个比喻

- 线程就像是一个旅人，Parker就像它随身携带的背包，条件变量就好比背包中的帐篷
    - _counter就好比背包中的备用干粮（0为耗尽，1为充足）
- 调用Park就是看需不需要停下来休息
    - 如果备用干粮耗尽，就进帐篷休息
    - 反之继续前进
- 调用unpark，就好比让干粮充足
    - 如果这个时候旅人还在帐篷，就让他继续前进
    - 如果这个时候旅人还在行走，那么它下次调用park时，就是消耗掉存储的干粮，不需要停留就可以继续前进
        - 因为背包中空间有限，多次调用unpark，也只会补充一份备用干粮（上限为1）

如果你还是不明白的话：

- 当你没有调用unpark的时候：旅行者，前面的蛆，以后再来探索吧
- 当你调用unpark的时候：用胶布粘住了派蒙的嘴巴，它将在你下次停下来的时候撕掉
- 可以提前封住她的嘴巴

![park1](/images/JavaThread/3-共享模型之管程/1642328218880.png)

![park2](/images/JavaThread/3-共享模型之管程/1642328237311.png)

## 重新理解线程的状态转换

![线程的状态](/images/JavaThread/3-共享模型之管程/1642330625727.png)

众所众知，在Java中我们的线程有六种状态

接下来说说他们之间的状态是如何转换的

> 情况1：NEW==>RUNNABLE

当调用线程的start方法的时候，状态将会从NEW转变为RUNNABLE

> RUNNABLE<==>WAITING

t线程用了`synchronized`获取了对象锁之后

- 调用`obj.wait()`方法时，t线程从`RUNNABLE-->WAITING`
- 调用`obj.notify()`、`obj.notifyAll()`、`t.interrput()`时
    - 竞争锁成功：t线程从WAITING转换为RUNNABLE
    - 竞争锁失败时：t线程从WAITING转变为BLOCKED

> RUNNABLE<==>WAITING

- 当前线程调用t.join方法，当前线程从`RUNNABLE--->WAITING`
    - 注意是**当前线程**在**t线程对象**上的监视器等待
- **t线程**运行结束时，或调用了**当前线程**的`interrupt()`时，当前线程从`WAITING--->RUNNABLE`

> RUNNABLE<==>WAITING

- 当前线程调用`LockSupport.park()`方法，将会进入该状态
- 调用`LockSupport.unpark(目标线程)`或调用了当前线程的`interrput()`，会让线程从`WAITING--->RUNNABLE`

> RUNNABLE<===>TIME_WAITING

t线程调用了`synchronized(obj)`并获取了锁对象后

- 调用`obj.wait(long n)`方法时，t线程从`RUNNBALE--->TIME_WAITING`
- t线程等待时间超过了n毫秒，或调用`obj.notify`、`obj.notifyAll()`、`t.interrput()`时
    - 竞争锁成功：返回RUNNABLE
    - 竞争锁失败：进入到BLOCKED

> RUNNABLE<===>TIME_WAITING

- 当前线程调用`t.join(long n)`方法时，当前线程会进入TIME_WAITING
    - 注意：是当前线程在t线程对象的监视器上等待
- 当前线程等待超过了n毫秒，或t线程运行结束，或调用了当前线程的`interrput()`时，当前线程将会返回RUNNABLE状态

> RUNNABLE<===>TIME_WAITING

- 当前线程调用了`Thread.sleep(long n)`时，将会进入到TIME_WAITING
- 当前线程等待超过了n毫秒，或者使用`inputter()`打断后，将会返回RUNNABLE状态

> RUNNABLE<===>BLOCKED

- t线程调用`synchronized(obj)`获取对象锁时如果竞争失败，将会进入到BLOCKED
- 持有obj对象的线程运行完毕，会唤醒该对象上的所有处于BLOCKED的线程进行重新竞争，此时如果t线程获取到了锁，将会重新进入到RUNNABLE状态，否则继续进入BLOCKED状态

> RUNNABLE===>TERMINATED

当前线程所有代码运行完毕，进入TERMINATED

## 多把锁

### 多把不相干的锁

现在有一间大屋子，有两个功能：睡觉，学习，互不相干

现在小南要学习，小女要睡觉，但如果只用一间屋子(一个对象锁)的话，那么并发度很低

解决方案是准备多个房间(多个对象锁)

例如：

```java
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;

@Slf4j
public class BigRoom {
    public void sleep() {
        synchronized (this) {
            log.debug("sleep 两个小时");
            TimeUnit.HOURS.sleep(2);
        }
    }

    public void study() {
        synchronized (this) {
            log.debug("study 1个小时");
            TimeUnit.HOURS.sleep(1);
        }
    }

}
```

相信你一眼就能看出来上述代码中的问题， 假设a在学习的时候b想睡觉，在同一个房间内是行不通的， 所以把锁丢在同一个大的对象上是不合适的

所以我们可以把这个大屋子分成两个小房间来解决这个问题

```java
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;

@Slf4j
public class BigRoom {
    private final Object studyRoom = new Object();
    private final Object sleepRoom = new Object();

    public void sleep() {
        synchronized (sleepRoom) {
            log.debug("sleep 两个小时");
            TimeUnit.HOURS.sleep(2);
        }
    }

    public void study() {
        synchronized (studyRoom) {
            log.debug("study 1个小时");
            TimeUnit.HOURS.sleep(1);
        }
    }

    /**
     * 这样的话两方都能获取到自己的锁
     */
    public static void main(String[] args) {
        BigRoom bigRoom = new BigRoom();
        new Thread(bigRoom::sleep, "Thread1").start();
        new Thread(bigRoom::study, "Thread2").start();
    }
}
```

- 好处：可以增加并发强度
- 坏处：如果一个线程需要同时获取多把锁，就容易发生死锁

### 如何有效地查找死锁

死锁如何产生的这就不多说了，现在来说说该如何发现程序中的死锁

1. 使用`jstack`

```bash
jstack 进程编号
```

![死锁](/images/JavaThread/3-共享模型之管程/1642333253102.png)

它会罗列出当前进程是否有死锁，如果有的话，会出现图上所示的标签

2. 使用`jconsole`

```bash
jconsole
```

然后选择你的线程，进入到线程页面，就有一个检测死锁的按钮

![检测死锁](/images/JavaThread/3-共享模型之管程/1642333385784.png)

如果检测到了，就会出现如下所示的内容

![检测到了死锁](/images/JavaThread/3-共享模型之管程/1642333410535.png)

### 死锁问题-哲学家就餐

![哲学家就餐](/images/JavaThread/3-共享模型之管程/1642334061689.png)

我们先来一个筷子类

```java
/**
 * 筷子类
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
class Chopstick {
    private String name;
}
```

然后再来一个哲学家类

```java

@EqualsAndHashCode(callSuper = true)
@Data
@Slf4j(topic = "c.Philosopher")
public class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;

    /**
     * @param name  线程的名字
     * @param left  左手边的筷子
     * @param right 右手边的筷子
     */
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }

    @Override
    public void run() {
        while (true) {
//        尝试获取左手边的筷子
            synchronized (left) {
//            尝试获取右手边的筷子
                synchronized (right) {
                    eat();
                }
            }
        }
    }

    @SneakyThrows
    private void eat() {
        log.info("{} is eating", getName());
        TimeUnit.SECONDS.sleep(1);
    }

}
```

此时，我们再开五个哲学家，来进行测试

```java
public class TestDead {
    public static void main(String[] args) {
        Chopstick c1 = new Chopstick("1");
        Chopstick c2 = new Chopstick("2");
        Chopstick c3 = new Chopstick("3");
        Chopstick c4 = new Chopstick("4");
        Chopstick c5 = new Chopstick("5");
        new Philosopher("苏格拉底", c1, c2).start();
        new Philosopher("拿破仑", c2, c3).start();
        new Philosopher("马克思", c3, c4).start();
        new Philosopher("恩格斯", c4, c5).start();
        new Philosopher("阿基米德", c5, c1).start();
    }
}
```

当你试图run起来的时候，就会发现它们突然都不动了

![死锁](/images/JavaThread/3-共享模型之管程/1642334359828.png)

当然，你可能run的比我的快一些，接下来开`jconsole`看看

可以发现，他们全都被锁住了...

![死锁的体现](/images/JavaThread/3-共享模型之管程/1642334479168.png)

解决方案在之后会说，先混个眼熟即可

### 活锁的问题

这个比死锁的概念简单一些，直接上代码吧

```java
import javax.naming.SizeLimitExceededException;

public class TestCount {

    static int count = 0;
    static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            while (count > 0) {
                Thread.sleep(20);
                count++;
            }
        }, "t1").start();
        new Thread(() -> {
            while (count <= 20) {
                Thread.sleep(20);
                count--;
            }
        }, "t2").start();
    }
}
```

可以看到 他们两个冲突了，这样程序将永远不会结束

解决的方案也很简单：把他们的时间弄的错来开，例如第一个是20ms，第二个就是40ms，这样虽然也要时间过，但是他们两终归能结束运行

实际在开发中遇到这种问题，就可以考虑使用随机数随机加减一些睡眠时间来解决，当然最好是规避这个问题

### 饥饿

这个普遍来说定义是：一个线程由于优先级太低，始终得不到CPU的运行，也不能结束，饥饿的情况不容易复现，但是之后在读写锁(涉及到IO时)会碰上这个问题

来看看一个使用顺序加锁的方式解决之前死锁的问题

![获取锁](/images/JavaThread/3-共享模型之管程/1642335108435.png)

顺序加锁的解决方案

![解锁](/images/JavaThread/3-共享模型之管程/1642335165021.png)

通过给定优先级或者设定时间，避免死锁

我们来改进下之前的死锁代码

![1](/images/JavaThread/3-共享模型之管程/1642335278286.png)

可以看到一直在run了

![结果](/images/JavaThread/3-共享模型之管程/1642335365891.png)

并且没有检测到死锁

![死锁null](/images/JavaThread/3-共享模型之管程/1642335378993.png)

但是你能发现一个情况，程序在运行了一段时间之后，就很难见到阿基米德

![1](/images/JavaThread/3-共享模型之管程/1642335420560.png)

这就是属于一种线程的饥饿，有些线程因为优先级的问题始终获取不到锁...

## ReentrantLock

相对于synchronized，它具备如下特点：

- 可以中断
- 可以设置超时时间
- 可以设置为公平锁
- 支持多个条件变量

和synchronized一样，都支持重入，通过它，我们可以很方便的解决死锁和饥饿问题

属于JUC,基本语法如下:

```java
import java.util.concurrent.locks.ReentrantLock;

public class A {
    static final ReentrantLock reentrantLock = new ReentrantLock();

    public static void main(String[] args) {
//    获取锁
        reentrantLock.lock();
        try {
//          临界区
            System.out.println("获取到了锁");
        } catch (Exception e) {
//          释放锁
            reentrantLock.unlock();
        }

    }
}
```

### 可重入

可重入是指同一个线程如果首次获取到了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁

如果是不可重入锁，那么第二次获得锁时，自己也会被锁住

ReentrantLock和Synchronized都是可重入锁

```java
import java.util.concurrent.locks.ReentrantLock;

public class A {
    static final ReentrantLock reentrantLock = new ReentrantLock();

    public static void main(String[] args) {
//    获取锁
        reentrantLock.lock();
        try {
//          临界区
            System.out.println("enter-1");
            m1();
        } catch (Exception e) {
//          释放锁
            reentrantLock.unlock();
        }
    }

    public static void m1() {
        //    获取锁
        reentrantLock.lock();
        try {
//          临界区
            System.out.println("enter-2");
            m2();
        } catch (Exception e) {
//          释放锁
            reentrantLock.unlock();
        }
    }

    public static void m2() {
        //    获取锁
        reentrantLock.lock();
        try {
//          临界区
            System.out.println("enter-3");
        } catch (Exception e) {
//          释放锁
            reentrantLock.unlock();
        }
    }

}
```

最终123都会被打印出来

![运行结果](/images/JavaThread/3-共享模型之管程/1642336433462.png)

### 可打断

就是在等待的过程中，其他线程可以用`inputter()`终止等待

在使用ReentrantLock的时候，如果要当前锁可以在等待期间被打断的话，需要使用`lockInterruptibly`来进行加锁，使用普通的`lock`来加锁无法实现可被打断

```java

@Slf4j(topic = "c.TestReenter")
public class TestReenter {
    static final ReentrantLock reentrantLock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            try {
//                如果没有竞争，那么此方法就会获取Lock对象锁，如果有竞争，就会进入阻塞队列
//                可以被其他线程用interruput打断
                log.debug("尝试获取锁");
                reentrantLock.lockInterruptibly();
            } catch (InterruptedException e) {
//                这里相当于在等待的期间被打断了，也就是根本没有获取到锁
                e.printStackTrace();
                return;
            }
            try {
                log.info("获取锁");
            } finally {
                reentrantLock.unlock();
            }
        }, "t1");

        reentrantLock.lock();
        t1.start();
        Thread.sleep(1000);
//        打断
        t1.interrupt();
//        主线程结束
        reentrantLock.unlock();


    }


}
```

最终运行结果：

![a](/images/JavaThread/3-共享模型之管程/1642337150360.png)

这样做的好处是，可以有效防止死锁的情况发生（因为锁是可以被打断的）

### 锁超时

也就是立刻失败，不让死等，从而避免死锁的情况发生，刚刚地锁打断是被动的，这个是主动的

使用也非常简单，使用`lock.tryLock`即可，这样做是尝试获取锁，如果获取成功，则返回true，如果获取失败，则返回false，此时我们就可以根据自身情况来进行对应的操作

```java

@Slf4j(topic = "c.TestReenter")
public class TestReenter {
    static final ReentrantLock reentrantLock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            log.debug("启动...");
            if (!reentrantLock.tryLock()) {
                log.debug("获取锁失败，返回");
                return;
            }
            try {
                log.debug("获取到了锁");
            } finally {
                reentrantLock.unlock();
            }
        }, "t1");

        reentrantLock.lock();
        log.info("获取到了锁");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } finally {
            reentrantLock.unlock();
        }

    }


}
```

运行结果：

```text
20:52:57.231 [main] INFO c.TestReenter - 获取到了锁
20:52:57.236 [t1] DEBUG c.TestReenter - 启动...
20:52:57.236 [t1] DEBUG c.TestReenter - 获取锁失败，返
```

当然，我们还可以指定等待时间，例如等待10秒，如果十秒内能够获取得到锁，就继续执行

```java

@Slf4j(topic = "c.TestReenter")
public class TestReenter {
    static final ReentrantLock reentrantLock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            log.debug("启动...");
            try {
                if (!reentrantLock.tryLock(10, TimeUnit.SECONDS)) {
                    log.debug("获取锁失败，返回");
                    return;
                }
            } catch (InterruptedException e) {
//                这个异常是因为tryLock支持可打断，可以用那啥把等待中的这个线程打断掉，做一些别的操作
                log.error("获取不到锁");
                e.printStackTrace();
                return;
            }
            try {
                log.debug("获取到了锁");
            } finally {
                reentrantLock.unlock();
            }
        }, "t1");

        reentrantLock.lock();
        log.info("获取到了锁");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } finally {
            reentrantLock.unlock();
        }
    }
}
```

运行结果：

```text
20:58:53.043 [main] INFO c.TestReenter - 获取到了锁
20:58:53.047 [t1] DEBUG c.TestReenter - 启动...
20:58:55.063 [t1] DEBUG c.TestReenter - 获取到了锁
```

### 使用锁超时解决哲学家问题

我们之前哲学家问题的根源就在这个加锁和解锁上---有可能右手的筷子正在被其他人的左手使用

```java

@EqualsAndHashCode(callSuper = true)
@Data
@Slf4j(topic = "c.Philosopher")
public class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;

    /**
     * @param name  线程的名字
     * @param left  左手边的筷子
     * @param right 右手边的筷子
     */
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }

    @Override
    public void run() {
        while (true) {
//        尝试获取左手边的筷子
            synchronized (left) {
//            尝试获取右手边的筷子======= 问题就在这里，synchronized拿不到锁所以会一直在等待
                synchronized (right) {
                    eat();
                }
            }
        }
    }

    @SneakyThrows
    private void eat() {
        log.info("{} is eating", getName());
        TimeUnit.SECONDS.sleep(1);
    }
}
```

我们解决的方式很简答，首先明确的是-筷子是公用的，所以说可以给筷子挂上一个锁的属性

```java
/**
 * 筷子类
 */
@EqualsAndHashCode(callSuper = true)
@Data
@AllArgsConstructor
@NoArgsConstructor
class Chopstick extends ReentrantLock {
    private String name;
}
```

接着，只需要改动下我们的哲学家，让其通过tryLock来获取锁即可

```java

@EqualsAndHashCode(callSuper = true)
@Data
@Slf4j(topic = "c.Philosopher")
public class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;

    /**
     * @param name  线程的名字
     * @param left  左手边的筷子
     * @param right 右手边的筷子
     */
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }

    @Override
    public void run() {
        while (true) {
//            尝试获取左手筷子 这里也可以换成有时限的，降低一些CPU的负担
            if (left.tryLock()) {
                try {
//                        尝试获取右手筷子
                    if (right.tryLock()) {
                        try {
                            eat();
                        } finally {
//                            解锁右手筷子
                            right.unlock();
                        }
                    }
                } finally {
//                        解锁左手的筷子
                    left.unlock();
                }

            }
        }
    }

    @SneakyThrows
    private void eat() {
        log.info("{} is eating", getName());
        TimeUnit.SECONDS.sleep(1);
    }

}
```

接着主方法内恢复最开始的无序获取

```java

public class TestDead {
    public static void main(String[] args) {
        Chopstick c1 = new Chopstick("1");
        Chopstick c2 = new Chopstick("2");
        Chopstick c3 = new Chopstick("3");
        Chopstick c4 = new Chopstick("4");
        Chopstick c5 = new Chopstick("5");
        new Philosopher("苏格拉底", c1, c2).start();
        new Philosopher("拿破仑", c2, c3).start();
        new Philosopher("马克思", c3, c4).start();
        new Philosopher("恩格斯", c4, c5).start();
        new Philosopher("阿基米德", c5, c1).start();
    }
}
```

看看log

```text
21:14:15.923 [拿破仑] INFO c.Philosopher - 拿破仑 is eating
21:14:15.923 [恩格斯] INFO c.Philosopher - 恩格斯 is eating
21:14:16.947 [拿破仑] INFO c.Philosopher - 拿破仑 is eating
21:14:16.947 [恩格斯] INFO c.Philosopher - 恩格斯 is eating
21:14:17.954 [拿破仑] INFO c.Philosopher - 拿破仑 is eating
21:14:17.954 [阿基米德] INFO c.Philosopher - 阿基米德 is eating
21:14:18.963 [恩格斯] INFO c.Philosopher - 恩格斯 is eating
21:14:18.963 [拿破仑] INFO c.Philosopher - 拿破仑 is eating
21:14:19.968 [苏格拉底] INFO c.Philosopher - 苏格拉底 is eating
21:14:19.968 [马克思] INFO c.Philosopher - 马克思 is eating
21:14:20.972 [恩格斯] INFO c.Philosopher - 恩格斯 is eating
......
可以发现没有死锁的情况发生了,并且也没有饥饿的问题发生
```

### 公平锁

ReentrantLock默认和synchronized一样是不公平的锁

当一个线程持有锁，其他线程都会进入等待队列去等待，当该线程执行完毕归还锁的时候，其他线程就会一拥而上抢夺锁

如果是公平锁，则一个线程执行完毕归还锁后，其他线程会按照进入队列的顺序，有序的依次地获取到锁

但是ReentrantLock可以通过重载构造方法传入true来实现公平

```java
import java.util.concurrent.locks.ReentrantLock;

public class Test {
    public static final ReentrantLock lock = new ReentrantLock(true);
}
```

但是这种方式并不值得提倡，一般没有必要，会降低并发度，本意虽然是用来解决饥饿问题的，但是我们已经有更好的替代品tryLock了

### 条件变量

synchronized中也有条件变量，就是我们之前在院里的时候，那个waitSet休息室，当条件不满足的时候，进入waitSet等待

ReentrantLock的条件变量比synchronized的强大之处在于：它是支持多个条件变量的，这就好比：

- synchronized是那些不满足条件的在一旁的休息室等着
- 而它支持多间休息室，有专门的的等烟休息室、专门的早餐休息室.....唤醒的时候也是按照休息室来进行唤醒

使用流程

1. await前需要获取到锁
2. await执行后，会释放锁，进入conditionalObject等待
3. await的线程被唤醒(或被打断、或超时)去重新竞争LOCK锁
4. 竞争lock锁成功后，从await后继续执行

```java

public class TestAwait {
    static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
//        创建一个新的条件变量（休息室）
        Condition condition1 = lock.newCondition();
        Condition condition2 = lock.newCondition();
        lock.lock();
        try {
//            进入休息室等待
//            condition1.await();
//            按照时间等待
            condition1.await(1, TimeUnit.SECONDS);

//            进入不能被打断的等待
//            condition1.awaitUninterruptibly();

        } catch (InterruptedException e) {
            e.printStackTrace();
        }

//        叫醒condition1里面随机一个线程
//        condition1.signal();
//        叫醒condition1里面所有线程
        condition1.signalAll();

    }

}
```

## 同步模式之顺序控制

### wait notify版

两个线程，必须先2后1打印，非常简单

```java
public class Test {
    static final Object obj = new Object();
    static boolean t2True = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (obj) {
                while (!t2True) {
                    obj.wait();
                }
                System.out.println("t1的内容");
            }
        }, "t1").start();
        new Thread(() -> {
            synchronized (obj) {
                t2True = true;
                obj.notifyAll();
            }
        }, "t2").start();
    }
}
```

### ReentrantLock版

有两种方式，这里一种一种的用

```java
import lombok.ToString;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class Test {
    static final ReentrantLock lock = new ReentrantLock();
    static Condition t2Locks = lock.newCondition();

    public static void main(String[] args) {
        new Thread(() -> {
            lock.lock();
            t2Locks.await();
            System.out.println("t1打印");
            lock.unlock();
        }, "t1").start();

        new Thread(() -> {
            lock.lock();
            System.out.println("t2打印");
            t2Locks.signalAll();
            lock.unlock();
        }, "t2").start();
    }
}
```

或者通过park的方式来--使用lockSupport

```java
import java.util.concurrent.locks.LockSupport;

public class Test {

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            LockSupport.park();
            System.out.println("t1");
        }, "t1");
        t1.start();
        new Thread(() -> {
            System.out.println("t2");
            LockSupport.unpark(t1);
        }, "t2").start();
    }
}
```

## 设计模式-交替输出

### wait-notify

要求：abc这三个字母轮番按照顺序输出

这个之前已经有在老韩那里学过了，我就简单写下，其他的同理，都是差不多的意思

```java
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;

@Slf4j(topic = "c.Test")
public class Test {
    static final Object obj = new Object();
    /**
     * 0---A
     * 1---B
     * 2---C
     */
    static int count = 0;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (obj) {
                while (count != 0) {
                    obj.wait();
                }
                log.info("A");
                count = 1;
                obj.notifyAll();
            }
        }, "t1").start();

        new Thread(() -> {
            synchronized (obj) {
                while (count != 1) {
                    obj.wait();
                }
                log.info("B");
                count = 2;
                obj.notifyAll();
            }
        }, "t2").start();

        new Thread(() -> {
            synchronized (obj) {
                while (count != 2) {
                    obj.wait();
                }
                log.info("C");
                obj.notifyAll();
            }
        }, "t3").start();

    }

}
```