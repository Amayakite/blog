---
title: 23-正则表达式
date: 2021-11-29 21:49:05
category: JavaSE
tag:
 - Java
 - JavaSE
 - RegExp
---

## 初始正则表达式

假设你现在通过爬虫之类的东西，从百度中爬取到了以下文本

```md
1994年6、7月间，在经历了一场历时三天的讨论之后，团队决定再一次改变了努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器WebRunner。 [8]
1995年，互联网的蓬勃发展给了Oak机会。业界为了使死板、单调的静态网页能够“灵活”起来，急需一种软件技术来开发一种程序，这种程序可以通过网络传播并且能够跨平台运行。于是，世界各大IT企业为此纷纷投入了大量的人力、物力和财力。这个时候，Sun公司想起了那个被搁置起来很久的Oak，并且重新审视了那个用软件编写的试验平台，由于它是按照嵌入式系统硬件平台体系结构进行编写的，所以非常小，特别适用于网络上的传输系统，而Oak也是一种精简的语言，程序非常小，适合在网络上传输。Sun公司首先推出了可以嵌入网页并且可以随同网页在网络上传输的Applet（Applet是一种将小程序嵌入到网页中进行执行的技术），并将Oak更名为Java（在申请注册商标时，发现Oak已经被人使用了，再想了一系列名字之后，最终，使用了提议者在喝一杯Java咖啡时无意提到的Java词语）。5月23日，Sun公司在Sun world会议上正式发布Java和HotJava浏览器。IBM、Apple、DEC、Adobe、HP、Oracle、Netscape和微软等各大公司都纷纷停止了自己的相关开发项目，竞相购买了Java使用许可证，并为自己的产品开发了相应的Java平台。 [9-10]
1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0），这是Java发展历程中的重要里程碑，标志着Java成为一种独立的开发工具。9月，约8.3万个网页应用了Java技术来制作。10月，Sun公司发布了Java平台的第一个即时（JIT）编译器。
1997年2月，JDK 1.1面世，在随后的3周时间里，达到了22万次的下载量。4月2日，Java One会议召开，参会者逾一万人，创当时全球同类会议规模之纪录。9月，Java Developer Connection社区成员超过10万。
```

现在有一个需求，获取到文章中的所有英文单词

使用传统的方法将要:

```java
//        使用传统方法提取单词
        char[] chars = str.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            switch (chars[i]) {
                case 'a':
                case 'b':
                    。。。。。。
                    System.out.println(chars[i]);
                    break;
                default:
            }
        }
```

二十六个字母大小写都要过一遍，并且要识别下一个是不字母，是的话拼接，不是的话return

接下来使用正则表达式来解决这个问题

```java
public static void main(String[] args) {
    String str = "1994年6、7月....";
    Pattern pattern = Pattern.compile("[a-zA-Z]+");
    //        创建一个匹配其对象
    Matcher matcher = pattern.matcher(str);
    //        就是matcher匹配器按照pattern的模式，到str文本中去匹配，找到就返回true，否则就返回false
    //        开始循环匹配
    while (matcher.find()) {
        //            匹配内容，文本会放到matcher.group(0)
        System.out.println("找到：" + matcher.group(0));
    }

}
```

可以看到，完美的打印出了我想要的内容：

![image-20211129222342967](/images/Java/JavaSE/23-正则表达式/image-20211129222342967.png)

好，接下来尝试匹配数字 只需要替换一段话即可

```java
Pattern pattern = Pattern.compile("[0-9]+");
```

然后再匹配所有的英文单词和数字

```java
Pattern pattern = Pattern.compile("[a-zA-Z0-9]+");
```

接下来尝试匹配下百度热搜中的标题，下方是直接拔下来的代码

![image-20211129223145065](/images/Java/JavaSE/23-正则表达式/image-20211129223145065.png)

```html
<div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-top_3xY_F undefined c-index-single-hot1 " style="opacity:1;">1</span><a target="_blank" title="从六中全会公报看世界第一大党" href="/s?tn=88093251_10_hao_pg&amp;wd=%E4%BB%8E%E5%85%AD%E4%B8%AD%E5%85%A8%E4%BC%9A%E5%85%AC%E6%8A%A5%E7%9C%8B%E4%B8%96%E7%95%8C%E7%AC%AC%E4%B8%80%E5%A4%A7%E5%85%9A&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=824aAXp8%2BpFIUhwad5x92Sj445OMOJQqG8Tnhz%2FQCCIZDNmVQHfk0URcz2YsYx1XpG19vSbegMI7&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_1&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">从六中全会公报看世界第一大党<!--8--></a><span class="c-text c-text-hot opr-toplist1-label_3Mevn">热</span><!--9--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">497万</div></div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-top_3xY_F undefined c-index-single-hot2 " style="opacity:1;">2</span><a target="_blank" title="关于奥密克戎 卫健委权威解答来了" href="/s?tn=88093251_10_hao_pg&amp;wd=%E5%85%B3%E4%BA%8E%E5%A5%A5%E5%AF%86%E5%85%8B%E6%88%8E%20%E5%8D%AB%E5%81%A5%E5%A7%94%E6%9D%83%E5%A8%81%E8%A7%A3%E7%AD%94%E6%9D%A5%E4%BA%86&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=4f97eSWhSQ3ERobcS5hZd4hLh%2FCzUa4z7RPEtvlOMiZ2eoiS6UcSWDs5%2BWzN1xOkaiahoa4tXmk3&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_2&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">关于奥密克戎 卫健委权威解答来了<!--10--></a><!--11--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">487万</div></div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-top_3xY_F undefined c-index-single-hot3 " style="opacity:1;">3</span><a target="_blank" title="十九届六中全会决议中的10个明确" href="/s?tn=88093251_10_hao_pg&amp;wd=%E5%8D%81%E4%B9%9D%E5%B1%8A%E5%85%AD%E4%B8%AD%E5%85%A8%E4%BC%9A%E5%86%B3%E8%AE%AE%E4%B8%AD%E7%9A%8410%E4%B8%AA%E6%98%8E%E7%A1%AE&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=4f97eSWhSQ3ERobcS5hZd4hLh%2FCzUa4z7RPEtvlOMiZ2eoiS6UcSWDs5%2BWzN1xOkaiahoa4tXmk3&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_3&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">十九届六中全会决议中的10个明确<!--12--></a><!--13--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">479万</div></div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-normal_12THH " style="opacity:1;">4</span><a target="_blank" title="今冬第四轮大范围寒潮来了" href="/s?tn=88093251_10_hao_pg&amp;wd=%E4%BB%8A%E5%86%AC%E7%AC%AC%E5%9B%9B%E8%BD%AE%E5%A4%A7%E8%8C%83%E5%9B%B4%E5%AF%92%E6%BD%AE%E6%9D%A5%E4%BA%86&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=4f97eSWhSQ3ERobcS5hZd4hLh%2FCzUa4z7RPEtvlOMiZ2eoiS6UcSWDs5%2BWzN1xOkaiahoa4tXmk3&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_4&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">今冬第四轮大范围寒潮来了<!--14--></a><!--15--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">464万</div></div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-normal_12THH " style="opacity:1;">5</span><a target="_blank" title="中国从未邀请美国政客出席冬奥会" href="/s?tn=88093251_10_hao_pg&amp;wd=%E4%B8%AD%E5%9B%BD%E4%BB%8E%E6%9C%AA%E9%82%80%E8%AF%B7%E7%BE%8E%E5%9B%BD%E6%94%BF%E5%AE%A2%E5%87%BA%E5%B8%AD%E5%86%AC%E5%A5%A5%E4%BC%9A&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=4f97eSWhSQ3ERobcS5hZd4hLh%2FCzUa4z7RPEtvlOMiZ2eoiS6UcSWDs5%2BWzN1xOkaiahoa4tXmk3&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_5&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">中国从未邀请美国政客出席冬奥会<!--16--></a><!--17--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">459万</div></div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-normal_12THH " style="opacity:1;">6</span><a target="_blank" title="内蒙古满洲里检出阳性样本60份" href="/s?tn=88093251_10_hao_pg&amp;wd=%E5%86%85%E8%92%99%E5%8F%A4%E6%BB%A1%E6%B4%B2%E9%87%8C%E6%A3%80%E5%87%BA%E9%98%B3%E6%80%A7%E6%A0%B7%E6%9C%AC60%E4%BB%BD&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=4f97eSWhSQ3ERobcS5hZd4hLh%2FCzUa4z7RPEtvlOMiZ2eoiS6UcSWDs5%2BWzN1xOkaiahoa4tXmk3&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_6&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">内蒙古满洲里检出阳性样本60份<!--18--></a><!--19--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">446万</div></div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-normal_12THH " style="opacity:1;">7</span><a target="_blank" title="河南多地凌晨突然被不明物体照亮" href="/s?tn=88093251_10_hao_pg&amp;wd=%E6%B2%B3%E5%8D%97%E5%A4%9A%E5%9C%B0%E5%87%8C%E6%99%A8%E7%AA%81%E7%84%B6%E8%A2%AB%E4%B8%8D%E6%98%8E%E7%89%A9%E4%BD%93%E7%85%A7%E4%BA%AE&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=4f97eSWhSQ3ERobcS5hZd4hLh%2FCzUa4z7RPEtvlOMiZ2eoiS6UcSWDs5%2BWzN1xOkaiahoa4tXmk3&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_7&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">河南多地凌晨突然被不明物体照亮<!--20--></a><!--21--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">436万</div></div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-normal_12THH " style="opacity:1;">8</span><a target="_blank" title="深圳警方通报一男子路口劫持人质" href="/s?tn=88093251_10_hao_pg&amp;wd=%E6%B7%B1%E5%9C%B3%E8%AD%A6%E6%96%B9%E9%80%9A%E6%8A%A5%E4%B8%80%E7%94%B7%E5%AD%90%E8%B7%AF%E5%8F%A3%E5%8A%AB%E6%8C%81%E4%BA%BA%E8%B4%A8&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=2f13%2FChA15s%2Bpcr%2BTHV6ICPZUtJTBqt%2Bg7qa%2Fe3MkDNJGNr7CYeRnPGiGu2P1c36vhJUGElbuGqn&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_8&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">深圳警方通报一男子路口劫持人质<!--22--></a><!--23--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">426万</div></div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-normal_12THH " style="opacity:1;">9</span><a target="_blank" title="微信试行松绑外链" href="/s?tn=88093251_10_hao_pg&amp;wd=%E5%BE%AE%E4%BF%A1%E8%AF%95%E8%A1%8C%E6%9D%BE%E7%BB%91%E5%A4%96%E9%93%BE&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=2f13%2FChA15s%2Bpcr%2BTHV6ICPZUtJTBqt%2Bg7qa%2Fe3MkDNJGNr7CYeRnPGiGu2P1c36vhJUGElbuGqn&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_9&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">微信试行松绑外链<!--24--></a><!--25--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">412万</div></div><div class="toplist1-tr_4kE4D"><div class="toplist1-td_3zMd4 opr-toplist1-link_2YUtD"><span class="toplist1-hot_2RbQT c-index-single toplist1-hot-normal_12THH opr-toplist1-one-font_3t8Qt" style="opacity:1;">10</span><a target="_blank" title="外交部针对奥密克戎进行回应" href="/s?tn=88093251_10_hao_pg&amp;wd=%E5%A4%96%E4%BA%A4%E9%83%A8%E9%92%88%E5%AF%B9%E5%A5%A5%E5%AF%86%E5%85%8B%E6%88%8E%E8%BF%9B%E8%A1%8C%E5%9B%9E%E5%BA%94&amp;usm=5&amp;ie=utf-8&amp;rsv_pq=e70b81680001c594&amp;oq=baidu&amp;rsv_t=2f13%2FChA15s%2Bpcr%2BTHV6ICPZUtJTBqt%2Bg7qa%2Fe3MkDNJGNr7CYeRnPGiGu2P1c36vhJUGElbuGqn&amp;rqid=e70b81680001c594&amp;rsf=633b61ff30c35de3a95a3c1d295d44ff_1_10_10&amp;rsv_dl=0_right_fyb_pchot_20811" class="c-font-medium c-color-t opr-toplist1-subtitle_3FULy">外交部针对奥密克戎进行回应<!--26--></a><!--27--></div><div class="toplist1-right-num_3FteC toplist1-td_3zMd4" style="line-height:20px;position:relative;top:2px;">401万</div></div><!--7--></div>
```

开始使用正则进行匹配：

```java
//创建一个匹配器
Pattern pattern = Pattern.compile("<a target=\"_blank\" title=\"(\\S*)\"");
//创建一个匹配其对象
Matcher matcher = pattern.matcher(str);
//开始循环匹配
int count = 0;
while (matcher.find()) {
//匹配内容，这里内容会被放到matcher.group(1) 原理之后说
    System.out.println("找到热榜第"+(++count)+"的是:" + matcher.group(1));
}
```

可以看到，依旧完美的成功跑起来了

经过上面的案例，不难看出，正则表达式是处理文本的最佳选择，无论在什么情况下都是

接下来再提出一个需求：

```md
1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及9889。
```

1. 找出所有四个数字连在一起的字串
2. 找出所有四个数字连接在一起的字串，并且这四个数字要满足：第一位与第四位相同，第二位与第三位相同，比如：1221,5775
3. 写一个控制台程序，要求用户输入邮箱，并验证是否符合邮箱格式(xxxxx@xx.xx)
4. 验证用户输入的手机号是否符合手机号格式(19919991999)

​  为了解决上述的问题，Java提供了正则表达式技术，专门用于处理类似文本问题（当然，所有语言中都有这个功能，不过就个人感知来说，Java的正则表达式算是比较难用的那一类--没有``符，需要对转义符\进行二次转义）

​  简单来说，**正则表达式是对字符串执行模式匹配的技术**

​  正则表达式全称：regualr expression 简称 **RegExp**

​  所有语言中都含有正则表达式（特别垃圾的才没有），语法基本上都大同小异，学完一个其他的也就都会了，这玩意是所有程序员必备技能，面试不会问但是实际工作中（比如爬虫。全文搜索等功能）都要用到它

## 正则表达式的底层实现

案例：

```md
1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及9889。
```

找出所有四个数字连在一起的字串：应该找到1998 1999 3443 9889

上代码`RegTheory.java`：

```java
@Test
public void run1() {
    String conecnt = "1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及9889。";
    //        目标：匹配所有四个数字
    //        \\d表示一个任意的数字
    String regex = "\\d{4}";
    //        全写，上方是简写
    String regStr = "\\d\\d\\d\\d";
    //        创建一个正则表达式对象
    Pattern pattern = Pattern.compile(regex);
    //        创建一个匹配器，按照上方正则表达式的规则， 去匹配content字符串
    Matcher matcher = pattern.matcher(conecnt);
    //        开始匹配 循环的匹配
    while (matcher.find()) {
        System.out.println("result：" + matcher.group(0));
    }
}
```

### find方法和group(0)的源码分析

`matcher.find()`完成的任务

1. 根据指定的规则，定位满足规则的子字符串
   - 比如`世界你好1999阿啊啊`中，匹配四个数字，则找1和最后一个9的位置，分别为,4和7(从0开始索引)
2. 找到后，将**子字符串**开始的索引(4)记录到`mathcer`对象的属性 `int groups[]`当中
   1. `groups[0]=4`
   2. 并把该子字符串的结束的**索引(7)+1**的值记录到`groups[1]=7+1`
3. 同时记录：
   1. 初始值4到`int first`中：`first=4`

4. 结束的索引+1记录到`int last`和`int oldLast`中7+1，即：下次开始找的时候，从7+1这个位置开始进行匹配(下次执行`find()`方法中从8开始匹配)

   -

`matcher.group(0)`完成的任务

先看源码：

```java
public String group(int group) {
    if (first < 0)
        throw new IllegalStateException("No match found");
    if (group < 0 || group > groupCount())
        throw new IndexOutOfBoundsException("No group " + group);
    if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
        return null;
    // 当我们执行group(0)的时候，可以看到不满足前面的条件，因此执行下面的这些代码
    // 他这里传入了两个值，一个是group*2=0 也就是groups[0]
    //第二个是group*2+1=1 也就是groups[1]
    // groups中这两个位置的值可以通过之前的代码了解到，分别是4和8
    // 根据字符串的截取原则(截前不截后,subString()的规则)
    // 可以得知，最终截取的结果为索引4~7之间的字符串
    // 所以返回的就是4,5,6,7这四个索引位置的字符
    return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();
}
```

### 在分组情况下的源码分析

分组就是当我查找4个连在一起的数字，但是又想把它们的前两个和后两个分开来：

`(\\d\\d)(\\d\\d)`

就需要这样，比如1998，最终得出的结果为:[1998],[19],[98] 也就是有三个结果，三组内容

理论来说，分组的数量为括号数量+1

第一个小括号是第一组 19，第二个小括号是第二组 98，第0组为匹配这些内容的值：1998

接下来开始分析，测试内容为`1998年12月8日，第二代Java平台的企业版J2EE发布。......`

首先进行`matcher.find()`

1. 根据规则匹配`(\\d\\d)(\\d\\d)`
   1. 首先找到的子字符串是1998
   2. 然后记录索引位置，分别是`groups[0]=0,groups[1]=4`
   3. 记录第一组`()`匹配到的字符串的开始索引位置记录到`groups[2]=?`，结束的索引位置记录到`groups[3]=?+1`
      - `groups[2]=0`
      - `groups[3]=2`
   4. 第二组`()`原理同上，分别记录到`groups[4]=2`，`groups[5]=4`
   5. 如果还有更多括号的以此类推
2. 并同时记录`oldLast`的值为该子字符串传的结束位置+1`oldLast=4`

![image-20211130122015863](/images/Java/JavaSE/23-正则表达式/image-20211130122015863.png)

接下来看看他们是怎么截取的

在`matcher.group(int group )`中，可以看到最后return的值为：

`getSubSequence(groups[group * 2], groups[group * 2 + 1])`

也就是说，如果是第0组，结果为：0,1

第一组的话，结果为：2,3

第二组的话，结果为：4,5

完美对应了上一步存放的位置

啊，真是精妙的设计..接下来看看结果：

![image-20211130122524760](/images/Java/JavaSE/23-正则表达式/image-20211130122524760.png)

 代码片段

```java
String regStr = "(\\d\\d)(\\d\\d)";
//        创建一个正则表达式对象
Pattern pattern = Pattern.compile(regStr);
//        创建一个匹配器，按照上方正则表达式的规则， 去匹配content字符串
Matcher matcher = pattern.matcher(conecnt);
//        开始匹配 循环的匹配
while (matcher.find()) {
    System.out.println("result：" + matcher.group(0));
    System.out.println("匹配到的第一组：" + matcher.group(1));
    System.out.println("匹配到的第二组：" + matcher.group(2));
}
```

总结：

- group(0)表示匹配到的整体的子字符串
- group(n)表示匹配到的子字符串的第n组字串

​  如果说n的数量大于括号的数量，如，只有两个括号，但是group(3)，就可以根据前面的规则发现，group(3)中对应的初始索引位置`groups[5]`和`groups[6]`分别都是-1，字符串中截取-1的值，直接抛出**下标越界异常**

​  所以分组不能越界

## 正则表达式语法

​  如果想要灵活的运用正则表达式，必须了解其中的各种语法，元字符从功能上大概分为：

1. 限定符
2. 选择匹配符
3. 分组组合和反向引用符
4. 特殊字符
5. 字符匹配符
6. 定位符

### 元字符-转义号及常用匹配符

`\\`符号 说明：当我们使用正则表达式去检索某些**特殊字符**的时候，需要用到转义符，否则检索不到结果，甚至会报错，比如说我们现在有一个字符串：`abc$(`，相匹配其中的`abc$`现在试图直接匹配下

```java
Pattern pattern = Pattern.compile("abc$");
```

可以看到，什么都没有匹配到

现在尝试加上转义符`\\`:

```java
Pattern pattern = Pattern.compile("abc\\$");
```

成功的匹配出了结果：`result：abc$`

额外提醒：**Java的正则表达式中，两个`\\`代表其他语言中的一个`\`(正则匹配这方面做的不是很好)**

需要用到转移符号的字符有以下：

`. * + ( )  $ / \ ?[ ] ^ { } -`

- `.` 表示匹配所有字符
- `[]` 表示可接收的字符串：
  例如：我想要匹配efgh中的任意一个字符，则需要：
  `[efgh]` 匹配e、f、g、h中的任意一个字符
- [^]表示不接受的字符串
  例如：`[^abc]`表示除了a、b、c以外的任意一个字符，包括数字和特殊符号

-

## 正则表达式-元字符-字符匹配符

| 符号  | 作用                                                                         |      实例      | 解释                                                                                 | 匹配输入               |
| :---: | :--------------------------------------------------------------------------- | :------------: | ------------------------------------------------------------------------------------ | ---------------------- |
|  []   | 表示可接收的字符列表                                                         |     [efgh]     | 匹配e、f、g、h<br />中的任意一个字符                                                 | e、f                   |
|  [^]  | 表示不接受的字符列表                                                         |     [^abc]     | 表示**除了**a、b、c以外的<br />任意一个字符<br />包括数字和特殊符号                  | a、b                   |
|   -   | 连字符，一般在[]内使用                                                       |      A-Z       | 任意单个大写字母                                                                     | A、Y                   |
|       |                                                                              |      0-9       | 任意单个数字                                                                         | 0、8                   |
|       |                                                                              |      a-z       | 任意单个小写字母                                                                     | a、y                   |
|       |                                                                              |   [^a-z]{2}    | 匹配两个不是小写a~z之间的<br />任意字符                                              | BD、AZ                 |
|   .   | 匹配除`\n`以外的任何字符                                                     |      a..b      | 以a开头，b结尾<br />中间包括2个任意字符的<br />长度为4的字符串                       | aaab 、<br />aefb      |
| `\\d` | 匹配单个数字字符<br />相当于`[0-9]`                                          | `\\d{3}(\\d)?` | 包含三个或四个数字的字符串                                                           | 123、9876              |
| `\\D` | 匹配**非**单个数字字符<br />相当于`[^0-9]`                                   |  `\\D(\\d)*`   | 以单个非数字字符开头，后<br />后面接任意个数字字符串                                 | a、A315                |
| `\\w` | 匹配单个数字，大小写字母<br />相当于`[0-9A-Za-z]`                            | `\\d{3}\\w{4}` | 以三个数字字符开头<br />长度为7的数字字母字符串                                      | 234abcd、<br />12345Pe |
| `\\W` | 匹配**非**单个数字，大小写字母<br />相当于`[^0-9A-Za-z]`                     |  `\\W+\\d{2}`  | 至少以一个非数字字母字符开头<br />2个数字字符结尾的字符串                            | #29、#?@10             |
| (?i)  | 让大小写不敏感                                                               |   `(?i)abc`    | 让abc都不区分大小写                                                                  | Abc、ABc、aBC          |
|       |                                                                              |   `a(?i)bc`    | 表示bc不区分大小写                                                                   | aBC、acC               |
|       |                                                                              |  `a((?i)b)c`   | 表示只有b不区分大小写                                                                | aBc、abc               |
|       | Parrtern.compile(RegExP,<br />Pattern.CASE_INSENSITIVE)<br />等同于`(?i)abc` |                | 仅在Java中有效<br />让其不区分大小写<br />在其他语言中基本是<br />`/abc/i`类似于这样 |                        |

## 元字符-选择匹配符

在匹配某个字符串的时候是选择性的，即：既可以匹配这个，又可以匹配那个，这时候需要用到选择匹配符

| 符号  | 作用                       |     实例      | 解释                     | 匹配输入               |
| :---: | -------------------------- | :-----------: | ------------------------ | ---------------------- |
|  \|   | 匹配"\|"之前或之后的表达式 |    `ab|cd`    | ab或者cd                 | ab、cd                 |
|       |                            | `[a-z]|[A-Z]` | A-z中的任意单个字符      | a、A、Z                |
|       |                            | `川流|不|息`  | 匹配串流 或者 不 或者 息 | 犹如车辆一般川流、不息 |

## 元字符-限定符

| 符号  | 作用                                           |     实例      | 解释                                                                                                            | 匹配输入                 |
| :---: | ---------------------------------------------- | :-----------: | --------------------------------------------------------------------------------------------------------------- | ------------------------ |
|   *   | 指定字符重复0次或者n次（无要求）<br />零到多次 |   `(abc)*`    | 仅包含任意个abc的字符串<br />等效于`\w*`                                                                        | abc<br />abcabcabc       |
|   +   | 指定字符串重复一次或n次（字少一次）<br />1到多 |  `m+(abc)*`   | 至少以1个m开头，后面接任意个abc的字符串                                                                         | m<br />mabc<br />mabcabc |
|   ?   | 指定字符重复0次或者1一次<br />最多一次         |   `m+abc?`    | 至少以一个m开头，后接ab或者abc的字符串<br />(c可以没有)，但是ab一定要有<br />如果abc加了括号包裹，abc也可以没有 | mab<br />mabc            |
|  {n}  | 指定至少n个匹配                                |  `[abcd]{3}`  | 由abcd中字母组成的任意长度为3的字符串                                                                           | abc<br />abd<br />bdc    |
| {n,m} | 指定至少n个但不多于m个匹配                     | `[abcd]{3,5}` | abcd中字母组成的任意长度<br />不小于3且不大于5的字符                                                            | abc<br />abcd<br />abcda |

## 元字符-定位符

| 符号  | 作用                             |        实例         | 解释                                                                         | 匹配输入                          |
| :---: | -------------------------------- | :-----------------: | ---------------------------------------------------------------------------- | --------------------------------- |
|   ^   | 指定起始字符                     |   `^[0-9]+[a-z]*`   | 至少以一个数字开头<br />后接任意个小写字符串                                 | 1aaaa<br />6vnf                   |
|   $   | 指定结束字符                     | `^[0-9]+\\-[a-z]+$` | 至少以一个数字开头<br />后连接`-`符，并以至少一个小写<br />字母结束字符      | 1-a<br />6-z<br />61111-zqqqqq    |
| `\\b` | 匹配目标字符串<br />的边界       |      `run\\b`       | 这里说的字符串边界指的是<br />字符串间有空格<br />或者是目标字符串的结束位置 | runI want **run** **run** **run** |
| `\\B` | 匹配目标字符串<br />的**非边界** |      `run\\b`       | 和`\\b`的含义相反                                                            | **run**I want run run run         |

## 分组和捕获

| 常用分组构造形式   | 说明                                                                                                                                                                  |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `(pattern)`        | 非命名捕获。<br />捕获匹配的子字符串，编号为0的第一个捕获是由整个正则表达式模式匹配的文本<br />其他捕获的结果则**根据左括号的顺序从1开始自动编号**                    |
| `(?<name>pattern)` | 命名捕获。<br />将匹配到的子字符串捕获到一个组名或编号中。<br />用于name的字符串不能包含任何标点符号，并且不能以数字开头<br />可以使用单引号代替尖括号，如：`?'name'` |

非命名捕获`(\\d)(\\d)(\\d\\d)`就是这样的格式，这里不多写了，之前已经写了一大截

命名捕获：使用起来就是这样，也就是说可以在使用的时候通过分组名更方便的获取想要的分组

```java
@Test
public void testRunByName() {
    String connect = "1234 5678";
    String regExp = "(?<g1>\\d\\d)(?<g2>\\d\\d)";
    Pattern pattern = Pattern.compile(regExp);
    Matcher matcher = pattern.matcher(connect);
    while (matcher.find()) {
        System.out.println("找到的内容：" + matcher.group());
        System.out.println("分组1：" + matcher.group(1));
        System.out.println("分组1【通过组名】：" + matcher.group("g1"));

        System.out.println("分组2：" + matcher.group(2));
        System.out.println("分组2【通过组名】：" + matcher.group("g2"));

    }
}
结果：
    
找到的内容：1234
分组1：12
分组1【通过组名】：12
分组2：34
分组2【通过组名】：34
......
```

## 几个常用的分组形式-非捕获匹配

| 常用分组构造形式 | 说明                                                                                                                                                                                                          |
| :--------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|   (?:pattern)    | 匹配pattern但不捕获该匹配的子表达式，即：它是一个非捕获匹配，不存储以后使用的匹配。<br />这对于用`or`字符(`|`)组合模式部件的情况很有用。<br />例如：`industr(?:y|ies)`是比`industry|industries`更经济的表达式 |
|   (?=pattern)    | 它是一个非捕获匹配。<br />例如：`Windows(?=95|98|NT|2000)`<br />可以匹配`Windows2000`中的`Windows`<br />但是不可以匹配`Windows3.1`中的`Windows`                                                               |
|   (?!pattern)    | 该表达式匹配不处于匹配`pattern`字符串的起始点的搜索字符串。<br />他是一个非捕获匹配。<br />例如：`Windows(?!95|98|NT|2000)`<br />匹配`Windows3.1`中的`Windows`<br />但是能匹配`Windows2000`中的`Windows`      |

演示：

```java
@Test
public void testRegF() {

    String str = "吃葡萄不吐葡萄皮 不吃葡萄不洗葡萄汁";
    //      1.  要求：找到葡萄、葡萄皮、葡萄汁的子字符串
    String regExp = "葡萄(?:皮|汁)";
    Pattern pattern = Pattern.compile(regExp);
    Matcher matcher = pattern.matcher(str);
    while (matcher.find()) {
        System.out.println("找到的内容1：" + matcher.group());
    }
    //      2.  要求：找到葡萄皮 葡萄汁但是不包含汁和皮
    String regExp2 = "葡萄(?=汁|皮)";
    Pattern pattern2 = Pattern.compile(regExp2);
    Matcher matcher2 = pattern2.matcher(str);
    while (matcher2.find()) {
        System.out.println("找到的内容2：" + matcher2.group());
    }
    //       3. 要求：找到葡萄 但是不能是葡萄皮 葡萄汁中有的葡萄
    String regExp3 = "葡萄(?!皮|汁)";
    Pattern pattern3 = Pattern.compile(regExp3);
    Matcher matcher3 = pattern3.matcher(str);
    while (matcher3.find()) {
        System.out.println("找到的内容3：" + matcher3.group());
    }
}
```

## 正则表达式一览表（全）

| 字符          | 说明                                                                                                                                                                                                                                                                                                                                                       |
| :------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \             | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， **n**匹配字符 **n**。**\n** 匹配换行符。序列 **\\\\** 匹配 **\\** ，**\\(** 匹配 **(**。                                                                                                                                                                                                    |
| ^             | 匹配输入字符串开始的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 还会与"\n"或"\r"之后的位置匹配。                                                                                                                                                                                                                                              |
| $             | 匹配输入字符串结尾的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，$ 还会与"\n"或"\r"之前的位置匹配。                                                                                                                                                                                                                                              |
| *             | 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。                                                                                                                                                                                                                                                                              |
| +             | 一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。                                                                                                                                                                                                                                                           |
| ?             | 零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。                                                                                                                                                                                                                                                              |
| {*n*}         | *n* 是非负整数。正好匹配 *n* 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。                                                                                                                                                                                                                                                             |
| {*n*,}        | *n* 是非负整数。至少匹配 *n* 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。                                                                                                                                                                                                                        |
| {*n*,*m*}     | *m* 和 *n* 是非负整数，其中 *n* <= *m*。匹配至少 *n* 次，至多 *m* 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。                                                                                                                                                                               |
| ?             | 当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是"非贪心的"。<br />**"非贪心的"模式匹配搜索到的、尽可能短的字符串**，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。                                                                                   |
| .             | 匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。                                                                                                                                                                                                                                                           |
| (*pattern*)   | 匹配 *pattern* 并捕获该匹配的子表达式。可以使用 **$0…$9** 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\("或者"\)"。                                                                                                                                                                                                                 |
| (?:*pattern*) | 匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (\|) 组合模式部件的情况很有用。例如，'industr(?:y\|ies) 是比 'industry\|industries' 更经济的表达式。                                                                                                                                               |
| (?=*pattern*) | 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95\|98\|NT\|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。        |
| (?!*pattern*) | 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95\|98\|NT\|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| *x*\|*y*      | 匹配 *x* 或 *y*。例如，'z\|food' 匹配"z"或"food"。'(z\|f)ood' 匹配"zood"或"food"。                                                                                                                                                                                                                                                                         |
| [*xyz*]       | 字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。                                                                                                                                                                                                                                                                                              |
| [^*xyz*]      | 反向字符集。匹配未包含的任何字符。例如，`[^abc]`匹配"plain"中"p"，"l"，"i"，"n"。                                                                                                                                                                                                                                                                          |
| [*a-z*]       | 字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。                                                                                                                                                                                                                                                                        |
| [^*a-z*]      | 反向范围字符。匹配不在指定的范围内的任何字符。例如，`[^a-z]`匹配任何不在"a"到"z"范围内的任何字符。                                                                                                                                                                                                                                                         |
| [?=&/%#.]     | 可以通过中括号来匹配任意的符号：比如 - ? = % . 这些字符有的在其他情况下是作为一个特殊的符号来使用的，比如 . 在其他情况下是通配符<br />常见的如下：`@``#$%^&*()_\-+=<>?:"{}`                                                                                                                                                                                |
| \b            | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。                                                                                                                                                                                                                                                              |
| \B            | 非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。                                                                                                                                                                                                                                                                                          |
| \c*x*         | 匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。                                                                                                                                                                                                                       |
| \d            | 数字字符匹配。等效于 [0-9]。                                                                                                                                                                                                                                                                                                                               |
| \D            | 非数字字符匹配。等效于 [^0-9]。                                                                                                                                                                                                                                                                                                                            |
| \f            | 换页符匹配。等效于 \x0c 和 \cL。                                                                                                                                                                                                                                                                                                                           |
| \n            | 换行符匹配。等效于 \x0a 和 \cJ。                                                                                                                                                                                                                                                                                                                           |
| \r            | 匹配一个回车符。等效于 \x0d 和 \cM。                                                                                                                                                                                                                                                                                                                       |
| \s            | 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。                                                                                                                                                                                                                                                                                      |
| \S            | 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。                                                                                                                                                                                                                                                                                                               |
| \t            | 制表符匹配。与 \x09 和 \cI 等效。                                                                                                                                                                                                                                                                                                                          |
| \v            | 垂直制表符匹配。与 \x0b 和 \cK 等效。                                                                                                                                                                                                                                                                                                                      |
| \w            | 匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。                                                                                                                                                                                                                                                                                                       |
| \W            | 与任何非单词字符匹配。与`[^A-Za-z0-9_]`等效。                                                                                                                                                                                                                                                                                                              |
| \x*n*         | 匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&"1"等效。允许在正则表达式中使用 ASCII 代码。                                                                                                                                                                                             |
| \\\*num\*     | 匹配 \\*num\*，此处的 \\*num\* 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。                                                                                                                                                                                                                                                   |
| \\\*n\*       | 标识一个八进制转义码或反向引用。如果 \\\*n\* 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。                                                                                                                                                                                                |
| \\\*nm\*      | 标识一个八进制转义码或反向引用。如果 \\\*nm\* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 \*nm*前面至少有*n*个捕获，则*n*是反向引用，后面跟有字符*m*。如果两种前面的情况都不存在，则 \\\*nm\* 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。                                                                                       |
| \nml          | 当 *n* 是八进制数 (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 *nml*。                                                                                                                                                                                                                                                                          |
| \u*n*         | 匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。                                                                                                                                                                                                                                                                  |

### 补充-贪婪匹配和非贪婪匹配

一段代码说明白：

```java
@Test
public void regExpNoS() {
    String str = "hello111111 ok";
    //默认是贪婪匹配
    String regStr = "\\d+";
    //非贪婪匹配
    regStr = "\\d+?";
    Pattern pattern = Pattern.compile(regStr);
    Matcher matcher = pattern.matcher(str);
    while (matcher.find()) {
        System.out.println("找到：" + matcher.group());
    }
}
```

贪婪匹配结果：111111

非贪婪匹配结果：

![image-20211130195455434](/images/Java/JavaSE/23-正则表达式/image-20211130195455434.png)

## 正则匹配实例

### 匹配汉字

```java

    /**
     * 验证是否是一个或者一段汉字
     */
    @Test
    public void run1() {
        String content = "鱼跃此时海，花开彼岸天";
//        汉字的范围，\u4E00-\u9FA5  或者\u0931-uffe5 可以匹配中间的符号之类的
//        [\\u0391-\\uFFE5]匹配双字节字符（汉字+符号）
        String regExp = "^[\\u0391-\\uffe5]+$";
//        至少要有一个汉字，必须为汉字开头，汉字结尾
        Pattern compile = Pattern.compile(regExp);
        if (compile.matcher(content).find()) {
            System.out.println("满足格式");
        } else {
            System.out.println("不满足格式");
        }
    }
```

### 邮政编码

```java
    /**
     * 邮政编码：1~9开头的一个六位数
     */
    @Test
    public void run2() {
        String content = "123456";
        String regExp = "^[1-9]\\d{5}$";
        Pattern compile = Pattern.compile(regExp);
        if (compile.matcher(content).find()) {
            System.out.println("满足格式");
        } else {
            System.out.println("不满足格式");
        }
    }
```

### QQ号码

```java
/**
     * 验证是否是一个QQ号：1~9 开头，5~10位数
     */
@Test
public void run3() {
    String content = "10001";
    String regExp = "^[1-9]\\d{4,9}$";
    Pattern compile = Pattern.compile(regExp);
    if (compile.matcher(content).find()) {
        System.out.println("满足格式");
    } else {
        System.out.println("不满足格式");
    }
}
```

### 手机号码

```java
/**
     * 验证是否为一个手机号：
     * 必须是13 14 15 18 开头的11位数，比如1358889999
     */
@Test
public void run4() {
    String content = "13919991999";
    String regExp = "^1(?:3|4|5|8)\\d{9}$";
    Pattern compile = Pattern.compile(regExp);
    if (compile.matcher(content).find()) {
        System.out.println("满足格式");
    } else {
        System.out.println("不满足格式");
    }

}
```

### URL链接

```java
@Test
public void run5() {
    String content = "https://www.bilibili.com/bangumi/play/ss1600/?from=search&seid=8463112694218139397&spm_id_from=333.337.0.0";
    /*
         * 1. 先确定开始的部分(http|https)://
         * 2. 主题的构成，可以是域名，也可以是IP地址 有. 可能有-_
         * 2.1 \\w匹配它 - 匹配 - \\. 匹配 . + 匹配一个到多个
         * 2.2 [\w-]+ 表示匹配域名的结尾（结尾没有.）
         * 2.2.1  ((http|https)://)? 最后一个问号表示这个协议头可有可无 例如 www.google.com 或者 https://www.google.com 都是可以的
         * 2.3 至此 一个完整的域名验证完毕
         * 3.1  [.] 表示就是匹配一个.  ？同理
         * 3.2  (/[\w-?=&/%#.]*)?  这里匹配后段内容  -?=&/%#. 是可能会出现的符号
         * */
    String regExp = "^((http|https)://)?([\\w-]+\\.)+[\\w-]+(/[\\w-?=&/%#.]*)?$";
    Pattern compile = Pattern.compile(regExp);
    Matcher matcher = compile.matcher(content);
    if (matcher.find()) {
        System.out.println("满足格式");
        System.out.println(matcher.group());
    } else {
        System.out.println("不满足格式");
    }
}
```

### 邮箱

这个是瞎写的，真要用还是去网上抄即可

```java
    /**
     * 验证是否为一个邮箱
     */
    @Test
    public void run6() {
        String content = "amayakite.x@gmail.com";
        String regExp = "^([\\w-.]+)@([\\w-.]+)\\.[\\w]+$";
        Pattern compile = Pattern.compile(regExp);
        Matcher matcher = compile.matcher(content);
        if (matcher.find()) {
            System.out.println("满足格式");
            System.out.println(matcher.group());
        } else {
            System.out.println("不满足格式");
        }
    }
```

## 正则表达式三个常用类

`java.util.regex` 包主要包括如下三个类

- `Pattern`类
- `Mathcer`类
- `PatternSyntaxExeception` 异常类

### Pattern类

`pattern`对象是一个正则表达式对象，Pattern类没有公共构造方法，要创建一个Pattern对象，需要调用其公共静态方法`Pattern.compile(String regExp)`，它返回一个Pattern对象，该方法接受一个正则表达式作为它的第一个参数

### Matcher类

Matcher对象是对输入字符串的解析和匹配的引擎，与Pattern类一样，Matcher也没有公共构造方法，需要调用Pattern对象的matcher方法来获取一个Matcher对象

![image-20211130215948471](/images/Java/JavaSE/23-正则表达式/image-20211130215948471.png)

常用的替换方法

| 方法名                                                           | 说明                                                                                                                        |
| ---------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| `Matcher appendReplacement(StringBuffer sb, String replacement)` | 实现非终端添加和替换步骤。                                                                                                  |
| `StringBuffer appendTail(StringBuffer sb)`                       | 实现终端添加和替换步骤。                                                                                                    |
| `String replaceAll(String replacement)` 比较常用                 | 替换模式与给定替换字符串相匹配的输入序列的每个子序列                                                                        |
| `String replaceFirst(String replacement)`                        | 替换模式与给定替换字符串匹配的输入序列的第一个子序列                                                                        |
| `static String quoteReplacement(String s)`                       | 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的`appendReplacement` 方法一个字面字符串一样工作 |

也可以通过如下方法来直接的返回一个字符串是否能和表达式匹配，匹配返回true，不匹配返回false

一般工作情况下这样用的多，简洁方便（如果想去验证某一个字符串是否满足某一个正则匹配块）

当然，这种方式是整体匹配---传入的字符串必须完全满足该条件才回返回true（regExp中可以不加上^或者&这两个头尾符）

```java
@Test
public void run7() {
    //        演示matcher的独立用法
    String str = "hello world";
    boolean matches = Pattern.matches("hello.*", str);//true
   matches = Pattern.matches("hello", str);//false
    System.out.println(matches);
}
```

### PatternSyntaxExeception

PatternSyntaxExeception是一个非强制异常类，它表示一个正则表达式模式中的语法错误

## 分组、捕获、反向引用

先来看看一个问题:

给你一段文本，找出所有四个数字连接在一起的字符串，并且这四个数字要满足

1. 第一位与第四位相同
2. 第二位与第三位相同
3. 例如：1441 2332

分组和捕获之前已经说过了，大概就是`(?<number1>\\d)` 这样

![image-20211130220750736](/images/Java/JavaSE/23-正则表达式/image-20211130220750736.png)

看到这里，很清晰的就知道，反向引用的语法为：`(\\d)\\1`

也就是：比如说我现在捕获了三个字段

`(\\d)(\\d)(\\d)` 那么我要捕获第一个字段则需要：`(\\d)(\\d)(\\d)\\1`

三个全部捕获即：`(\\d)(\\d)(\\d)\\1\\2\\3`就可以了，1,2,3是根据括号的顺序决定的

这里三个全部捕获能获取到的为：123123、456456、789789等

1. 匹配两个连续相同的数字:`(\\d)\\1`
2. 匹配5个连续相同的数字：`(\\d)\\1{4}`
3. 匹配解决上方问题`(\\d)(\\d)\\2\\1`

放在Java中就是：

```java
@Test
public void run8() {
    String content = "1998 2002 2222 2112 ";
    String regExp = "(\\d)(\\d)\\2\\1";
    Pattern compile = Pattern.compile(regExp);
    Matcher matcher = compile.matcher(content);
    while (matcher.find()) {
        System.out.println("匹配结果：" + matcher.group());
    }
}
```

### 外部反向引用使用-使用外部反向引用解决结巴的问题

先说下，在`matcher.group()`时，也可以通过外部反向引用快速获取，且不需要加上($)号，详情看下面的[扩展-解析出一个URL中的字段](###扩展-解析出一个URL中的字段)

![image-20211130223553382](/images/Java/JavaSE/23-正则表达式/image-20211130223553382.png)

现在有一段话：`我我我我我我我我.....我要.....看看看看......杰哥！`

 ```java
     @Test
     public void run9() {
         String str = "我我我我我我我我.....我要.....看看看看......杰哥！";
 //        1. 去掉所有的.
         String regExp = "\\.";
         Pattern compile = Pattern.compile(regExp);
         Matcher matcher = compile.matcher(str);
 //        使用replaceAll替换符合的字符串
         str = matcher.replaceAll("");
         System.out.println("去掉所有的.后：" + str);
 //        2. 去掉重复的字 . 匹配任意字符
         //分组捕获到的内容会存放到$1
         regExp = "(.)\\1+";
         compile = Pattern.compile(regExp);
         matcher = compile.matcher(str);
         while (matcher.find()) {
             System.out.println("找到重复的字" + matcher.group());
         }
 //        使用外部方向引用替换：我我我我替换为我
         str = matcher.replaceAll("$1");
         System.out.println("去掉所有的重复的字后：" + str);
 
 //        可以使用简化的方式两步完成
         str = "我我我我我我我我.....我要.....看看看看......杰哥！";
 //        先使用一条语句去掉...
         str = Pattern.compile("[.]").matcher(str).replaceAll("");
         System.out.println("简化去重1：" + str);
 
 //        再使用一条语句去掉重复的汉字
         str = Pattern.compile("(.)\\1+").matcher(str).replaceAll("$1");
         System.out.println("简化去重2：" + str);
         //我要看杰哥！
 
     }
 ```

## 在String类中使用正则表达式

String类中的replaceAll是可以直接使用正则表达式替换的

比方说，现在有一段话，我想将其的1.?全部替换为1.8：

```md
2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其获得了Apple公司Mac OS X的工业标准的支持。2001年9月24日，J2EE1.3发布。2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升，与J2SE1.3相比，其多了近62%的类和接口。在这些新特性当中，还提供了广泛的XML支持、安全套接字（Socket）支持（通过SSL与TLS协议）、全新的I/OAPI、正则表达式、日志与断言。2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE 1.5更名为Java SE 5.0（内部版本号1.5.0），代号为“Tiger”，Tiger包含了从1996年发布1.0版本以来的最重大的更新，其中包括泛型支持、基本类型的自动装箱、改进的循环、枚举类型、格式化I/O及可变参数。
```

非常简单：

```java
@Test
public void run10() {
    String str = "......";
    String replaceAll = str.replaceAll("1\\.\\d", "1.8");
    System.out.println(replaceAll);
}
```

也可以通过调用器的matcher方法验证数据：

比方说验证一个手机号，要求必须是138,139开头的手机号

```java
@Test
public void run11(){
    String str ="13969968888";
    boolean matches = str.matches("^(13(?:9|8))+(\\d){8}");
    System.out.println("验证结果："+ matches); //true
}
```

也可以结合split来进行分割数据

比方说，这段话中，通过所有特殊字符进行分割字符串

`11111@22222#33333$44444-55555&66666*77777.88888`

```java
    @Test
    public void run12() {
        String str = "11111@22222#33333$44444-55555&66666*77777.88888";
        String[] split = str.split("[@#$\\-*&.]");
        for (String s : split) {
            System.out.println(s);
        }
    } 
```

## 扩展-验证一个数字是否是整数或者小数

目标：`123 -456 34.89 -87.9 -0.01 0.45`

需要区分正负

```java
@Test
public void run13() {
    String content = "123.456";
    String regExp = "^[-+]?([1-9]\\d*|0)(.\\d+)?$";
    if (content.matches(regExp)) {
        System.out.println("匹配成功 是整数 或小数");
    } else {
        System.out.println("匹配失败");
    }
}
```

解析：`([1-9]\\d*|0)`就是要么以1~9开头任意数量的数字，或者是个0，防止0098这样的事情

## 扩展-解析出一个URL中的字段

![image-20211130234627965](/images/Java/JavaSE/23-正则表达式/image-20211130234627965.png)

思路：分组，分成4个组，然后分别获取对应的值即可

```java
@Test
public void run14() {
    String url = "http://111.111.111.111:8080/user/article?id=1003#title";
    String regExp = "^(?<protocol>http|https)://(?<host>[a-zA-z0-9.]+):(?<port>\\d{2,5})(?<files>[\\w-/]*/[\\w?=#]+)$";
    Pattern compile = Pattern.compile(regExp);
    Matcher matcher = compile.matcher(url);
    //        整体匹配
    if (matcher.matches()) {
        //            外部反向引用
        System.out.println("$protocol:" + matcher.group("protocol"));
        System.out.println("$host:" + matcher.group("host"));
        System.out.println("$port:" + matcher.group("port"));
        System.out.println("$files:" + matcher.group("files"));
    }
}
```

## 扩展-Java正则表达式大全

<https://blog.csdn.net/zpz2411232428/article/details/83549502> 这篇文章上啥都有

```md
一、校验数字的表达式


1 数字：^[0-9]*$
2 n位的数字：^\d{n}$
3 至少n位的数字：^\d{n,}$
4 m-n位的数字：^\d{m,n}$
5 零和非零开头的数字：^(0|[1-9][0-9]*)$
6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
13 非负整数：^\d+$ 或 ^[1-9]\d*|0$
14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$




二、校验字符的表达式


1 汉字：^[\u4e00-\u9fa5]{0,}$
2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
3 长度为3-20的所有字符：^.{3,20}$
4 由26个英文字母组成的字符串：^[A-Za-z]+$
5 由26个大写英文字母组成的字符串：^[A-Z]+$
6 由26个小写英文字母组成的字符串：^[a-z]+$
7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
11 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+
12 禁止输入含有~的字符：[^~\x22]+




三、特殊需求表达式


1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
3 InternetURL：[a-zA-z]+://[^\s]* 或 ^https://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 
6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
7 身份证号：
  15或18位身份证：^\d{15}|\d{18}$
  15位身份证：^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$
  18位身份证：^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$
8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 
12 日期格式：^\d{4}-\d{1,2}-\d{1,2}
13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 
15 钱的输入格式：
16 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
20 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
24 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
26 中文字符的正则表达式：[\u4e00-\u9fa5]
27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)
29 HTML标记的正则表达式：<(\S*?)[^>]*>.*?|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)
32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
```
