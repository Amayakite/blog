const e=JSON.parse('{"key":"v-a20e04fe","path":"/GoLang/Base/05-%E7%BA%BF%E7%A8%8B.html","title":"05-线程","lang":"zh-CN","frontmatter":{"title":"05-线程","date":"2022-02-28T16:03:58.000Z","category":"GoLang","tag":["GoLang","Thread"],"description":"概述 这玩意也是 Go 语言中比较核心的两个东西 为啥说是两个？ Go 语言的线程 在 Go 语言中的并发通过goroutine实现，goroutine并不是真正的系统层面的线程，而是用户态的线程 我们可以更具需求创建上千万个goroutine并发工作，goroutine是由 Go 语言的运行时runtime调度完成 而线程是由操作系统调度完成 GO 语言还提供channel在多个goroutine间进行通讯，goroutine和channel是 Go 语言秉承的 CSP 并发模式的重要实现基础 CSP：Communicating Sequentinal Process","head":[["meta",{"property":"og:url","content":"http://www.amayakite.github.io/GoLang/Base/05-%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"Amayakite Blogs"}],["meta",{"property":"og:title","content":"05-线程"}],["meta",{"property":"og:description","content":"概述 这玩意也是 Go 语言中比较核心的两个东西 为啥说是两个？ Go 语言的线程 在 Go 语言中的并发通过goroutine实现，goroutine并不是真正的系统层面的线程，而是用户态的线程 我们可以更具需求创建上千万个goroutine并发工作，goroutine是由 Go 语言的运行时runtime调度完成 而线程是由操作系统调度完成 GO 语言还提供channel在多个goroutine间进行通讯，goroutine和channel是 Go 语言秉承的 CSP 并发模式的重要实现基础 CSP：Communicating Sequentinal Process"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-17T12:51:48.000Z"}],["meta",{"property":"article:author","content":"Amayakite"}],["meta",{"property":"article:tag","content":"GoLang"}],["meta",{"property":"article:tag","content":"Thread"}],["meta",{"property":"article:published_time","content":"2022-02-28T16:03:58.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-17T12:51:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"05-线程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-02-28T16:03:58.000Z\\",\\"dateModified\\":\\"2023-06-17T12:51:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Amayakite\\",\\"url\\":\\"https://github.com/Amayakite\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"GoRoutine 的概念","slug":"goroutine-的概念","link":"#goroutine-的概念","children":[]},{"level":2,"title":"使用 GoRoutine","slug":"使用-goroutine","link":"#使用-goroutine","children":[{"level":3,"title":"启动单个 GoRoutine","slug":"启动单个-goroutine","link":"#启动单个-goroutine","children":[]},{"level":3,"title":"等待多个线程执行完毕","slug":"等待多个线程执行完毕","link":"#等待多个线程执行完毕","children":[]},{"level":3,"title":"匿名函数来开一个线程","slug":"匿名函数来开一个线程","link":"#匿名函数来开一个线程","children":[]}]},{"level":2,"title":"GoRuntime 原理","slug":"goruntime-原理","link":"#goruntime-原理","children":[]},{"level":2,"title":"Channel","slug":"channel","link":"#channel","children":[{"level":3,"title":"Channel 的类型","slug":"channel-的类型","link":"#channel-的类型","children":[]},{"level":3,"title":"基本使用 Channel","slug":"基本使用-channel","link":"#基本使用-channel","children":[]},{"level":3,"title":"带缓冲和不带缓冲的区别","slug":"带缓冲和不带缓冲的区别","link":"#带缓冲和不带缓冲的区别","children":[]},{"level":3,"title":"Channel 遍历","slug":"channel-遍历","link":"#channel-遍历","children":[]},{"level":3,"title":"单向通道","slug":"单向通道","link":"#单向通道","children":[]}]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[]},{"level":2,"title":"锁","slug":"锁","link":"#锁","children":[{"level":3,"title":"互斥锁","slug":"互斥锁","link":"#互斥锁","children":[]},{"level":3,"title":"读写锁","slug":"读写锁","link":"#读写锁","children":[]},{"level":3,"title":"WaitGroup信号量","slug":"waitgroup信号量","link":"#waitgroup信号量","children":[]},{"level":3,"title":"Sync.Once","slug":"sync-once","link":"#sync-once","children":[]},{"level":3,"title":"Sync.Map","slug":"sync-map","link":"#sync-map","children":[]},{"level":3,"title":"原子操作","slug":"原子操作","link":"#原子操作","children":[]}]}],"git":{"createdTime":1687006308000,"updatedTime":1687006308000,"contributors":[{"name":"Amayakite","email":"amayakite@qq.com","commits":1}]},"readingTime":{"minutes":22.13,"words":6638},"filePathRelative":"GoLang/Base/05-线程.md","localizedDate":"2022年2月28日","excerpt":"<h2> 概述</h2>\\n<p>这玩意也是 Go 语言中比较核心的两个东西</p>\\n<p>为啥说是两个？</p>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">Go 语言的线程</p>\\n<p>在 Go 语言中的并发通过<code>goroutine</code>实现，<code>goroutine</code>并不是真正的系统层面的线程，而是用户态的线程</p>\\n<p>我们可以更具需求创建上千万个<code>goroutine</code>并发工作，<code>goroutine</code>是由 Go 语言的运行时<code>runtime</code>调度完成</p>\\n<p>而线程是由操作系统调度完成</p>\\n<p>GO 语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通讯，<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP 并发模式的重要实现基础</p>\\n<p>CSP：Communicating Sequentinal Process</p>\\n</div>","autoDesc":true}');export{e as data};
