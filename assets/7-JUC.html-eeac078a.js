const e=JSON.parse('{"key":"v-1d256216","path":"/JavaLang/Thread/7-JUC.html","title":"7-JUC","lang":"zh-CN","frontmatter":{"title":"7-JUC","date":"2022-01-18T15:52:30.000Z","category":"Thread","tag":["Java","JavaSE","Thread"],"description":"JUC概述 这玩意是这个java.util.concurrent包的简称，是Java给我们提供的一个并发编程的工具包。 里面有非常多的工具类 AQS 为什么要先说这个？它是一个抽象的接口java.util.concurrent.locks.AbstractQueuedSynchronizer。 翻译过来就是阻塞式锁和相关同步器工具的框架 其他工具都是基于它来实现的 用state来表示资源的状态(分为独享模式和共享模式)，子类需要定义和维护这个状态，控制如何获取锁和释放锁 getState()-获取状态 setState(int newState)-设置状态 compareAndSetState(int expect, int update)-比较状态，如果相等就更新状态 独占模式是只有一个线程能获取锁，共享模式是多个线程能获取锁 提供了基于FIFO的等待队列，类似于Monitor的EntryList 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor的WaitSet","head":[["meta",{"property":"og:url","content":"http://www.amayakite.github.io/JavaLang/Thread/7-JUC.html"}],["meta",{"property":"og:site_name","content":"Amayakite Blogs"}],["meta",{"property":"og:title","content":"7-JUC"}],["meta",{"property":"og:description","content":"JUC概述 这玩意是这个java.util.concurrent包的简称，是Java给我们提供的一个并发编程的工具包。 里面有非常多的工具类 AQS 为什么要先说这个？它是一个抽象的接口java.util.concurrent.locks.AbstractQueuedSynchronizer。 翻译过来就是阻塞式锁和相关同步器工具的框架 其他工具都是基于它来实现的 用state来表示资源的状态(分为独享模式和共享模式)，子类需要定义和维护这个状态，控制如何获取锁和释放锁 getState()-获取状态 setState(int newState)-设置状态 compareAndSetState(int expect, int update)-比较状态，如果相等就更新状态 独占模式是只有一个线程能获取锁，共享模式是多个线程能获取锁 提供了基于FIFO的等待队列，类似于Monitor的EntryList 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor的WaitSet"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-17T12:51:48.000Z"}],["meta",{"property":"article:author","content":"Amayakite"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaSE"}],["meta",{"property":"article:tag","content":"Thread"}],["meta",{"property":"article:published_time","content":"2022-01-18T15:52:30.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-17T12:51:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"7-JUC\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-18T15:52:30.000Z\\",\\"dateModified\\":\\"2023-06-17T12:51:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Amayakite\\",\\"url\\":\\"https://github.com/Amayakite\\"}]}"]]},"headers":[{"level":2,"title":"JUC概述","slug":"juc概述","link":"#juc概述","children":[]},{"level":2,"title":"AQS","slug":"aqs","link":"#aqs","children":[{"level":3,"title":"利用AbstractQueuedSynchronizer自定义锁","slug":"利用abstractqueuedsynchronizer自定义锁","link":"#利用abstractqueuedsynchronizer自定义锁","children":[]}]},{"level":2,"title":"公平锁和非公平锁的区别","slug":"公平锁和非公平锁的区别","link":"#公平锁和非公平锁的区别","children":[]},{"level":2,"title":"读写锁","slug":"读写锁","link":"#读写锁","children":[{"level":3,"title":"ReentrantReadWriteLock","slug":"reentrantreadwritelock","link":"#reentrantreadwritelock","children":[]},{"level":3,"title":"ReentrantReadWriteLock注意事项","slug":"reentrantreadwritelock注意事项","link":"#reentrantreadwritelock注意事项","children":[]},{"level":3,"title":"缓存的应用-数据库的查询缓存","slug":"缓存的应用-数据库的查询缓存","link":"#缓存的应用-数据库的查询缓存","children":[]},{"level":3,"title":"简单实现-不涉及锁","slug":"简单实现-不涉及锁","link":"#简单实现-不涉及锁","children":[]},{"level":3,"title":"缓存更新策略-问题分析","slug":"缓存更新策略-问题分析","link":"#缓存更新策略-问题分析","children":[]},{"level":3,"title":"缓存更新策略-实现","slug":"缓存更新策略-实现","link":"#缓存更新策略-实现","children":[]},{"level":3,"title":"StampedLock","slug":"stampedlock","link":"#stampedlock","children":[]}]},{"level":2,"title":"Semaphore-控制访问量","slug":"semaphore-控制访问量","link":"#semaphore-控制访问量","children":[]},{"level":2,"title":"CountdownLatch-倒计时锁","slug":"countdownlatch-倒计时锁","link":"#countdownlatch-倒计时锁","children":[{"level":3,"title":"基本使用","slug":"基本使用","link":"#基本使用","children":[]},{"level":3,"title":"CountdownLatch实例：在分布式服务中分布式的获取结果","slug":"countdownlatch实例-在分布式服务中分布式的获取结果","link":"#countdownlatch实例-在分布式服务中分布式的获取结果","children":[]}]},{"level":2,"title":"CyclicBarrier-循环栅栏-可以重用的CountdownLatch","slug":"cyclicbarrier-循环栅栏-可以重用的countdownlatch","link":"#cyclicbarrier-循环栅栏-可以重用的countdownlatch","children":[{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":3,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]}]},{"level":2,"title":"线程安全集合类","slug":"线程安全集合类","link":"#线程安全集合类","children":[]},{"level":2,"title":"ConcurrentHashMap","slug":"concurrenthashmap","link":"#concurrenthashmap","children":[]},{"level":2,"title":"Concurrent的方法一览","slug":"concurrent的方法一览","link":"#concurrent的方法一览","children":[]},{"level":2,"title":"CurrentLinkedQueue","slug":"currentlinkedqueue","link":"#currentlinkedqueue","children":[]}],"git":{"createdTime":1687006308000,"updatedTime":1687006308000,"contributors":[{"name":"Amayakite","email":"amayakite@qq.com","commits":1}]},"readingTime":{"minutes":23.95,"words":7186},"filePathRelative":"JavaLang/Thread/7-JUC.md","localizedDate":"2022年1月18日","excerpt":"<h2> JUC概述</h2>\\n<p>这玩意是这个<code>java.util.concurrent</code>包的简称，是Java给我们提供的一个并发编程的工具包。</p>\\n<p>里面有非常多的工具类</p>\\n<h2> AQS</h2>\\n<p>为什么要先说这个？它是一个抽象的接口<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>。</p>\\n<p>翻译过来就是阻塞式锁和相关同步器工具的框架</p>\\n<p>其他工具都是基于它来实现的</p>\\n<ul>\\n<li>用state来表示资源的状态(分为独享模式和共享模式)，子类需要定义和维护这个状态，控制如何获取锁和释放锁\\n<ul>\\n<li>getState()-获取状态</li>\\n<li>setState(int newState)-设置状态</li>\\n<li>compareAndSetState(int expect, int update)-比较状态，如果相等就更新状态</li>\\n<li>独占模式是只有一个线程能获取锁，共享模式是多个线程能获取锁</li>\\n</ul>\\n</li>\\n<li>提供了基于FIFO的等待队列，类似于Monitor的EntryList</li>\\n<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</li>\\n</ul>","autoDesc":true}');export{e as data};
