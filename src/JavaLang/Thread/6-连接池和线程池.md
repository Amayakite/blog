---
title: 6-连接池和线程池
date: 2022-1-17 17:23:30
category: Thread
tag:
- Java
- JavaSE
- Thread
---

## 自定义一个连接池

### 为啥需要连接池？

例如：一个线上商城应用，QPS达到数千，如果每次请求都重新创建连接和关闭数据库，性能会收到极大的影响，此时如果预先创建好了一批连接，放入连接池。
一次请求到达后，从连接池获取连接，使用完数据后再还给连接池，这样既解约了创建和关闭连接的开销，也实现了连接的重用，不止于让庞大的数据压垮数据库

### 制作一个简单的连接池

这里面的MockConnection是一个自己实现了Connection的类，里面加了个name属性，和一个name属性的构造方法，没有实现其他的任何代码

```java

@Slf4j(topic = "c.MySqlPool")
public class MyPool {

    /**
     * 连接池大小
     */
    private final int poolSize;

    /**
     * 连接对象数组(sql)
     */
    private Connection[] connection;

    /**
     * 连接状态数组 0表示空闲 1表示占用 使用线程安全的数组
     */
    private AtomicIntegerArray states;

    /**
     * 构造方法初始化---给对应的数组赋值
     *
     * @param poolSize 连接池大小
     */
    public MyPool(int poolSize) {
        this.poolSize = poolSize;
        this.connection = new Connection[poolSize];
        this.states = new AtomicIntegerArray(new int[poolSize]);
        for (int i = 0; i < poolSize; i++) {
            connection[i] = new MockConnection("Connection" + i);
        }
    }

    /**
     * 借连接
     */
    public Connection borrow() {
//        先看看哪些连接是空闲的
        while (true) {
            for (int i = 0; i < poolSize; i++) {
                if (states.get(i) == 0) {
//                 尝试赋值，赋值成功返回该链接
                    if (states.compareAndSet(i, 0, 1)) {
                        log.debug("借出了链接{}", i);
                        return connection[i];
                    }
                }
            }
//            如果没有空闲的连接，则等待
            synchronized (this) {
                try {
                    log.debug("没有空闲的连接，等待中");
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * 归还连接
     *
     * @param connection 连接对象
     */
    public void free(Connection connection) {
        for (int i = 0; i < poolSize; i++) {
            if (connection == this.connection[i]) {
//                这里只有归还的线程有权限去修改状态，其他的线程不能修改状态 所以线程是安全的
                states.set(i, 0);
                log.debug("归还了链接{}", i);
//                唤醒连接
                synchronized (this) {
                    this.notifyAll();
                }
                break;
            }
        }

    }
}
```

连接类如下图所示

![连接池类](/images/Java/JavaThread/6-连接池和线程池/1642421665322.png)

接下来测试下

```java

@Slf4j
public class TestPool {
    public static void main(String[] args) {
        MyPool myPool = new MyPool(2);
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
//                获取连接
                log.info("线程{}开始获取连接", Thread.currentThread().getName());
                Connection borrow = myPool.borrow();
                log.info("线程{}获取连接成功，连接是{}", Thread.currentThread().getName(), borrow);
//                执行操作 假装这里查询用了5s
                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
//                    归还连接
                    log.info("线程{}用完了连接，现在归还连接{}", Thread.currentThread().getName(), borrow);
                    myPool.free(borrow);
                }
            }, "t" + i).start();
        }
    }
}
```

![结果](/images/Java/JavaThread/6-连接池和线程池/1642421715005.png)

可以看到，非常成功的运行了

当然我们这个连接池目前来说还没有考虑：

- 连接的动态增长和收缩
- 连接保活（可用性检测）
- 等待超时处理
- 分布式hash

对于关系型数据库，有比较成熟地连接池实现，例如C3P0，Druid、还有Spring自带的那个全球最快的连接池等

对于更通用的对象池，也有Apache的 commons pool，例如redis可以参考jedis中关于连接池的实现

## 自定义线程池

### 为什么要有线程池

实际上，我们线程在CPU之间的上下文切换都是需要代价的(这里就不多做展开说明了，Go lang语言之父发布过线程的上下文切换代价的视频，说的非常详细)

每当线程切换的时候，CPU都需要对齐当前的状态进行保存（也就是存储一个快照），下次时间片分配回给这个线程的时候，再通过这个快照恢复线程

所以说，当我们的线程多于一定的阀值的时候，CPU往往在上下文切换上下花的时间比我们执行的时间可能都要多..

得出结论：我们不应该在每次任务来的时候都创建新的线程，而是充分利用已有线程，让他们更好地处理当前业务

这个时候，就需要线程池来帮我们管理总线程数量，让CPU保证最高效的运行

我目前的思路：利用线程的waiting，来完成线程池---利用函数式接口之类的，完成动态的任务传递

![线程池](/images/Java/JavaThread/6-连接池和线程池/1642423109119.png)

### 自定义线程池-阻塞队列

```java
package com.Project.myqueue;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author Amayakite
 * @version 1.0.0
 * @date 2022/1/17 20:40
 * @since 1.8
 */
@Slf4j(topic = "c.BlockingQueue")
public class BlockingQueue<T> {

    /**
     * 1. 任务队列，Deque是一个双向链表，可以往前面和后面添加元素
     * 它的实现类中，ArrayDeque性能较好
     */
    private final Deque<T> queue = new ArrayDeque<>();

    /**
     * 2. 锁
     */
    private final ReentrantLock lock = new ReentrantLock();

    /**
     * 生产者条件变量
     */
    private final Condition fullWaitCondition = lock.newCondition();

    /**
     * 消费者条件变量
     */
    private final Condition emptyWaitCondition = lock.newCondition();

    /**
     * 容量
     */
    private int capacity;

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }

    /**
     * 带超时的阻塞获取
     *
     * @param timeout 等待时间
     * @param unit    等待的时间单位
     * @return T
     */
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();
        try {
//            将超时时间统一转换为纳秒
            long nanos = unit.toNanos(timeout);
//            获取当前时间
            long start = System.nanoTime();
//            队列是否为空
            while (queue.isEmpty()) {
                try {
                    if (nanos <= 0) {
//                        如果说超时了或者传入负数，就返回null
                        return null;
                    }
//                    为空则进入等待 这个方法会自动计算剩余时间（也就是总共时间减去已用时间会作为返回值返回），防止虚假唤醒导致
                    nanos = emptyWaitCondition.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
//                如果被虚假唤醒了，则重新计算超时时间
            }
//            通知生产者可以继续存入元素了
            fullWaitCondition.signalAll();
//            获取队列头部元素
            return queue.removeFirst();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 阻塞获取 没有超时时间
     *
     * @return T
     */
    public T take() {
        lock.lock();
        try {
//            队列是否为空
            while (queue.isEmpty()) {
                try {
//                    为空则进入等待
                    emptyWaitCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
//            通知生产者可以继续存入元素了
            fullWaitCondition.signalAll();
//            获取队列头部元素
            return queue.removeFirst();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 阻塞添加 没有超时时间
     *
     * @param task 对象
     */
    public void put(T task) {
        lock.lock();
        try {
//            队列是否已满
            while (queue.size() == capacity) {
                try {
//                    已满则进入等待
                    fullWaitCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
//            将新的元素添加到队列尾部
            queue.add(task);
            log.debug("任务加入任务队列成功:{}", task);
//            唤醒一位消费者
            emptyWaitCondition.signal();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 带超时时间的阻塞添加
     *
     * @return 布尔值，true表示添加成功
     */
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
//            队列是否已满
            while (queue.size() == capacity) {
                try {
                    if (nanos <= 0) {
                        return false;
                    }
//                    已满则进入等待
                    nanos = fullWaitCondition.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
//            将新的元素添加到队列尾部
            queue.add(task);
//            唤醒一位消费者
            emptyWaitCondition.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }


    /**
     * 获取大小
     *
     * @return int
     */
    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 自定义拒绝策略
     *
     * @param rejectPolicy 拒绝策略
     * @param task         实例对象
     */
    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
//            判断队列是否满了
            if (queue.size() == capacity) {
//                满了
                rejectPolicy.reject(this, (Runnable) task);
            } else {
//                有空闲
                queue.add(task);
//                通知消费者
                emptyWaitCondition.signal();
            }

        } finally {
            lock.unlock();
        }
    }
}
```

### 自定义线程池-拒绝策略接口

```java
package com.Project.myqueue;

/**
 * @author Amayakite
 * @version 1.0.0
 * @date 2022/1/17 22:01
 * @since 1.8
 */
@FunctionalInterface
public interface RejectPolicy<T> {

    void reject(BlockingQueue<T> queue, Runnable task);
}
```

### 自定义线程池-线程池类

```java
package com.Project.myqueue;

import lombok.extern.slf4j.Slf4j;

import java.util.HashSet;
import java.util.concurrent.TimeUnit;

/**
 * @author Amayakite
 * @version 1.0.0
 * @date 2022/1/17 21:02
 * @since 1.8
 */
@Slf4j(topic = "c.ThreadPool")
public class ThreadPool {
    /**
     * 阻塞队列，泛型是Runnable，方便更好的传入各种类型的线程对象
     */
    private BlockingQueue<Runnable> taskQueue;

    /**
     * 线程集合
     */
    private final HashSet<Worker> workers = new HashSet<>();

    /**
     * 核心的线程数量
     */
    private int coreSize;

    /**
     * 获取任务的超时时间
     */
    private long timeout;

    /**
     * 超时时间的单位
     */
    private TimeUnit timeUnit;

    private RejectPolicy<Runnable> rejectPolicy;

    /**
     * 创建一个线程池
     *
     * @param coreSize  核心的线程数量
     * @param timeout   超时时间
     * @param timeUnit  超市单位
     * @param queueSize 阻塞队列的长度上限
     */
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueSize) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue = new BlockingQueue<>(queueSize);
        log.debug("创建线程池完毕");
    }

    /**
     * 创建线程池 同时自定义拒绝策略
     *
     * @param coreSize     核心的线程数量
     * @param timeout      超时时间
     * @param timeUnit     超时时间的单位
     * @param queueSize    阻塞队列的长度上限
     * @param rejectPolicy 拒绝策略
     */
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueSize, RejectPolicy<Runnable> rejectPolicy) {
        this(coreSize, timeout, timeUnit, queueSize);
        this.rejectPolicy = rejectPolicy;
    }

    /**
     * 执行任务
     *
     * @param task 任务对象
     */
    public void execute(Runnable task) {
        synchronized (workers) {
//        判断任务数量是否超过核心线程数量(coreSize) 如果没有超过，直接交给Worker执行
//        如果超过了,则加入任务队列暂存
            if (workers.size() < coreSize) {

//            创建任务对象
                Worker worker = new Worker(task);
                log.debug("新增worker:{},任务为：{}", worker, task);
//            加入到任务队列
                workers.add(worker);
//            启动线程
                worker.start();
            } else {
//                加入任务队列
                log.debug("试图任务加入任务队列:{}", task);
//                1. 死等
//                2. 带超时时间的等待
//                3. 让主线程放弃任务的执行
//                4. 抛出异常
//                5. 让调用者自己执行任务
//                等等等等，太多选择了，应该把决策权交给线程的使用者，而不是写死在代码当中
                if (this.rejectPolicy == null) {
//                    如果没有传入拒绝策略，则走死等路线
                    taskQueue.take();
                } else {
//                否则，调用自定义的拒绝策略
                    taskQueue.tryPut(rejectPolicy, task);
                }
            }
        }
    }

    class Worker extends Thread {
        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }

        @Override
        public void run() {
//            执行任务
//            1 当task不为空，执行任务
//            2 当task执行完毕，再接着从任务队列获来获取任务并执行
            while (task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
                try {
                    log.debug("正在执行：{}", task);
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
//                    线程已经执行完毕
                    task = null;
                }
            }
//            当实在是没有任务要走的时候，从workers内移除当前Worker
            synchronized (workers) {
                log.debug("移除worker:{}", this);
                workers.remove(this);
            }
        }
    }
}
```

### 测试

```java
package com.Project.myqueue;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;

/**
 * @author Amayakite
 * @version 1.0.0
 * @date 2022/1/17 21:23
 * @since 1.8
 */
@Slf4j(topic = "c.TestPool")
public class TestPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(2, 1, TimeUnit.SECONDS, 10,
                (queue, task) -> {
//                   死等
//                    queue.put(task);

//                   超时策略
                    boolean offer = queue.offer(task, 3, TimeUnit.SECONDS);
                    if (!offer) {
                        log.error("任务队列已满，拒绝执行任务：{}", task);
                    } else {
                        log.info("任务已提交：{}", task);
                    }

//                    让调用者放弃任务，并抛出runtime异常 注意这样会让剩余的任务都不会执行
//                    throw new RuntimeException("任务队列已满，拒绝执行任务：" + task);

//                    让调用者自己执行任务
//                    task.run();

                }
        );
        int change = 20;
        for (int i = 0; i < change; i++) {
            int j = i;
            threadPool.execute(() -> {
                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("{}", j);
            });
        }
    }
}
```

运行结果：完美运行

![运行结果](/images/Java/JavaThread/6-连接池和线程池/1642430671515.png)

## ThreadPoolExecutor

这是JUC工具包提供给我们的线程池工具，非常好用

包结构如下

![包结构](/images/Java/JavaThread/6-连接池和线程池/1642431209830.png)

### 线程池的状态

ThreadPoolExecutor使用int的高三位表示线程池的状态，低29位表示线程池数量

| 状态名     | 高三位 | 接收新任务 | 处理阻塞队列任务 | 说明                                         |
| ---------- | ------ | ---------- | ---------------- | -------------------------------------------- |
| RUNNING    | 111    | Y          | Y                |                                              |
| SHUTDOWN   | 000    | N          | Y                | 不会接受新的任务，但会处理阻塞队列剩余的任务 |
| STOP       | 001    | N          | N                | 会中断正在执行的任务，并抛弃阻塞队列的任务   |
| TIDYING    | 010    |            |                  | 任务全部执行完毕后，活动线程为0进入终结      |
| TERMINATED | 011    |            |                  | 终结状态                                     |

从数字上比较：`TERMINATED>TIDYING>STOP>SHUTDOWN>RUNNING`

这些信息存储在一个原子变量`cti`内，目的是将线程池状态和线程个数合二为一，这样就可以用一次cas原子操作进行赋值

![ctl](/images/Java/JavaThread/6-连接池和线程池/1642431833353.png)

### 构造方法

```java {2-8}
public ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler) 
{
    //....do something
}
```

它的构造方法接收如上参数

- `corePoolSize`核心线程数量（最多保留的线程数）
- `maximumPoolSize`（最大线程数量）
- `keepAliveTime`（线程存活时间-针对急救性线程）
- `unit` 时间单位-针对急救线程
- `workQueue` 阻塞队列
- `threadFactory` 线程工厂：可以为每个线程创建时起一个名字
- `handler` 拒绝策略

构造相当多，当然它也有一些更少参数的重载

工作原理

![原理](/images/Java/JavaThread/6-连接池和线程池/1642432319353.png)

1. 上图中`c`表示核心线程的数量，`m`表示最大线程的数量
    1. 最大线程相当于是**核心线程数**加上**救急线程数**
    2. 也就是相当于除了我们的核心线程数2个之外，还可以有一个救急线程
2. 他们都是懒加载机制（用到了才会创建）

接下来我们来一个任务，进入到线程池内执行，将会产生如下结果

![核心线程](/images/Java/JavaThread/6-连接池和线程池/1642432512207.png)

这个时候如果又来了个任务，就要启动核心线程2去执行这个任务

![线程2](/images/Java/JavaThread/6-连接池和线程池/1642432594023.png)

但假设此时又来了个线程3，那么这个线程将会进入阻塞队列

![阻塞队列](/images/Java/JavaThread/6-连接池和线程池/1642432625184.png)

假设我们这里阻塞队列的长度是2，那么阻塞队列还能放的下

![阻塞队列-2](/images/Java/JavaThread/6-连接池和线程池/1642432653347.png)

那如果我们此时再来一个任务会发生什么呢？

> 此时JUC的线程池并不会去执行拒绝策略，而是会先看看，我们是否有可用的救急线程，如果有的话，就启用救急线程，并将**新来的**任务交给救急线程去执行

![救急线程](/images/Java/JavaThread/6-连接池和线程池/1642432769864.png)

那么这个救急任务在执行完了之后会做什么呢？注意到了前面的一个参数吗？`keepAliveTime`---这是救急线程的存活时间

也就是说，只要这个救急线程在一定的时间内是处于空闲的状态，那么线程池将会关闭掉它

但**核心线程**是永远都不会结束的，只要这个程序还在run，对应的线程就会一直存在...即使没有任何任务了

> 如果此时再来一个线程将会发生什么呢？

再来一个线程，将会执行拒绝策略....因为此时没有任何线程可以给它用了

总结来说就是这样的：

![总结](/images/Java/JavaThread/6-连接池和线程池/1642433217038.png)

ThreadPoolExecutor的拒绝策略是由RejectExecutionHandler这个接口来展开的，它有四个现成的拒绝策略

![拒绝策略](/images/Java/JavaThread/6-连接池和线程池/1642433318465.png)

默认是AbortPolicy抛出异常的方式来返回给客户端

> 根据这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种线程

### newFixedThreadPool

```java {3-8}
 public static ExecutorService newFixedThreadPool(int nThreads) {
     return new ThreadPoolExecutor(
         nThreads,
         nThreads,
         0L, 
         TimeUnit.MILLISECONDS,
         new LinkedBlockingQueue<Runnable>()
     );
 }
```

> 特点

- 核心线程数=最大线程数（没有急救线程被创建），因此也无需超时时间
- 阻塞队列是无界的，可以放置任意数量的任务
    - 适用于**已知任务量**，但是相对耗时的任务

使用比较简单，只需要：

```java
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author Amayakite
 * @version 1.0.0
 * @date 2022/1/17 23:40
 * @since 1.8
 */
@Slf4j(topic = "c.TestThreadPoolExecutors")
public class TestThreadPoolExecutors {
    public static void main(String[] args) {
//        创建连接池，并设定大小为2
        ExecutorService pool = Executors.newFixedThreadPool(2);
        for (int i = 0; i < 10; i++) {
            int finalI = i;
//            轮循执行任务
            pool.execute(() -> log.debug(String.valueOf(finalI)));
        }
    }
}
```

执行结果：

```text
23:42:51.820 [pool-1-thread-2] DEBUG c.TestThreadPoolExecutors - 1
23:42:51.820 [pool-1-thread-1] DEBUG c.TestThreadPoolExecutors - 0
23:42:51.825 [pool-1-thread-1] DEBUG c.TestThreadPoolExecutors - 3
23:42:51.825 [pool-1-thread-2] DEBUG c.TestThreadPoolExecutors - 2
23:42:51.825 [pool-1-thread-1] DEBUG c.TestThreadPoolExecutors - 4
23:42:51.825 [pool-1-thread-1] DEBUG c.TestThreadPoolExecutors - 6
23:42:51.825 [pool-1-thread-2] DEBUG c.TestThreadPoolExecutors - 5
23:42:51.825 [pool-1-thread-1] DEBUG c.TestThreadPoolExecutors - 7
23:42:51.825 [pool-1-thread-2] DEBUG c.TestThreadPoolExecutors - 8
23:42:51.825 [pool-1-thread-1] DEBUG c.TestThreadPoolExecutors - 9
```

可以看到，整体来说都是比较有规律的，是两个两个的连在一块执行

但是要注意的一点是：因为使用的全都是核心线程池内的线程，使用结束后，他们并不会去主动的结束自己...所以如果你run起来会发现你的程序到现在为止还没有退出

![还在运行](/images/Java/JavaThread/6-连接池和线程池/1642434429674.png)

至于如何结束，之后会说到，先手动kill吧

并且可以发现，它的取名规则为`pool-{number}-thread-{number}`，我们是不是可以自己取一个好听的名字呢？当然是可以的，只需要使用threadFactory工厂即可

```java

@Slf4j(topic = "c.TestThreadPoolExecutors")
public class TestThreadPoolExecutors {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(2, new ThreadFactory() {
            private AtomicInteger t = new AtomicInteger(1);

            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, "myPool-" + t.getAndIncrement());
            }
        });
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            pool.execute(() -> log.debug(String.valueOf(finalI)));
        }
    }
}
```

运行结果：

```text
23:52:46.387 [myPool-1] DEBUG c.TestThreadPoolExecutors - 0
23:52:46.387 [myPool-2] DEBUG c.TestThreadPoolExecutors - 1
23:52:46.392 [myPool-1] DEBUG c.TestThreadPoolExecutors - 2
23:52:46.392 [myPool-2] DEBUG c.TestThreadPoolExecutors - 3
23:52:46.392 [myPool-1] DEBUG c.TestThreadPoolExecutors - 4
23:52:46.392 [myPool-1] DEBUG c.TestThreadPoolExecutors - 6
23:52:46.392 [myPool-2] DEBUG c.TestThreadPoolExecutors - 5
23:52:46.392 [myPool-1] DEBUG c.TestThreadPoolExecutors - 7
23:52:46.392 [myPool-2] DEBUG c.TestThreadPoolExecutors - 8
23:52:46.392 [myPool-1] DEBUG c.TestThreadPoolExecutors - 9
```

### newCachedThreadPool

翻译过来就是带有缓冲功能的线程池，构造方法如下

```java {3-8}
public static ExecutorService newCachedThreadPool(){
    return new ThreadPoolExecutor(
        0,
        Integer.MAX_VALUE,
        60L,
        TimeUnit.SECONDS,
        new SynchronousQueue<Runnable>()
    );
}
```

创建：`Executors.newCachedThreadPool()`

> 特点

- 核心线程数都是0，最大线程数是`Integer.MAX_VALUE`，急救线程的空闲生存时间是60s，意味着
    - 全部线程都是急救线程（60s之后会回收）
    - 急救线程可以无限的创建
- 队列采用了`SynchronousQueue`实现，特点是
    - 它没有容量，**没有线程来取是放不进去的**（一手交钱，一手交货）

关于`SynchronousQueue`,这里举一个例子来演示下,相当于里面可以存储任意类型的数据，但是得有人取出来，不然放进去后的一瞬间，该线程将会被堵塞

```java

@Slf4j(topic = "c.TestThreadPoolExecutors")
public class TestThreadPoolExecutors {
    public static void main(String[] args) throws InterruptedException {
        SynchronousQueue<Integer> integers = new SynchronousQueue<>();
        new Thread(() -> {
            try {
                log.debug("putting:{}", 1);
                integers.put(1);
                log.debug("putted:{}...", 1);

                log.debug("putting:{}", 2);
                integers.put(2);
                log.debug("putted:{}...", 2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                log.debug("taking:{}", 1);
                integers.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t2").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            try {
                log.debug("taking:{}", 2);
                integers.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t3").start();


    }
}
```

运行结果：

```text
00:14:22.092 [t1] DEBUG c.TestThreadPoolExecutors - putting:1
00:14:23.097 [t2] DEBUG c.TestThreadPoolExecutors - taking:1
00:14:23.097 [t1] DEBUG c.TestThreadPoolExecutors - putted:1...
00:14:23.097 [t1] DEBUG c.TestThreadPoolExecutors - putting:2
00:14:24.104 [t3] DEBUG c.TestThreadPoolExecutors - taking:2
00:14:24.104 [t1] DEBUG c.TestThreadPoolExecutors - putted:2...
```

可以看到，非常有规律的put和taking，t1线程也一直在等着...

### newSingleThreadExecutor

```java {3-12}
public static ExecutorService newSingleThreadExecutor(){
    return new FinalizableDelegatedExecutorService
    (
        new ThreadPoolExecutor(
            1,
            1,
            0L,
            TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>()
        )
    );
}
```

创建：`Executors.newSingleThreadExecutor()`

使用场景：

> 希望多个任务排队执行，线程数固定为1，任务数多余1的时候，会被放入**无界队列**排队，任务执行完毕，这唯一的线程也不会被释放

区别：

- 自己创建一个单线程串行执行任务，如果执行任务失败而终止那么没有任何补偿，而线程池还会创建一个线程，保证池的正常工作
- `Executors.newSingleThreadExecutor`的线程个数始终为1，不能修改
    - `FinalizableDelegatedExecutorService`应用的是装饰器模式，只对外暴露了`ExecutorService`接口，因此不能调用`ThreadPoolExecutor`中特有的方法
- `Executors.newFixedThreadPool(1)` 初始为1，后续还可以修改
    - 对外暴露的是`ThreadPoolExecutor`对象，可以强转后调用`setCorePoolSize`等方法进行修改

接下来使用下

```java
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author Amayakite
 * @version 1.0.0
 * @date 2022/1/17 23:40
 * @since 1.8
 */
@Slf4j(topic = "c.TestThreadPoolExecutors")
public class TestThreadPoolExecutors {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService pool = Executors.newSingleThreadExecutor();
        pool.execute(() -> {
            log.info("1");
            int i = 1 / 0;
        });

        pool.execute(() -> {
            log.info("2");
        });

        pool.execute(() -> {
            log.info("3");
        });
    }
}
```

接着运行：可以看到，虽然说我们的第一个代码出现异常了，但是后面的任务依旧能够正常运行，并且切换成了另外一个线程

```text
00:38:15.259 [pool-1-thread-1] INFO c.TestThreadPoolExecutors - 1
00:38:15.263 [pool-1-thread-2] INFO c.TestThreadPoolExecutors - 2
00:38:15.263 [pool-1-thread-2] INFO c.TestThreadPoolExecutors - 3
Exception in thread "pool-1-thread-1" java.lang.ArithmeticException: / by zero
	at com.Project.jdkpool.TestThreadPoolExecutors.lambda$main$0(TestThreadPoolExecutors.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
```

## 线程池的提交任务

### 方法一览

总共有如下方法可以给线程池提交任务

```java

//执行任务
void execute(Runnable command);

//提交任务为Task，用返回值Future获取执行任务结果
<T> Future<T> submit(Callable<T> command);

//提交tasks中的所有任务
<T> List<Future<T>>invokeAll(Collection<?extends Callable<T>> tasks)throws InterruptedException;

//提交tasks中的所有任务，带有超时时间
<T> List<Future<T>>invokeAll(Collection<?extends Callable> tasks,long timeout,TimeUnit unit)throws InterruptedException;

//提交tasks中的所有任务，哪个任务先执行完毕，返回此任务的结果，其他任务取消
<T> T invokeAny(Collection<?extends Callable<T>> tasks)throws InterruptedException,ExecutionException;

//提交tasks中的所有任务，哪个任务先执行完毕，返回此任务的结果，其他任务取消，带超时时间
<T> T invokeAny(Collection<?extends Callable> tasks,long timeout,TimeUnit unit)throws InterruptedException,ExecutionException;
```

### 提交线程-submit

使用非常简单，只需要知道可以用它来获取返回结果即可，接收使用Future的get即可

```java

@Slf4j(topic = "c.TestThreadPoolExecutors")
public class TestThreadPoolExecutors {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        Future<String> submit = pool.submit(new Callable<String>() {
            @Override
            public String call() throws Exception {
                Thread.sleep(1000);
                return "hello";
            }
        });
//        使用Future就可以获取结果了
        log.info("{}", submit.get());
    }
}
```

运行结果：

```text
00:54:28.326 [main] INFO c.TestThreadPoolExecutors - hello
```

当然，因为`Callable<T>`也是一个单例的接口，所以可以使用`lambda`表达式来简化语法

```java {6-9}
@Slf4j(topic = "c.TestThreadPoolExecutors")
public class TestThreadPoolExecutors {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        Future<String> submit = pool.submit(() -> {
            Thread.sleep(1000);
            return "hello";
        });
//        使用Future就可以获取结果了
        log.info("{}", submit.get());
    }
}
```

### 提交任务之一次性提交多个任务-invokeAll和invokeAny

它们有两种，代超时间和不带超时时间的，这里就演示All没有超时时间的

Any的话 这里就不演示了，使用和All是一样的，区别在于：只要有一个任务完成了，其他任务都会取消运行，同时返回的直接是一个Object，而并非是Future(也就是说any会阻塞当前线程)

使用

```java

@Slf4j(topic = "c.TestThreadPoolExecutors")
public class TestThreadPoolExecutors {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService pool = Executors.newFixedThreadPool(2);
        List<Future<Integer>> futures = pool.invokeAll(Arrays.asList(
                () -> {
                    log.info("begin1");
                    Thread.sleep(1000);
                    return 1;
                },
                () -> {
                    log.info("begin2");
                    Thread.sleep(1500);
                    return 2;
                },
                () -> {
                    log.info("begin3");
                    Thread.sleep(2000);
                    return 3;
                }
        ));
        futures.forEach(f -> {
            try {
                log.info("{}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
    }
}
```

运行结果：

```text
01:03:25.240 [pool-1-thread-1] INFO c.TestThreadPoolExecutors - begin1
01:03:25.240 [pool-1-thread-2] INFO c.TestThreadPoolExecutors - begin2
01:03:26.249 [pool-1-thread-1] INFO c.TestThreadPoolExecutors - begin3
01:03:28.252 [main] INFO c.TestThreadPoolExecutors - 1
01:03:28.253 [main] INFO c.TestThreadPoolExecutors - 2
01:03:28.254 [main] INFO c.TestThreadPoolExecutors - 3
```

这里第三个线程慢一拍的原因是我的线程池内只设置了两个大小，所以第三个要等其中一个执行完毕后才会从队列进入到线程池内执行

## 关闭线程池

### shutdown

```java

/**
 * 将线程池状态设置为SHUTDOWN
 * - 不会接收新的任务
 * - 但会将已经提交的任务执行完
 * - 此方法不会阻塞调用线程的执行
 */
void shutdown();
```

实现代码如下

![shutdown](/images/Java/JavaThread/6-连接池和线程池/1642439648377.png)

### shutdownNow

```java

/**
 * 线程池状态变为STOP
 * - 不会接收新任务
 * - 会将队列中的任务返回
 * - 并用interrupt方式中断正在执行的任务
 */
List<Runnable> shutdownNow();
```

实现代码如下

![shutdownNow](/images/Java/JavaThread/6-连接池和线程池/1642439810684.png)

### 其他方法

```java
//不在RUNNING状态的线程池的话，调用此方法会返回true
boolean isShutdown();

//线程池状态是否为TERMINATED
        boolean isterminated();

// 调用shutdown之后，由于调用线程并不会等待所有的任务结束，因此如果想在线程池TERMINATED后做一些事情，可以利用此方法等待
        boolean awaitTermination(long timeout,TimeUnit unit)throws InterruptedException;
```

### shutdown和shutdownNow演示

代码如下，我懒得写了

![shutdown](/images/Java/JavaThread/6-连接池和线程池/1642440155151.png)

运行结果：程序正常地退出了

![quit](/images/Java/JavaThread/6-连接池和线程池/1642440182815.png)

如果说想在退出后再添加新的任务，则会抛出异常

![error](/images/Java/JavaThread/6-连接池和线程池/1642440235008.png)

如果说加了`awaitTermination`代码，那么主线程将会阻塞至指定的时间或者说有的任务都执行完了

![await](/images/Java/JavaThread/6-连接池和线程池/1642440276341.png)

如果使用了shutdownNow的话

![shutdownNow](/images/Java/JavaThread/6-连接池和线程池/1642440485970.png)

## 异步模式之工作线程

### 定义

让有限的线程池(Worker Thread)来轮流处理异步无限多的任务，也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式

例如：海底捞的服务员(线程)，轮流处理让每位客人点餐(任务)，如果为每位客人都分配一名专属的服务员，那么服务成本太高了

注意，不同的任务类型应该使用不同的线程池，这样能够避免饥饿，提高效率

例如：如果一个餐馆工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B），显然效率不咋地，但是如果分成服务员(A)和厨师(B)更为合理，当然这是是个大概，还可以以后更极致的分公

### 饥饿

固定大小的线程池会有饥饿现象

- 两个工人同是同时用一个线程池中的两个线程
- 他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作
    - 客人点餐：必须先点餐、上菜、在此期间处理点餐的公人必须等待
    - 后厨做菜：没啥说的了，做就是了
- 比如工人A处理了点餐任务，接下来它要等着公人B把菜做好，然后上菜，他们两也配合得蛮好
- 但现在同时来了两个客人，这时候工人A和B都去处理点餐了，没人做饭了，死锁

```java

@Slf4j(topic = "c.TestStarvation")
public class TestStarvation {
    static final List<String> MENU = Arrays.asList("地三鲜", "宫保鸡丁", "辣子鸡丁", "烤鸡爪");
    static Random RANDOM = new Random();

    static String cooking() {
        return MENU.get(RANDOM.nextInt(MENU.size()));
    }

    static main() {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        pool.execute(
                () -> {
                    log.debug("处理点餐");
                    Future<String> f = pool.submit(() -> {
                        log.debug("做菜");
                        return cooking();
                    });
                    try {
                        log.debug("上菜:{}", f.get());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
        );

        pool.execute(
                () -> {
                    log.debug("处理点餐");
                    Future<String> f = pool.submit(() -> {
                        log.debug("做菜");
                        return cooking();
                    });
                    try {
                        log.debug("上菜:{}", f.get());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
        );
    }
}
```

如果你运行上方程序，将会发现变成了这样：

![状态](/images/Java/JavaThread/6-连接池和线程池/1642481784604.png)

并且还检测不到死锁..这是因为程序的线程不足导致无法继续往下执行

这个时候，只需要将线程池的数量改成3就可以解决这个问题，但这并不是一个根本地解决之道，最好的解决方式是来两个线程池，一个专门负责点餐，一个专门负责做菜

![两个线程池](/images/Java/JavaThread/6-连接池和线程池/1642481987350.png)

### 创建多少个线程池比较合适

- 过小会导致程序不能充分利用系统资源，容易导饥饿
- 过大会导致更多的程序上下文切换，会占用更大的内存

### CPU密集型计算应该用的线程池数量

通常使用CPU的`核心数量+1`能够实现最优的CPU利用率，+1是保证当前线程由于页缺失故障（操作系统）或其他原因导致暂停时，额外的这个线程就能顶上去，保证CPU时钟周期不被浪费

### IO密集型计算

CPU不总是处于繁忙的状态，例如，执行业务计算的时候，这个时候会使用CPU资源，但是当我们执行IO操作时，远程RPC调用时，包括进行数据库操作时，这个时候CPU就闲下来了，可以利用多线程提高它的效率

> 公式如下

```text
线程数 = 核心数量 * 期望CPU利用率 * 总时间(CPU计算时间+等待时间) / CPU计算时间
```

例如4核CPU计算时间是50%，其他等待时间是50%,期望CPU被百分之百利用，套用公式

```text
4 * 100% * 100% / 50% = 8
```

例如4核CPU的计算时间是10%，其他等待时间是90%，希望CPU被百分之百利用，套用公式：

```text
4 * 100% * 100% / 10% = 40
```

## 任务调度线程池

### timer的缺点

在【任务调度线程池】加入之前，可以使用`java.util.Timer` 来实现定时功能，TImer的优点在于简单易用，但是由于所有任务都是由同一个线程来调度，因此所有的任务都是串行执行的

同一时间只能有一个任务在执行，前一个任务的延迟或异常都会影响到之后的任务

```java

@Slf4j(topic = "c.TestTimer")
public class TestTimer {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask task1 = new TimerTask() {

            @Override
            public void run() {
                log.debug("task 1");
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };

        TimerTask task2 = new TimerTask() {

            @Override
            public void run() {
                log.debug("task 2");
            }
        };

//        使用timer添加两个任务，希望他们都在1s之后执行
//        但是由于timer内只有一个线程来顺序的执行队列中的任务，因此【任务1】开启时，影响了【任务2】的执行

        timer.schedule(task1, 1000);
        timer.schedule(task2, 1000);


    }
}
```

可以看到，task2和1并不是同时执行的，而是在task1执行完毕后才进入执行状态

```text
13:21:54.816 [Timer-0] DEBUG c.TestTimer - task 1
13:21:56.836 [Timer-0] DEBUG c.TestTimer - task 2
```

并且如果任务1出现了异常

![error](/images/Java/JavaThread/6-连接池和线程池/1642485127238.png)

那么在抛出异常后，任务二以及后续的任务都会被终止

![终止](/images/Java/JavaThread/6-连接池和线程池/1642485164088.png)

### ScheduleThreadPoolExceutor-延时执行

使用起来非常简单，给定三个参数即可

```java

@Slf4j(topic = "c.TestTimer")
public class TestTimer {
    public static void main(String[] args) {
//        这里设置的实际上是核心线程数
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);

//        接收三个参数，第一个是任务，第二个是延迟时间，第三个是延迟时间单位
        pool.schedule(() -> {
            log.debug("task1");
            try {
                TimeUnit.SECONDS.sleep(2);
                log.debug("task1-over");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, 1, TimeUnit.SECONDS);

        pool.schedule(() -> {
            log.debug("task2");
            log.debug("task2-over");
        }, 1, TimeUnit.SECONDS);
    }
}
```

返回结果，因为我们给定的是两个线程，所以他们是同时执行

```text
14:06:41.112 [pool-1-thread-1] DEBUG c.TestTimer - task1
14:06:41.112 [pool-1-thread-2] DEBUG c.TestTimer - task2
14:06:41.115 [pool-1-thread-2] DEBUG c.TestTimer - task2-over
14:06:43.125 [pool-1-thread-1] DEBUG c.TestTimer - task1-over
```

并且，即使我们将线程池大小设定为1，同时让task1抛出异常，也不会影响到后续的执行

![异常](/images/Java/JavaThread/6-连接池和线程池/1642486264821.png)

### ScheduleThreadPoolExceutor-定时执行

我们有的时候希望任务并不是延迟执行，而是每隔一段时间执行一次，这就是定时执行（例如linux中的corn）

使用非常简单

```java

@Slf4j(topic = "c.TestTimer")
public class TestTimer {
    public static void main(String[] args) {
//        这里设置的实际上是核心线程数
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
//        参数1 任务对象，参数2 延时的时间 参数3 执行的间隔 参数4时间单位
        log.debug("start....");
        pool.scheduleAtFixedRate(() -> {
            log.info("running...");
        }, 1, 5, TimeUnit.SECONDS);
//        上面这里是在一秒后，每隔5秒执行一次


    }
}
```

可以看到，在程序开始一秒后，它以每隔五秒的方式在持续运行

![运行](/images/Java/JavaThread/6-连接池和线程池/1642486732495.png)

> 注意：如果说我们每次任务的执行时间大于间隔时间（也就是任务的运行时间大于第三个参数），那么间隔时间将会延后

```java

@Slf4j(topic = "c.TestTimer")
public class TestTimer {
    public static void main(String[] args) {
//        这里设置的实际上是核心线程数
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
//        参数1 任务对象，参数2 延时的时间 参数3 执行的间隔 参数4时间单位
        log.debug("start....");
        pool.scheduleAtFixedRate(() -> {
            log.info("running...");
//            延迟5秒
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("run结束了");

        }, 1, 1, TimeUnit.SECONDS);
//        上面这里是在一秒后，每隔1秒执行一次
    }
}
```

可以看到，运行的时间收到了改变--即使我们设定的是1s执行一次

![running](/images/Java/JavaThread/6-连接池和线程池/1642486942568.png)

> 这样是为了防止我们的代码进行重叠
>
> 这个东西的应用场景比较多，例如每隔xx小时执行一次任务备份之类的

如果说我们是想在上次任务结束后的基础上增加指定的时间，可以使用官方提供的另外一个方法`scheduleWithFixedDelay`

```java

@Slf4j(topic = "c.TestTimer")
public class TestTimer {
    public static void main(String[] args) {
//        这里设置的实际上是核心线程数
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);
//        参数1 任务对象，参数2 延时的时间 参数3 执行的间隔 参数4时间单位
        log.debug("start....");
        pool.scheduleWithFixedDelay(() -> {
            log.info("running...");
//            延迟5秒
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("run结束了");

        }, 1, 1, TimeUnit.SECONDS);
//        上面这里是在一秒后，每隔1秒执行一次
    }
}
```

这里我是开了两个线程，实际上开几个都是这样的效果

```text
14:28:49.113 [main] DEBUG c.TestTimer - start....
14:28:50.179 [pool-1-thread-1] INFO c.TestTimer - running...
14:28:55.180 [pool-1-thread-1] DEBUG c.TestTimer - run结束了
14:28:56.195 [pool-1-thread-1] INFO c.TestTimer - running...
14:29:01.200 [pool-1-thread-1] DEBUG c.TestTimer - run结束了
```

可以看到，我们第一次运行是在`50`的时候，第一次运行结束是在`55`,然后第二次是从`56`才开始执行

### 正确处理线程池异常的方法

任何线程池都适用这种方法式

1. 用Try-Catch把全部代码都包裹起来，一块处理，让任务自身来处理异常
2. 借助Future来完成

第一种我就不演示了，一般项目中都是只允许使用第一种方式，接下来演示下第二种

```java

@Slf4j(topic = "c.TestTimer")
public class TestTimer {
    public static void main(String[] args) throws InterruptedException {
//        这里设置的实际上是核心线程数
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);
        ScheduledFuture<Boolean> task1 = pool.schedule(() -> {
            log.debug("task1");
            int i = 1 / 0;
            return true;
        }, 1, TimeUnit.SECONDS);
        try {
            log.info("task1-result:{}", task1.get());
        } catch (Exception e) {
            log.error("task1-result-Error:{}", e.getMessage());
        }

        pool.shutdown();
    }
}
```

运行结果：

```text
14:38:37.541 [pool-1-thread-1] DEBUG c.TestTimer - task1
14:38:37.544 [main] ERROR c.TestTimer - task1-result-Error:java.lang.ArithmeticException: / by zero
```

### 定时任务的应用-每周四十八点执行任务

例如我想在每周四18点打印一句话之类的，反正按照下面的模板来套就行了，扩展性也蛮高

```java

@Slf4j(topic = "c.TestTimer")
public class TestTimer {
    public static void main(String[] args) throws InterruptedException {
//        这里设置的实际上是核心线程数
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);

//        当前时间和周四18点的间隔（毫秒）

//        获取当前时间
        LocalDateTime now = LocalDateTime.now();

//        修改时间到 18：00：00
        LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0);
//        修改到周四
        time = time.with(DayOfWeek.TUESDAY);

//        如果当前时间大于本周周四，则必须到下周周四才能执行
        if (now.compareTo(time) > 0) {
//            到下周周四
            time = time.plusWeeks(1);
        }

//        将两个时间进行计算，得到间隔时间，并转换成毫秒,得到延迟时间
        long initialDelay = Duration.between(now, time).toMillis();

//        一周的时间间隔（毫秒）
        long period = 1000 * 60 * 60 * 24 * 7;

        pool.scheduleAtFixedRate(() -> {
            log.debug("现在是xxx，执行了xx");
        }, initialDelay, period, TimeUnit.MILLISECONDS);

    }
}
```

## Tomcat线程池

众所周知，tomcat分为两个部分，一个是连接器，专门负责和外界沟通，一个是Context，给我们使用，连接器NIO如下图所示

![Tomcat线程池](/images/Java/JavaThread/6-连接池和线程池/1642489170302.png)

- LimitLatch用来限流，可以用来控制最大线程个数，类似于JUC中的Semaphore(这个后面会说)
- Acceptor只负责【接受新的Socket】连接
- Poller只负责监听`socket channel`是否有【可读的IO事件】
- 一旦可读，封装一个任务对象(`socketProcessor`)，提交给`Executors`线程池处理
- `Executors`线程池中的工作线程是负责【处理请求】

Tomcat的线程池扩展了ThreadPoolExecutor，行为稍有不同

- 如果总线程达到了maximumPoolSize
    - 这时不会立刻抛RejectExecutionException异常
    - 而是尝试再次将任务放入任务队列，如果还是失败，才会抛出RejectExecutionException异常

![异常](/images/Java/JavaThread/6-连接池和线程池/1642489688139.png)

### Connector配置

下面的配置可以直接在tomcat的配置文件中配置(应该也可以在springboot内这样配置)

| 配置项                | 默认值 | 说明                                 |
| --------------------- | ------ | ------------------------------------ |
| `acceptorThreadCount` | 1      | Acceptor线程数量                     |
| `pollerThreadCount`   | 1      | Poller线程数量                       |
| `minSpareThreads`     | 10     | 核心线程数量，也就是corePoolSize     |
| `maxThreads `         | 200    | 最大线程数，也就是maximumPoolSize    |
| `executor`            | -      | Executor名称，直接引用下面的Executor |

### Executor配置

| 配置项                  | 默认值            | 说明                                                                 |
| ----------------------- | ----------------- | -------------------------------------------------------------------- |
| threadPriority          | 5                 | 线程优先级                                                           |
| daemon                  | true              | 是否守护线程                                                         |
| minSpareThreads         | 25                | 核心线程数，也就是corePoolSize                                       |
| maxThreads              | 200               | 最大线程数，也就是maximumPoolSize                                    |
| maxIdleTime             | 60000             | 线程(救急)的生存时间，单位是毫秒，即：默认一分钟                     |
| maxQueueSize            | Integer.MAX_VALUE | 队列长度，默认是无界的，有的时候可以手动调成一个合适的值             |
| prestartminSpareThreads | false             | 核心线程是否在服务器启动时启动，也就是是否懒惰创建线程，默认是懒惰的 |

流程大概是这样的

![流程](/images/Java/JavaThread/6-连接池和线程池/1642490563696.png)


## Fork/Join 线程池

### 概念

Fork/Join线程池是JDK1.7新加的线程池实现，它体现的是一种分制思想，适用于能够进行任务拆分的cpu密集型运算

所谓的任务拆分，就是将一个大的任务分为算法上相同的小任务，直至不能拆分可以直接直接求解，跟递归相关的一些计算，例如并归排序、斐波那契数列等都可以用分制思想进行求解

Fork/Join在分制的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步地提升了运算效率

Fork/Join会默认创建和CPU核心大小相同数量的线程池

### 使用

提交给Fork/Join线程池的任务需要继承`RecursiveTask`，也就是有返回值，或者`RecursiveAction`没有返回值

我们来用它实现一个1~n之间的整数求和任务

首先我们需要自定义一个类来继承`RecursiveTask`

```java
/**
 * 求1~n之间整数的和
 */
@Slf4j(topic = "c.MyTask")
class MyTask extends RecursiveTask<Integer> {

  private int n;

  public MyTask(int n) {
    this.n = n;
  }

  @Override
  protected Integer compute() {
//     终止条件
    if (n == 1) {
      log.debug("join:{}", n);
      return n;
    }
    MyTask t1 = new MyTask(n - 1);
//        让一个线程去执行此任务
    t1.fork();
    log.debug("fork(): {}+{}", n, t1.join());
//        获取任务结果
    int result = t1.join() + n;
    log.debug("join(): {}+{}={}", t1.join(), n, result);
    return result;
  }
}
```

接着调用它

```java
@Slf4j(topic = "c.TestTaskPool")
public class TestTaskPool {
  public static void main(String[] args) {
    ForkJoinPool pool = new ForkJoinPool();
    Integer invoke = pool.invoke(new MyTask(10));
    log.info("invoke的值：" + invoke);
    log.info("当前线程池的数量：" + pool.getPoolSize());
  }
}
```

看看log

```text
15:48:29.524 [ForkJoinPool-1-worker-4] DEBUG c.MyTask - join:1
15:48:29.527 [ForkJoinPool-1-worker-4] DEBUG c.MyTask - fork(): 2+1
15:48:29.528 [ForkJoinPool-1-worker-4] DEBUG c.MyTask - join(): 1+2=3
15:48:29.528 [ForkJoinPool-1-worker-4] DEBUG c.MyTask - fork(): 3+3
15:48:29.528 [ForkJoinPool-1-worker-4] DEBUG c.MyTask - join(): 3+3=6
15:48:29.528 [ForkJoinPool-1-worker-3] DEBUG c.MyTask - fork(): 4+6
15:48:29.528 [ForkJoinPool-1-worker-3] DEBUG c.MyTask - join(): 6+4=10
15:48:29.528 [ForkJoinPool-1-worker-2] DEBUG c.MyTask - fork(): 5+10
15:48:29.528 [ForkJoinPool-1-worker-2] DEBUG c.MyTask - join(): 10+5=15
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - fork(): 6+15
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - join(): 15+6=21
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - fork(): 7+21
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - join(): 21+7=28
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - fork(): 8+28
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - join(): 28+8=36
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - fork(): 9+36
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - join(): 36+9=45
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - fork(): 10+45
15:48:29.528 [ForkJoinPool-1-worker-1] DEBUG c.MyTask - join(): 45+10=55
15:48:29.528 [main] INFO c.TestTaskPool - invoke的值：55
15:48:29.528 [main] INFO c.TestTaskPool - 当前线程池的数量：8
```

用图片来表示就是这样

![结果](/images/Java/JavaThread/6-连接池和线程池/1642492237818.png)

